---
layout: single
title:  "1주차"
categories: TIL
tag: [java]
author_profile: false
toc: true
toc_label: "TIL"
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## 객체와 클래스 그리고 인스턴스
* ***객체***
    * 물리적, 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.
	* 소프트웨어 에서 구현할 대상
* ***클래스***
	* java에서 객체를 생성하기 위한 일종의 설계도
	* 속성(필드)을 가지고 있고, 행위(메소드)를 가지고있다.
	* oop의 관점에서 클래스 타입으로 선언되었을 때 '객체'라고 부른다.
* ***인스턴스***
	* 클래스를 가지고 객체를 실체화 한것.
	* 메모리에 할당되어 실제로 사용되는 객체
    
## 절차형, 객체지향, 함수형 패러다임
* ***절차형 프로그래밍 (Procedural Programming)***
<br>
위에서부터 아래로의 순차적인 처리를 중요시 하며 루틴, 서브루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임
	* ***장점***
		* 컴퓨터 처리구조와 유사해 실행속도가 빠르다.
	* ***단점***
		* 코드가 길어지면 가독성이 떨어지며 유지보수가 어렵다.
		* 정해진 순서대로 입력을 해야하므로 순서가 바뀌면 결과를 보장할 수 없다.
		* 대형 프로젝트에 적합하지 않다.

* ***객체지향 프로그래밍 (OOP)***
<br>
모든 것을 객체로 취급하고 객체가 처리요청을 받았을 때, 객체 내부의 기능을 사용해 처리하는 방법이다.
<br>
클래스 디자인과 객체들의 관계를 중심으로 설계가 이루어진다.
<br>
따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있고, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라진다.
	* ***특징***
		* 캡슐화 - 정보를 은닉하고 노출시키지 않는다.
		* 추상화 - 공통적인 속성이나 기능을 묶는다.
		* 상속 - 아래 더 자세히..
		* 다형성 - 아래 더 자세히..
	* ***장점***
		* 재사용에 용이하다. (확장, 유지보수)
		* 분석과 설계의 전환이 쉽다.
	* ***단점***
		* 처리속도가 상대적으로 느리다.
		* 모든 객체의 역할과 기능을 설계해야 하기 때문에 많은 시간이 소요된다.

* ***함수형 프로그래밍***
<br>
순수함수를 사용해 상태를 제어하지 않고 빠른 처리에 집중하는 방식, 함수 자체가 일급객체가 된다. 
<br>
OOP와는 데이터(상태)를 다루는 개념과, 간결한 코드 작성에 대한 관점차이가 있다.
<br>
<br>
***일급객체*** - 다른 요소들과 아무런 차별이 없는 객체, 함수를 변수로 사용할 수 있다는 의미도 된다.
<br>

	* ***장점***
		* 함수가 하는일은 명확하기 때문에 코드의 가독성이 좋아지고 테스트가 쉬워진다.
		* 값이 한번 변수에 할당되면 이후에 변경되지 않기 때문에 부수효과가 발생하지 않으며 참조투명성을 가진다. 즉, 멀티코어 프로세스에서 교착상태에 빠지지 않는다.
		* 동시성 프로그래밍에 용이하다.
	* ***단점***
		* 상태의 조작이 불가능하다.

<br>
* ***그래서 뭐가 좋은데?***
<br>
자바8에서 함수형 프로그래밍을 도입했다. 
<br>
객체지향을 추구하는 자바진영에서 왜 함수형 프로그래밍을 도입했을까?
<br>
데이터 자체를 핸들링하는 함수형 프로그래밍은 어떤 데이터가 들어가도 로직 수행 후 의도한 데이터를 리턴한다. 
하지만 객체지향은 여기에 상태까지 관리해 줘야 하기 때문에 신경 쓸것이 많다. 
<br>
현대 어플리케이션은 함수형과 객체지향을 모두 사용한다. 
<br>
예를들면, 내가 매일 작업하는 로직들은 함수형 이지만, 디비에 접근하는 순간만큼은 함수형일 수가 없다. 
<br>
데이터를 저장해야 하고 값을 리턴받아야 하고 등의 상태값이 존재하기 때문이다. 
<br>
이외에도 여러가지가 있겠지만 자바8에 추가된 람다의 함수형 프로그래밍도 이와 같다. 
<br>
람다로 코드를 짤 경우 데이터의 무결성을 보장한다. 
<br>
왜냐하면 전통적인 for루프의 경우 객체를 작업하지만 람다의 경우 데이터 그 자체를 핸들링 하기 때문이다.
<br>
결국 시대의 흐름에 맞게 병렬 프로세싱을 잘 활용하기위해 자바 8에서 도입을 했고 
<br>
뭐가 더 좋다기 보단 둘다 적재적소에 사용하는게 중요하겠다.


## 기본형 타입과 참조형 타입
* ***원시타입(Primitive type)***
	* 정수, 실수, 문자, 논리 리터럴등의 실제 데이터값을 저장하는 타입
	* 기본값이 있기때문에 Null이 존재하지 않는다. 기본형 타입에 Null을 넣고싶다면 래퍼클래스를 활용한다.
	* 제네릭 타입에서 사용할 수 없다.
	* 실제값을 저장하는 공간으로 Stack 영역에 저장된다.
	* 실제값이 Stack영역에 있으므로 참조타입보다 접근속도가 빠르다
* ***참조타입(Reference type)***
	* 객체의 주소를 저장하는 타입으로 메모리 번지값을 통해 객체를 참조하는 타입
	* 기본형 타입을 제외한 모든 타입은 참조형 타입이다. (문자열, 배열, 클래서, 열거, 인터페이스 등)
	* 제네릭 타입에서 사용할 수 있다.
	* 실제 객체는 Heap 영역에 저장되고 Stack영역에 객체의 주소를 저장해서 참조한다.
	* 실제값이 Heap 영역에 있고 Stack메모리에는 참조값만 있으므로 값이 필요할 때마다 최소 2번 메모리 접근을 해야하고 박싱/언박싱 과정을 거쳐야 해서 원시타입보다 접근속도가 느리다.
	* 실제 사용하는 메모리양도 원시타입보다 월등히 많다.
* ***String?***
	* 참조타입에 속하지만 기본적인 사용은 원시타입이다.
	* 불변객체이다. 그래서 String 클래스의 값을 변경하는 메소드를 사용해도 값이 변경되는 것이 아닌 새로운 String 객체를 만든다.
	* 기본형 비교는 == 사용이지만 String 간 객체비교는 equals()메소드를 사용한다.

## wrapper class는 무엇이며 왜쓰는가?
원시타입을 객체로 다루기 위해 사용하는 클래스이다. 기본타입의 값을 내부에 두고 포장해서 포장객체 라고도 불리는데 래퍼클래스로 감싸고 있는 값은 외부에서 변경이 불가능하고 변경하려면 새로운 포장객체를 만들어야 한다. 자바의 모든 객체가 그러하듯 Object를 상속받는다.
* ***박싱 / 언박싱***
	* 원시타입을 포장객체로 만드는게 박싱, 반대로 포장객체에서 원시타입을 얻는게 언박싱이다.
	* JDK 1.5 이후로 오토 박싱/언박싱을 지원 한다.
	* 래퍼객체 내부값을 비교하려면 equals를 사용해야 한다. == 는 래퍼 객체의 참조 주소를 비교하기 때문이다. 
	* 래퍼클래스와 원시타입 비교는 둘다 가능하다. JDK 1.5 이후로 오토 박싱/언박싱을 지원하기 때문이다
* ***왜 쓰는데?***
	* 원시타입을 클래스화 하여 클래스의 장점을 활용할 수 있다. (클래스에 지원되는 여러 메소드들)
	* null 지원
	* 기본타입을 객체로 써야할 경우가 있음
		* ex) List<Integer> 에 원시타입 값을 넣는다던가... (오토박싱/언박싱 지원)
	* 제네릭에 원시타입은 쓸수가 없음
	* ***일급콜렉션***
		* 콜렉션을 래핑할때, 그 외에 다른 멤버변수가 없는 상태를 일급콜렉션 이라한다.
		* 이렇게 되면 하나의 인스턴스에서 비즈니스 로직을 관리할 수 있게 되는 장점이 있다.
			* ex) 같은 객체를 여러개 생성해야 할때, 이 모든 인스턴스들을 담는 일급콜렉션을 만들다던가..
			* 비즈니스 로직을 도메인에서 관리 (비즈니스에 종속적인 자료구조를 만들 수 있음)

## 동일성과 동등성
* ***동일성***
	* 두 객체가 완전히 같은 경우.
	<br>
	주소값이 같기 때문에 하나의 객체로 봐도 무방하며 두 변수가 같은 객체를 참조한다.
	* == 연산자를 사용해 판별할 수 있다.
	* 원시타입은 객체가 아닌 스택메모리에 직접 값이 올라가기 때문에 == 결과가 같으면 동일하다.
* ***동등성***
	* 두 객체가 같은 정보를 가지고 있는 경우.
	<br>
	두 객체의 주소가 달라도 내용이 같으면 동등하다고 말할 수 있다.
	* equals를 사용해 판별할 수 있다.
	* ***equals***
		* equals 메소드를 재정의 하지 않으면 == 연산자와 다르지 않다.
		* 객체에서 재정의 할 경우 == 연산자를 통해 두객체가 동일하면 true를 반환하고, 다르다면 동등성을 판단한다.
		재정의 하지 않을 경우 동일성 여부만 판단하기 때문에 동등성비교가 필요하다면 꼭 재정의 해주어야 한다.
	* ***hashcode?***
		* equals를 재정의 해줄 때, hashcode도 같이 재정의하는걸 권장한다. 이유가 무엇일까?
		* Hash Table을 사용하는 자료형일 경우 문제가 된다. 
		<br>
		동등한 객체 2개를 생성해서 Set에 담게되면 의도한 대로 담기지 않는다. 
		<br>
		Set 자료구조는 중복을 허용하지 않기 때문인데, Hash Table을 사용하는 자료형은 해싱 알고리즘을 사용한다. 해싱된 결과를 주소값으로 찾아가서 같은 자료가 있는지 확인하는데 동등한 두 객체는 다른 주소값을 가지고 있기 때문에 객체의 동등성을 위해 equals메소드와 hashcode메소드는 같이 오버라이드 되어야 지만 동등성을 보장받을 수 있다.

<br>

# To Do

## 자바의 접근제어자
* ***접근제어자***
<br>
객체지향 패러다임에서 정보은닉이란 필요한 정보만 오픈한다는 개념이다.
<br>
자바에서는 정보은닉을 위해 접근제어자 라는 기능을 제공하여 클래스 외부에서 직접적인 접근을 허용하지 않는
변수, 메서드, 생성자를 설정할 수 있다.
<br>
***단, 인터페이스의 접근제어자는 무조건 public 이다.*** 
<br>
인터페이스는 구현클래스가 아니라 추상클래스 이기 때문에
해당 인터페이스를 구현하는 구현클래스에서 구현이 꼭 필요하다. 그렇기 때문에 접근제어자를 생략하더라도 컴파일시 public으로 열어둔다.
<br>
또한 클래스의 접근제한은 public 과 default만 적용할 수 있다.

* ***왜 쓰는데?***
	* 클래스 내부의 데이터를 보호하기 위해
	* 객체지향에서 캡슐화 라고 부른다.

* ***private***
<br>
private 으로 선언한 메서드나 변수는 해당 클래스 내에서만 접근이 가능하다.
<br>
외부에 공개되지 않으며, 외부에서는 private멤버에 직접 접근이 불가능하며 해당 객체의 public 메소드를
<br>
통해서만 접근이 가능하다.
<br>
그래서 보통 private 멤버는 클래스 내부의 세부적인 로직을 수행하는데 사용된다.
<br>
또한 생성자를 private 으로 생성하여 인스터스화를 방지할 수 있다.

* ***public***
<br>
public으로 선언된 클래스 멤버는 외부에서 접근이 가능하며, 프로그램 어디에서도 접근이 가능하다.
자바는 public메소드를 통해서만 해당 객체의 private멤버에 접근할수 있고, 따라서 public 메소드는 private 멤버와 외부사이의
인터페이스 역할을 수행한다고 할 수 있다.

* ***default***
<br>
아무것도 선언하지 않으면 default 접근자가 붙는다. 같은 패키지내에서만 접근이 가능하다.

* ***protected***
<br>
default 접근제어자 처럼 같은패키지 내에서 접근이 가능하지만, 좀더 범위가 넓다.
<br>
protected멤버는 부모 클래스에게는 public 멤버처럼 취급되며, 외부에서는 private 멤버로 취급된다.
<br>
결국 protected로 선언된 멤버는 아래와 같은 접근 영역을 가진다.
	* protected를 선언한 클래스의 멤버
	* protected를 선언한 클래스가 속한 패키지의 멤버
	* protected를 선언한 클래스를 상속받은 자식 클래스의 멤버


## 상속
## 다형성
## 자바의 신 2권