---
layout: single
title:  "1주차"
categories: TIL
tag: [java]
author_profile: false
toc: true
toc_label: "TIL"
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## 객체와 클래스 그리고 인스턴스
* ***객체***
    * 물리적, 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.
	* 소프트웨어 에서 구현할 대상
* ***클래스***
	* java에서 객체를 생성하기 위한 일종의 설계도
	* 속성(필드)을 가지고 있고, 행위(메소드)를 가지고있다.
	* oop의 관점에서 클래스 타입으로 선언되었을 때 '객체'라고 부른다.
* ***인스턴스***
	* 클래스를 가지고 객체를 실체화 한것.
	* 메모리에 할당되어 실제로 사용되는 객체
    
## 절차형, 객체지향, 함수형 패러다임
* ***절차형 프로그래밍 (Procedural Programming)***
<br>
위에서부터 아래로의 순차적인 처리를 중요시 하며 루틴, 서브루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임
	* ***장점***
		* 컴퓨터 처리구조와 유사해 실행속도가 빠르다.
	* ***단점***
		* 코드가 길어지면 가독성이 떨어지며 유지보수가 어렵다.
		* 정해진 순서대로 입력을 해야하므로 순서가 바뀌면 결과를 보장할 수 없다.
		* 대형 프로젝트에 적합하지 않다.

* ***객체지향 프로그래밍 (OOP)***
<br>
모든 것을 객체로 취급하고 객체가 처리요청을 받았을 때, 객체 내부의 기능을 사용해 처리하는 방법이다.
<br>
클래스 디자인과 객체들의 관계를 중심으로 설계가 이루어진다.
<br>
따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있고, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라진다.
	* ***특징***
		* 캡슐화 - 정보를 은닉하고 노출시키지 않는다.
		* 추상화 - 공통적인 속성이나 기능을 묶는다.
		* 상속 - 아래 더 자세히..
		* 다형성 - 아래 더 자세히..
	* ***장점***
		* 재사용에 용이하다. (확장, 유지보수)
		* 분석과 설계의 전환이 쉽다.
	* ***단점***
		* 처리속도가 상대적으로 느리다.
		* 모든 객체의 역할과 기능을 설계해야 하기 때문에 많은 시간이 소요된다.

* ***함수형 프로그래밍***
<br>
순수함수를 사용해 상태를 제어하지 않고 빠른 처리에 집중하는 방식, 함수 자체가 일급객체가 된다. 
<br>
OOP와는 데이터(상태)를 다루는 개념과, 간결한 코드 작성에 대한 관점차이가 있다.
<br>
<br>
***일급객체*** - 다른 요소들과 아무런 차별이 없는 객체, 함수를 변수로 사용할 수 있다는 의미도 된다.
<br>

	* ***장점***
		* 함수가 하는일은 명확하기 때문에 코드의 가독성이 좋아지고 테스트가 쉬워진다.
		* 값이 한번 변수에 할당되면 이후에 변경되지 않기 때문에 부수효과가 발생하지 않으며 참조투명성을 가진다. 즉, 멀티코어 프로세스에서 교착상태에 빠지지 않는다.
		* 동시성 프로그래밍에 용이하다.
	* ***단점***
		* 상태의 조작이 불가능하다.

<br>
* ***그래서 뭐가 좋은데?***
<br>
자바8에서 함수형 프로그래밍을 도입했다. 
<br>
객체지향을 추구하는 자바진영에서 왜 함수형 프로그래밍을 도입했을까?
<br>
데이터 자체를 핸들링하는 함수형 프로그래밍은 어떤 데이터가 들어가도 로직 수행 후 의도한 데이터를 리턴한다. 
하지만 객체지향은 여기에 상태까지 관리해 줘야 하기 때문에 신경 쓸것이 많다. 
<br>
현대 어플리케이션은 함수형과 객체지향을 모두 사용한다. 
<br>
예를들면, 내가 매일 작업하는 로직들은 함수형 이지만, 디비에 접근하는 순간만큼은 함수형일 수가 없다. 
<br>
데이터를 저장해야 하고 값을 리턴받아야 하고 등의 상태값이 존재하기 때문이다. 
<br>
이외에도 여러가지가 있겠지만 자바8에 추가된 람다의 함수형 프로그래밍도 이와 같다. 
<br>
람다로 코드를 짤 경우 데이터의 무결성을 보장한다. 
<br>
왜냐하면 전통적인 for루프의 경우 객체를 작업하지만 람다의 경우 데이터 그 자체를 핸들링 하기 때문이다.
<br>
결국 시대의 흐름에 맞게 병렬 프로세싱을 잘 활용하기위해 자바 8에서 도입을 했고 
<br>
뭐가 더 좋다기 보단 둘다 적재적소에 사용하는게 중요하겠다.


## 기본형 타입과 참조형 타입
* 원시타입(Primitive type)
	* 정수, 실수, 문자, 논리 리터럴등의 실제 데이터값을 저장하는 타입
	* 기본값이 있기때문에 Null이 존재하지 않는다. 기본형 타입에 Null을 넣고싶다면 래퍼클래스를 활용한다.
	* 제네릭 타입에서 사용할 수 없다.
	* 실제값을 저장하는 공간으로 Stack 영역에 저장된다.
	* 실제값이 Stack영역에 있으므로 참조타입보다 접근속도가 빠르다
* 참조타입(Reference type)
	* 객체의 주소를 저장하는 타입으로 메모리 번지값을 통해 객체를 참조하는 타입
	* 기본형 타입을 제외한 모든 타입은 참조형 타입이다. (문자열, 배열, 클래서, 열거, 인터페이스 등)
	* 제네릭 타입에서 사용할 수 있다.
	* 실제 객체는 Heap 영역에 저장되고 Stack영역에 객체의 주소를 저장해서 참조한다.
	* 실제값이 Heap 영역에 있고 Stack메모리에는 참조값만 있으므로 값이 필요할 때마다 최소 2번 메모리 접근을 해야하고 박싱/언박싱 과정을 거쳐야 해서 원시타입보다 접근속도가 느리다.
	* 실제 사용하는 메모리양도 원시타입보다 월등히 많다.
* String?
	* 참조타입에 속하지만 기본적인 사용은 원시타입이다.
	* 불변객체이다. 그래서 String 클래스의 값을 변경하는 메소드를 사용해도 값이 변경되는 것이 아닌 새로운 String 객체를 만든다.
	* 기본형 비교는 == 사용이지만 String 간 객체비교는 equals()메소드를 사용한다.

## wrapper class는 무엇이며 왜쓰는가?
* 기본타입을 객체로 써야할 경우가 있음 - 리스트에 넣던가

## 동일성과 동등성

<br>

# To Do

## 자바의 신 2권
## 자바의 4가지 접근제어자
## 상속
## 다형성