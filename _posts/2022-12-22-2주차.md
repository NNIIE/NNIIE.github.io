---
layout: single
title:  "2주차"
categories: TIL
tag: [java]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## enum
열거형이라고 부르며, 서로 연관된 상수들의 집합이다.
<br>
모든 열거형은 `Enum`클래스의 자손이며 `Enum`클래스의 멤버를 상속받는다.

* ***특징과 장점***
    * enum은 컴파일 후 `public static final` 필드이며 객체로 제공된다.
    * 상수들은 JVM 메서드 영역에 자리한다.
    * Enum클래스는 상수와 같이 인스턴스가 단 한번만 생성된다.
    * 컴파일 시점에 타입안정성이 보장되기 때문에 `private` 생성자만을 가진다. 
    <br>
    즉, 인스턴스 생성을 제어하며 싱글톤을 일반화 한다. (싱글톤 구현의 방법으로도 사용됨)
    * 그렇기 때문에 주소값을 비교하는 == 연산자의 사용이 가능하다.
    <br>
    즉, 객체의 값을 비교하는 equals()보다 빠르고 컴파일 단계에서 검사되기 때문에 실수를 방지할 수 있다.

<br>

* ***Enum클래스의 메서드***
    * ***values()*** : enum클래스의 모든 상수를 배열로 반환한다.

    ```java
    // values 활용
    public static LottoRank countOfMatchNumber(int countOfMatchNumber) {
        return Arrays.stream(values())
                .filter(LottoRank -> LottoRank.countOfMatchNumber == countOfMatchNumber)
                .findAny()
                .orElse(MISS);
                // 또는 orElseThrow(new IllegalArgumentException(error message))
    }
    ```

    * ***valueOf()*** : `String`을 매개변수로 받아 일치하는 상수를 반환한다. (없으면 런타임 에러 발생)
    * ***ordinal()*** : 상수들의 index를 반환한다.

<br>

* ***단점***
<br>
enum자체가 가지는 비용이 적지 않다. static final 상수로도 충분하다면 enum의 사용 여부는 고려해보자
    
<br>

## 싱글톤패턴
객체의 인스턴스가 오직 1개만 생성되는 패턴이다.
<br>
하나의 인스턴스로 공유되며 접근, 사용할 수 있다

* 가장 단순한 코드레벨의 싱글톤 패턴
	
```java
// 동시성 이슈를 배제한 Lazy initialization 방식
// Thread Safety 하지 않다.
public class Person {
    private static Person instance = null;
    
    private Person() {
    }
    
    public static Person getInstance() {
        if (instance == null) {
            instance = new Person();
        }
        return instance;
    }
}
```
	
* ***장점***
	* 인스턴스가 하나기 때문에 매번 새로 인스턴스를 생성할 필요가 없다.
	* 싱글톤 패턴으로 만들어진 클래스는 전역 인스턴스이기 때문에 접근하기 편하다.

* ***단점***
	* 클라이언트가 구체클래스에 의존 -> DIP OCP 위반
	* 멀티스레드 환경에서 인스턴스가 하나이기 때문에 문제가 발생할 수 있다.
	* 테스트가 어렵다. 인스턴스가 하나기 때문에 테스트를 하려면 매번 초기화를 시켜주어야 한다.

<br>

* ***사용법?***
	* ***synchronized*** : 사용하지 말자. 락을 걸어버리는 방법으로 동기화 문제를 간단하고 확실하게 해결하지만 그렇기 때문에 멀티스레드의 이점을 모두 막아버린다.
	* ***Lazy initialization + Double-checked Locking*** : 이것도 좋지 않다.

	```java
	// 조건문으로 먼저 인스턴스를 확인한 다음 synchronized를 동기화 시켜 인스턴스를
	// 생성하는방법, 처음 생성이후 synchronized를 실행하지 않아서 성능저하 완화 가능
	public class Person {
        private static volatile Person instance;
        
        private Person() {
        }
		
		public static Person getInstance() {
			if (instance == null) {
				synchronized (Person.class) {
					if (instance == null) {
						instance = new Person();
					}
				}
			}
			return instance;
		}
	}
	```

	* ***Initialization on demand holder idiom*** : 제일 많이 사용되는 방법

	```java
	// 클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는
	// 시점을 이용한 방법
	public class Person {
		private Person() {
		}
		
		private static class LazyHorder {
			public static final Person INSTANCE = new Person();
		}

		public static Person getInstance() {
			return LazyHorder.INSTANCE;
		}
	}
	```

	* ***스프링 컨테이너를 사용하는게 가장 좋다.***
		* 상태를 유지(stateful)하면 안되고 무상태(stateless)로 설계해야 한다.
		* 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
		* 읽기만 가능해야 한다.
		* 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
		* `@Configuration`, `@Bean`을 같이 사용한다.

<br>

## HashTable
key와 value의 쌍으로 이루어진 데이터 구조이다.
<br>
해시충돌이 일어나지 않는 가정 하에 평균 시간복잡도 O(1)로 효율적이다. 
<br>
이는 배열에서 `index`를 알고 접근하는 것과 동일한 시간복잡도를 보인다.

* ***key*** : 해시함수의 input이 되는 고유 값, 키는 해시함수를 통해 해시로 변경되고 `index` 역할을 하게된다.
* ***value*** : 저장소(버킷, 슬롯)에 최종적으로 저장되는 값.
* ***Hash*** : 임의의 값을 가지는 key값을 고정된 길이로 변환하는 것
* ***Hash Function*** : 임의의 값을 고정된 크기의 값으로 변환하는 함수.  key -> hash
* ***저장소(Bucket, Slot)*** : Hash Table 에서 하나의 데이터가 저장되는 공간
* ***해시충돌*** : 서로 다른 key가 같은 hash값이 되는 경우

	* ***데이터 저장***
		<br>
		해시함수를 이용해 키값을 해시로 변경한 후 미리 준비해둔 저장소(버킷, 슬롯)중 
		<br>
		알맞는 해시값을 찾아 value를 저장한다.
		<br>
		이 과정의 시간복잡도는 O(1) 이다.

	* ***데이터 삭제***
		<br>
		버킷에서 삭제하려고 하는 key와 매핑되는 value값을 찾아서 삭제한다
		<br>
		이 과정의 시간복잡도는 O(1) 이다.

	* ***데이터 검색***
		<br>
		key를 이용해 value를 찾아내는 과정.
		<br>
		먼저 key값과 해시함수를 이용해 hash를 찾아내고 해당 hash로 value를 찾는다.
		<br>
		이 과정의 시간복잡도는 O(1) 이다.

<br>

* ***자바의 Hash?***
	* 자바에서는 `Object`클래스의 hashCode() 메서드로 모든 객체의 해시코드를 쉽게 구할 수 있다 
	* 자바는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 중복되지 않는 값을 제공한다.
	* String의 경우 `Object`로부터 상속받은 hashCode()를 오버라이딩 하여 문자열의 내용으로 해시코드를 만들어 낸다. 그렇기 때문에 다른 인스턴스의 String이어도 문자열이 같다면 같은 해시코드값을 가진다.
	* HashMap도 같은 방법으로 객체를 구별하기 때문에 이미 존재하는 키와 동일한 값을 저장하면 기존의 값을 덮어쓰게 된다.

<br>

* ***HashTable과 HashMap***
	<br>
	둘의 차이는 `Thread-Safe` 의 차이이다. 
	<br>
	HashTable은 동기화가 걸려있어 안전하지만 느리고 HashMap은 동기화가 없어서 불안전하지만 빠르다.

<br>

* ***단점***
	* 정렬이나 순차적인 데이터 저장에 적합하지 않다
	* 데이터가 저장되기 전에 저장공간을 확보해야 하기 때문에 공간효율성이 떨어진다.
	* Hash Function이 복잡할수록 연산속도가 증가한다.
	* 해시충돌이 발생할 경우 최악의 경우 시간복잡도가 O(N) 에 점점 수렴함

<br>

## Set 자료구조 확인하기
* 성능적으로 어떻게 사용하면 훨씬 효율적일까? 예를들면 contains

<br>

## 인터페이스

<br>

## 추상클래스

<br>

## 둘의 차이
* 가장 중요한건 필드 즉, 상태값을 가진다 못가진다의 차이였지만 인터페이스의 디폴트 메서드는 무엇인가?

<br>

## Strangler Pattern (교살자 패턴)

<br>

# To Do

<br>

## 인터페이스

<br>

## default method
* 디폴트 메서드랑 일반 메서드랑 뭐가달라서 인터페이스에서 사용할 수 있게 됬지?

<br>

## 자바의 신 2권