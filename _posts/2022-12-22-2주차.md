---
layout: single
title:  "2주차"
categories: TIL
tag: [java]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## enum
열거형이라고 부르며, 서로 연관된 상수들의 집합이다.
<br>
모든 열거형은 `Enum`클래스의 자손이며 `Enum`클래스의 멤버를 상속받는다.

* ***특징과 장점***
    * enum은 컴파일 후 `public static final` 필드이며 객체로 제공된다.
    * 상수들은 JVM 메서드 영역에 자리한다.
    * Enum클래스는 상수와 같이 인스턴스가 단 한번만 생성된다.
    * 컴파일 시점에 타입안정성이 보장되기 때문에 `private` 생성자만을 가진다. 
    <br>
    즉, 인스턴스 생성을 제어하며 싱글톤을 일반화 한다. (싱글톤 구현의 방법으로도 사용됨)
    * 그렇기 때문에 주소값을 비교하는 == 연산자의 사용이 가능하다.
    <br>
    즉, 객체의 값을 비교하는 equals()보다 빠르고 컴파일 단계에서 검사되기 때문에 실수를 방지할 수 있다.

<br>

* ***Enum클래스의 메서드***
    * ***values()*** : enum클래스의 모든 상수를 배열로 반환한다.

    ```java
    // values 활용
    public static LottoRank countOfMatchNumber(int countOfMatchNumber) {
        return Arrays.stream(values())
                .filter(LottoRank -> LottoRank.countOfMatchNumber == countOfMatchNumber)
                .findAny()
                .orElse(MISS);
                // 또는 orElseThrow(new IllegalArgumentException(error message))
    }
    ```

    * ***valueOf()*** : `String`을 매개변수로 받아 일치하는 상수를 반환한다. (없으면 런타임 에러 발생)
    * ***ordinal()*** : 상수들의 index를 반환한다.

<br>

* ***단점***
<br>
enum자체가 가지는 비용이 적지 않다. static final 상수로도 충분하다면 enum의 사용 여부는 고려해보자
    
<br>

## 싱글톤패턴
객체의 인스턴스가 오직 1개만 생성되는 패턴이다.
<br>
하나의 인스턴스로 공유되며 접근, 사용할 수 있다

* 가장 단순한 코드레벨의 싱글톤 패턴
	
```java
// 동시성 이슈를 배제한 Lazy initialization 방식
// Thread Safety 하지 않다.
public class Person {
    private static Person instance = null;
    
    private Person() {
    }
    
    public static Person getInstance() {
        if (instance == null) {
            instance = new Person();
        }
        return instance;
    }
}
```
	
* ***장점***
	* 인스턴스가 하나기 때문에 매번 새로 인스턴스를 생성할 필요가 없다.
	* 싱글톤 패턴으로 만들어진 클래스는 전역 인스턴스이기 때문에 접근하기 편하다.

* ***단점***
	* 클라이언트가 구체클래스에 의존 -> DIP OCP 위반
	* 멀티스레드 환경에서 인스턴스가 하나이기 때문에 문제가 발생할 수 있다.
	* 테스트가 어렵다. 인스턴스가 하나기 때문에 테스트를 하려면 매번 초기화를 시켜주어야 한다.

<br>

* ***사용법?***
	* ***synchronized*** : 사용하지 말자. 락을 걸어버리는 방법으로 동기화 문제를 간단하고 확실하게 해결하지만 그렇기 때문에 멀티스레드의 이점을 모두 막아버린다.
	* ***Lazy initialization + Double-checked Locking*** : 이것도 좋지 않다.

	```java
	// 조건문으로 먼저 인스턴스를 확인한 다음 synchronized를 동기화 시켜 인스턴스를
	// 생성하는방법, 처음 생성이후 synchronized를 실행하지 않아서 성능저하 완화 가능
	public class Person {
        private static volatile Person instance;
        
        private Person() {
        }
		
		public static Person getInstance() {
			if (instance == null) {
				synchronized (Person.class) {
					if (instance == null) {
						instance = new Person();
					}
				}
			}
			return instance;
		}
	}
	```

	* ***Initialization on demand holder idiom*** : 제일 많이 사용되는 방법

	```java
	// 클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는
	// 시점을 이용한 방법
	public class Person {
		private Person() {
		}
		
		private static class LazyHorder {
			public static final Person INSTANCE = new Person();
		}

		public static Person getInstance() {
			return LazyHorder.INSTANCE;
		}
	}
	```

	* ***스프링 컨테이너를 사용하는게 가장 좋다.***
		* 상태를 유지(stateful)하면 안되고 무상태(stateless)로 설계해야 한다.
		* 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
		* 읽기만 가능해야 한다.
		* 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
		* `@Configuration`, `@Bean`을 같이 사용한다.



## hash
* 작동하는 방식이라던가..

## Set 자료구조 확인하기
* 성능적으로 어떻게 사용하면 훨씬 효율적일까? 예를들면 contains

## 인터페이스

## 추상클래스

## 둘의 차이
* 가장 중요한건 필드 즉, 상태값을 가진다 못가진다의 차이였지만 인터페이스의 디폴트 메서드는 무엇인가?

## Strangler Pattern (교살자 패턴)

<br>

# To Do

## 인터페이스

## default method
* 디폴트 메서드랑 일반 메서드랑 뭐가달라서 인터페이스에서 사용할 수 있게 됬지?

## 자바의 신 2권