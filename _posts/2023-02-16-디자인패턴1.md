---
layout: single
title:  "Design Pattern"
categories: TIL
tag: [어댑터 패턴, 프록시 패턴, 데코레이터 패턴, 싱글톤 패턴, 템플릿 메서드 패턴, 팩터리 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>

# 디자인패턴
일종의 설계 템플릿으로, 구체적인 구현방법을 제시하는것이 아니라 어떤 문제에 대해
<br>
어떤 구조와 접근법이 적절한지에 대한 **가이드라인**이다.
<br>
소프트웨어가 점점 복잡해지면서 다양한 문제가 발생하게 되었고, 이런 문제를 해결하기 위해
<br>
많은 개발자들이 각자의 방식으로 접근하다보니 비슷한 문제를 다른방식으로 해결하는 경우가 많았다.
<br>
결국 유지보수 등의 어려움을 겪게되고, 이러한 문제를 해결하기 위해 많은 개발자들의 전문지식을 모아
<br>
이미 검증된 방식을 **템플릿 형태**로 모아 **가이드라인**을 제시하게 되었다. 
<br>
이로써, 소프트웨어의 유연성, 확장성, 생산성, 픔질 향상에 큰 도움이 된다.

<br>
<br>
<br>
<br>

## 어댑터 패턴 - Adapter Pattern
호환되지 않는 두 **인터페이스**를 연결하여 함께 동작할 수 있게 만드는 디자인 패턴이다.
<br>
코드를 수정하지 않아도 다른 객체와 동작할 수 있고 유지보수, 확장성, 재사용성에 용이하다.
<br>
또한 어댑터를 중간에 두기 때문에 다른 객체와의 결합도도 줄일 수 있다.
<br>
단점으로는, 중간객체 **(어댑터)** 를 추가함으로써 클래스가 많아지고 코드가 복잡해 진다.

<br>

* **어댑터 패턴 예제**

```java
public class Animal {
    public void makeSound() {
        System.out.println("Generic animal sound");
    }
}

// Wolf 클래스는 Animal 클래스와 호환되지 않는 인터페이스를 가지고 있다.
public class Wolf {
    public void howl() {
        System.out.println("Howl");
    }
}

/*
WolfAdapter 클래스는 Animal 클래스를 상속받고, makeSound() 메서드를 오버라이드 해서 
Wolf 클래스의 howl() 메서드를 호출하도록 구현한다.
*/
public class WolfAdapter extends Animal {

    private Wolf wolf;
    
    public WolfAdapter(Wolf wolf) {
        this.wolf = wolf;
    }

    public void makeSound() {
        wolf.howl();
    }
}

// 어댑터패턴으로 호환되지 않는 인터페이스를 연결하면 기존 코드를 수정하지 않아도 다른 객체와 같이 동작할 수 있게 된다.
public class AdapterExample {
    public static void main(String[] args) {
        Animal animal = new Animal();
        animal.makeSound(); // "Generic animal sound" 출력
        
        Wolf wolf = new Wolf();
        WolfAdapter adapter = new WolfAdapter(wolf);
        adapter.makeSound(); // "Howl" 출력
    }
}
```

<br>

* **JDBC API에 사용된 어댑터 패턴**

```java
/*
Class.forName() 메서드로 Driver 클래스를 로드한다. 이 클래스는 MySQL 제조사가 제공하는 드라이버이다.
그런다음 DriverManager.getConnection() 메서드를 사용하여 데이터베이스와 연결한다. 
이 메서드는 실제로 Driver 인터페이스를 구현한 객체를 생성하여 Connection 인터페이스와 연결한다.
*/
public static void main(String[] args) {
    // JDBC 드라이버 로드
    Class.forName("com.mysql.cj.jdbc.Driver");
    
    // 데이터베이스 연결
    String url = "jdbc:mysql://localhost/test";
    String user = "user";
    String password = "password";
    Connection conn = DriverManager.getConnection(url, user, password);
}

/*
JDBC 는 데이터베이스와 연결하기 위해 인터페이스를 제공한다. 데이테베이스 제조사마다 제공하는
드라이버의 인터페이스가 다르기 떄문에 DriverManager클래스에 어댑터 패턴을 사용한다.
*/
public class DriverManager {
    public static Connection getConnection(String url, String user, String password) {
        // 데이터베이스 제조사가 제공하는 드라이버를 찾아서 Driver 인터페이스를 구현한 객체를 생성
        Driver driver = findDriver(url);
        // Driver 인터페이스를 구현
```


<br>
<br>
<br>
<br>

## 프록시 패턴 - Proxy Pattern
**Proxy** 를 사용하여 객체에 대한 접근을 제어하고 간접적으로 제어하는 디자인 패턴이다.
<br>
객체에 대한 직접적인 접근을 대신해 **Proxy 객체** 를 사용해 객체에 접근을 하고 **Proxy 객체** 는
<br>
실제 객체를 대신해 객체의 **대리자 역할** 을 수행하며 객체와 동일한 인터페이스를 제공한다
<br>
**Proxy 객체** 는 실제 객체의 인터페이스를 구현하며, 실제 객체의 메서드를 호출하기전 추가작업을 할 수 있다.

<br>

### 장점
* 객체 생성과 초기화를 지연시킬 수 있어, 성능을 개선할 수 있다.
    * 원본객체의 생성 또는 초기화에 많은 비용이 들어갈 경우 유용하다.
    * 실제객체가 원격서버에 있는경우, 프록시객체로 서버접근에 대한 리소스를 줄일 수 있다.
    * 프록시객체는 원본객체의 인스턴스를 생성하지 않고, 요청이 들어올 경우 생성하고 요청을 처리한다.
* 실제객체에 대한 접근을 제어할 수 있어, 보안성을 높일 수 있다.
    * 원본객체가 보안성이 중요할 경우 유용하다.
* 객체의 메서드의 실행 전후로 추가적인 작업을 수행할 수 있어 유연성이 증가한다.
    * 이를 통해 로깅, 캐싱, 트랜잭션 등 다양한 처리가 가능하다.

<br>

### 단점
* 프록시 객체는 실제객체에 접근하기 위해 추가적인 리소스가 들어가므로 성능이 저하될 수 있다.
* 프록시 객체라는 추가적은 클래스가 필요하고, 이는 복잡성이 증가하고 유지보수를 어렵게 할 수 있다.
* 중간에 다른 객체가 끼어있기 때문에 디버깅이 어려워질 수 있어 추가적인 로깅이나 디버깅 작업이 필요하다.
* 프록시객체가 실제객체를 대신하기 때문에 실제객체가 생성되지 않아 에상하지 못한 문제가 발생할 수 있다.

<br>

### 구현
#### 정적 프록시 방식
프록시 객체를 컴파일 시점에 미리 생성하는 방식
* 컴파일 시점에 생성되므로 런타임에 추가적인 비용이 발생하지 않는다.
* 인터페이스를 구현하는 클래스만 프록시 객체를 생성할 수 있다.
* 프록시객체를 수정하려면 컴파일을 다시 해야한다.

```java
public class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

/*
프록시 객체가 구현할 AnimalInterface 인터페이스를 구현한다.
AnimalProxy 클래스는 AnimalInterface 인터페이스를 구현한다.
생성자를 통해 실제 객체를 전달받고, eat() 메서드에서 실제 객체의 eat() 메서드를 호출하기 전에 
수행할 작업과 호출한 후에 수행할 작업을 정의한다.
마지막으로 클라이언트에서 프록시 객체를 생성하고 사용한다.
이를 통해 클라이언트는 실제 객체를 알 필요가 없고, 프록시 객체를 이용해 추가적인 작업을 수행할 수 있다.
*/

public interface AnimalInterface {
    void eat();
}

public class AnimalProxy implements AnimalInterface {
    private Animal animal;

    public AnimalProxy(Animal animal) {
        this.animal = animal;
    }

    public void eat() {
        System.out.println("Before eating");
        animal.eat();
        System.out.println("After eating");
    }
}

// 클라이언트
Animal animal = new Animal();
AnimalInterface proxy = new AnimalProxy(animal);
proxy.eat();
```

<br>

#### 동적 프록시 방식
프록시 객체를 런타임에 동적으로 생성하는 방식
<br>
일반적으로 유연성이 높고 프록시 객체를 동적으로 수정할 수 있어 더 많이 사용된다.
* 인터페이스를 구현하지 않은 클래스도 프록시 객체를 생성할 수 있다.
* 프록시 객체를 동적으로 수정할 수 있다.
* 더 다양한 기능을 수행할 수 있어 AOP 같은 패러다임에 사용하기 적합하다.
* 런타임에 프록시객체를 생성하므로, 정적프록시 방식에 비해 성능이 떨어질 수 있다.
* 컴파일 시점에 프록시객체를 알수 없어서 디버깅이 어려울 수 있다.

```java
public interface Animal {
    void eat();
}

public class Dog implements Animal {
    public void eat() {
        System.out.println("The dog is eating.");
    }
}

/*
AnimalInvocationHandler 클래스는 InvocationHandler 인터페이스를 구현하여 invoke() 메서드를 재정의 한다.
*/
public class AnimalInvocationHandler implements InvocationHandler {
    private Animal animal;

    public AnimalInvocationHandler(Animal animal) {
        this.animal = animal;
    }

    // 이 메서드는 실제 객체의 메서드를 호출하기 전후의 실행시간을 출력한다.
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        long startTime = System.nanoTime();
        Object result = method.invoke(animal, args);
        long endTime = System.nanoTime();
        System.out.println("Execution time: " + (endTime - startTime) + " ns");
        return result;
    }
}

/*
Dog 객체를 생성한 후 Proxy.newProxyInstance 메서드를 사용해 Animal 인터페이스를 구현하는 동적 프록시 객체를 생성한다.
이때, AnimalInvocationHandler 클래스를 InvocationHandler로 사용한다. 
마지막으로, 프록시 객체의 eat() 메서드를 호출하여 AOP가 적용된 결과를 출력한다.
*/
Animal dog = new Dog();
Animal proxy = (Animal) Proxy.newProxyInstance(
    Animal.class.getClassLoader(),
    new Class[] { Animal.class },
    new AnimalInvocationHandler(dog)
);
proxy.eat();
```

<br>
<br>
<br>
<br>

## 데코레이터 패턴 - Decorator Pattern


<br>
<br>
<br>
<br>

## 싱글톤 패턴 - Singleton Pattern


<br>
<br>
<br>
<br>

## 템플릿 메서드 패턴 - Template Method Pattern


<br>
<br>
<br>
<br>

## 팩터리 메서드 패턴 - Factory Method Pattern


<br>
<br>
<br>
<br>

## 전략 패턴 - Strategy Pattern


<br>
<br>
<br>
<br>

## 템플릿 콜백 패턴 - Template Callback Pattern - 견본/회신 패턴


<br>
<br>
<br>
<br>


<br>