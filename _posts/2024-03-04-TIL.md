---
layout: single
title:  "TIL-01"
categories: TIL
tag: [System Out, HashTable, ConcurrenctHashMap, Thread Local, PermGen, String + 연산, Singleton Pattern]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>

# Logger vs System Out stream(err,out)

## System Out
``` java
public class PrintStream extends FilterOutputStream implements Appendable, Closeable {

    public void println() {
        newLine();
    }

    private void newLine() {
            try {
                synchronized (this) {
                    ensureOpen();
                    textOut.newLine();
                    // ...
```
* I/O 작업을 수행하며, 시스템 호출을 통해 운영체제의 커널로 전달된다.
* Write 작업은 PrintStream 클래스의 println 메서드는 synchronized 로 동기화 된다.
* 여러 스레드가 동시에 출력을 시도할 때 상당한 대기 시간과 성능 저하가 발생할 수 있다.

## Logger
* 마찬가지로 I/O 작업을 수행한다.
* Write 작업이 별도의 로깅스레드에서 비동기로 실행된다.
* 로그 처리는 로그 시스템이 관리하는 내부 큐와 별도의 처리 스레드를 통해 이루지기 때문에 직접적인 블로킹이 발생하지 않는다.
* 로그 출력 레벨을 사용할 수 있다.


<br>
<br>
<br>
<br>

# HashTable vs ConcurrentHashMap

## HashTable
* 모든 public 메서드 레벨에서 synchronized 를 사용한 동기화 사용
* 모든 연산이 단일 락을 사용함으로써 한 시점에 하나의 스레드만 맵에 대한 연산을 수행할 수 있다.

## ConcurrentHashMap
* volatile을 사용하여 변수의 최신값을 보장하고, 추가적으로 lock 알고리즘을 사용한다.
* 내부구조는 배열과 연결 리스트의 조합으로 이루어져 있는데, 이 배열의 각 요소를 버킷 이라고 하며, 각 버킷에는 키-값 쌍을 저장하는 노드들이 연결 리스트나 트리 형태로 연결되어 있다.
* 쓰기작업이 발생할 때, 해당 키가 위치하는 버킷 또는 해당 버킷내의 노드 에만 락을 적용한다.
* 한 스레드가 한 버킷에서 쓰기 작업을 수행하는 동안 다른 스레드는 다른 버킷에서 동시에 쓰기 작업을 수행할 수 있다.

<br>
<br>
<br>
<br>

# Thread Local
* 스레드 단위로 변수를 할당해 스레드 내부에서 접근할 수 있도록 한다.
* 다른 스레드와의 변수 공유로 인한 동시성 문제를 방지할 수 있다.
* 사용자 인증 정보, 디비 연결, 세션 정보 등 스레드마다 다른 컨텍스트 정보를 저장해야 할 때 유용하다.
	* ex) Spring Security
* 스레드풀에서 스레드를 재사용할땐 꼭 사용 후 remove()를 해줘야 한다.

<br>
<br>
<br>
<br>

# PermGen
* JDK 1.7 까지
	* PermGen
		* 클래스와 메서드에 대한 메타 정보, 상수 풀, 정적 변수등을 저장한다.
		* JVM시작 시 한번 설정되면 런타임 중 변경할 수가 없고 이로인해 oom이 발생
* JDK 1.8 이후
	* Metaspace (메서드 영역)
		* class 메타정보, static 등의 정적 정보가 위치
		* native memory 영역으로 OS가 크기를 조절한다.
* constant pool이 heap으로 옮겨간 후의 장점
	* 힙영역에 속함으로써 크기가 유연하게 확장될 수 있음


<br>
<br>
<br>
<br>

# String + 연산 버전별 차이점, 컴파일러가 어떻게 최적화 하는지
* JDK 1.4 이하
  * 연산할 때 마다 새로운 String 객체가 생성되고 이전 문자열들을 복사하여 새 객체에 넣는 방식
  * 이는 많은 임시 객체 생성과 메모리복사를 초래한다.
* JDK 1.5
  * +연산 시 StringBuilder를 사용하도록 컴파일러가 최적화 됨
  * 연산을 할때마다 새로운 String 객체를 생성하는 대신 StringBuilder객체를 재사용 하여 효율적
* JDK 1.9
  * +연산 코드를 발견하면 컴파일러는 이를 invokedynamic 호출로 변환한다.
  * invokedynamic는 컴파일이 아닌 런타임 시점에 해당 연산에 최적화된 메서드를 호출한다.
    * ex) StringBuilder, StringConcatFactory 등

<br>
<br>
<br>
<br>

# Singleton Pattern을 Nested Class로 구현하는 법


<br>
<br>
<br>
<br>