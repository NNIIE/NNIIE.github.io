---
layout: single
title:  "5주차"
categories: TIL
tag: [SOLID]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>



# SOLID
객체지향의 5가지 설계원칙

<br>

## 단일책임 원칙 - SRP
한 클래스는 하나의 책임만 가져야 한다.
<br>
<br>
모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다.
<br>
한 클래스가 수행할 수 있는 책임 (기능)이 여러가지라면, 클래스 내부 함수끼리의 강한 결합이
<br>
발생할 가능성이 높아지고 이는 유지보수에 비효율적이다.
<br>
한 클래스를 변경하기 위해 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고있는 것이다.

<br>

## 개방-폐쇄 원칙 - OCP
확장에는 열려있고 변경에는 닫혀 있어야 한다.
<br>
<br>
수많은 모듈 중 하나를 수정할 때, 해당 모듈을 이용하는 다른 모듈들을 고쳐야 한다면 비효율적이다.
<br>
즉, 기능을 추가하거나 변경해도 이미 제대로 동작하고 있던 코드를 변경하지 않아도 기존의 코드에
<br>
새로운 코드를 추가함으로써 기능의 추가나 변경이 가능한걸 의미한다.
<br>
<br>
추상화는 개방-폐쇄 원칙의 핵심요소이다.
<br>
자주 변화하는 부분을 추상화 함으로써 유연함을 높인다.
<br>
모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 추상화의 파생클래스를 만드는것으로 확장이 가능하다.
<br>
<br>
객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성을 위한 핵심원칙이다.

<br>

## 리스코프 치환원칙 - LSP
객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야 한다.
<br>
<br>
하위타입객체는 상위타입객체에서 가능한 행위를 수행할 수 있어야 한다.
<br>
즉, 상위타입객체를 하위타입객체로 치환해도 정상적으로 동작해야 한다. == IS-A
<br>
객체지향 초기에는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만 시간이 지나면서 인터페이스와 구현체에도 적용되는 광범위한 원칙으로 바뀌었다.

<br>

## 인터페이스 분리원칙 - ISP
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
<br>
<br>
클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.
<br>
큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
<br>
이는 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않게 한다.

<br>

## 의존관계 역전원칙 - DIP
추상화에 의존해야하고, 구체화에 의존하면 안된다. 
<br>
<br>
의존 관계를 맺을 때, 
<br>
변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 한다
<br>
즉, 구체화된 클래스 보단 추상클래스나 인터페이스에 의존해야 한다.
<br>
<br>
상위계층이 하위계층의 구현으로부터 독립적이어야 한다.
* 상위모듈은 하위모듈에 의존해선 안되고, 상위모듈과 하위모듈 모두 추상화에 의존해야한다.
* 추상화는 세부사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

<br>
<br>
<br>
<br>

# 스레드
운영체제에 메모리를 할당받아 실행중인 프로그램을 프로세스라고 한다.
<br>
스레드란 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다.
<br>
모든 프로세스는 한 개 이상의 스레드가 존재하며 1개는 단일스레드 2개 이상은 멀티스레드 라고 한다.
<br>
<br>
독립적인 프로세스들은 자원 및 데이터를 공유하지않아 리소스가 많이들어가지만 
<br>
멀티스레드의 경우는 자원 및 데이터 공유를 공유하기 때문에 리소스가 적게들어간다.
<br>
물론 데이터를 공유하기 때문에 동기화가 중요하다 -> `thread-safe`

모든 자바 어플리케이션은 메인스레드가 `main()` 메서드를 실행하면서 시작한다.
<br>
이러한 Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 
<br>
만들어 병렬로 코드를 실행할 수 있다. 단일 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만 
<br>
멀티 스레드는 **메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.**

<br>

## 생성
* Runnable 인터페이스 구현
* Thread 클래스 상속
* 람다

```java
class OfThreadClass extends Thread {
	@Override
	public void run() {}
}

class OfRunnableInterface implements Runnable {
	@Override
	public void run() {}
}

class OfLambda {
	Thread thread = new Thread(() -> {
		String threadName = Thread.currentThread().getName();
		System.out.println(threadName);
	});
    thread.setName("Thread #1");
    thread.start();
}
```

자바에서는 다중상속이 안되기 때문에, `Thread` 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없다. 
<br>
하지만 `Runnable` 인터페이스를 구현하는 경우에는 다른 인터페이스를 구현할 수도 있고 다른클래스도 상속 받을수 있다는 장점이 있다.


<br>
<br>
<br>
<br>

# To Do

<br>
<br>
<br>
<br>






<br>