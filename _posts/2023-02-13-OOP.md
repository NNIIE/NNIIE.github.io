---
layout: single
title:  "OOP"
categories: TIL
tag: [OOP, 서브클래싱 / 서브타이핑]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>

# OOP
어플리케이션을 구성하는 요소들을 객체로 보고, 
<br>
객체들을 유기적으로 연결하여 상호작용하는 방식으로 프로그래밍 하는걸 말한다. 
<br>
데이터와 이를 처리하는 루틴을 하나의 **독립된 객체** 로 보고 기능적으로 관련된 
<br>
데이터와 메서드를 묶는 것을 중심으로 한다.
<br>
재사용성, 유지보수 에 용이하고 대형 프로젝트에 적합하다.
<br>
하지만 속도가 상대적으로 느리고, 설계 시 많은 리소스가 들어간다.
* 객체
	* 속성과 동작을 가진다.
	* 속성은 객체의 상태를 나타내고, 동작은 객체의 행동을 나타낸다.
	* 자동차 객체를 예로 들면
		* 속성 : 색상, 모델, 브랜드 등
		* 동작 : 가속, 감속, 정지 등
* **추상화**
    * 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
* **캡슐화**
    * 정보은닉 - 접근제어자
    * 코드의 의존성을 줄이고, 결합도를 낮추는 것
    * 필요한 부분만 외부에 노출시키고 나머지는 숨긴다.
    * 외부에서 불필요한 의존을 할 일이 없어지고 의존성이 줄어드는 만큼 유지보수도 편해진다.
* **상속**
    * 코드의 재사용성에 이점이 있지만 코드의 재사용성만을 위해 사용은 지양한다.
    * 흔히 재사용성 뿐 아니라 계층구조 같은 구조를 만들 때 사용하자
* **다형성**
    * 객체지향의 꽃이라고도 불린다.
    * 형태가 같지만 다른 기능을 하는 것을 말한다.
    * 하나의 타입에 여러 객체를 대입할 수 있는 성질이다.
        * 업캐스팅
            * 서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 한다.
        * 동적바인딩
            * 메시지를 수신했을 때 실행도리 메서드가 런타임에 결정된다.
        * 오버로딩
        * 오버라이딩

<br>
<br>
<br>
<br>

## OOP 왜쓰는데?
* **재사용성**
<br>
<br>
클래스와 상속을 사용해 이미 작성된 코드를 쉽게 재사용 할 수 있고,
<br>
이로인해 코드의 일관성을 유지할 수 있다.

<br>

* **코드의 구조화와 유지보수**
<br>
<br>
객체를 사용해 기능적으로 관련된 데이터와 메서드를 묶어서 관리할 수 있다.
<br>
이로인해 코드의 일관성을 유지할 수 있고,
<br>
새로운 기능이 추가될 때 기존 코드를 변경하지 않아도 되므로 유지보수성을 높일 수 있다.

<br>

* **캡슐화**
<br>
<br>
객체간의 상호작용을 캡슐화 하여 데이터의 안정성을 유지할 수 있다.
<br>
객체는 자신만의 속성과 동작을 가지고 있으며, 다른 객체와 상호작용 할때 인터페이스를 통해
<br>
메시지를 주고받으므로 데이터가 보호되고, 객체간의 의존성을 줄일 수 있다.

<br>

* **상속을 통한 코드 재사용**
<br>
<br>
상속이란 이미 작성된 코드를 확장하거나 변경하여 새로운 클래스를 생성하는 방식이다.
<br>
기존 클래스를 기반으로 함으로 재사용성, 유지보수성을 높일 수 있다.

<br>

* **다형성**
<br>
<br>
다형성이란 객체가 다양한 형태로 동작할 수 있는 방식이다.
<br>
객체가 동일한 메시지를 받을때, 각각 다르게 동작할 수 있고 이로인해 코드를 유연하게 작성할 수 있다.

<br>

* **현실세계와의 유사성**
<br>
<br>
현실세계를 반영하므로 코드를 보다 직관적으로 작성할 수 있다.
<br>
예를들어, 자동차 객체를 만들때 자동차의 특징과 동작을 모델링하여 코드를 작성할 수 있다.

<br>

* **협업**
<br>
<br>
객체는 개별적인 역할과 책임을 가지므로 여러 개발자가 동시에 작업할 수 있다.

<br>
<br>
<br>
<br>

## OOP 단점

* **복잡성**
<br>
<br>
객체지향적인 설계는 추상화를 통해 복잡성을 감추지만, 구현을 위해 많은 코드가 필요하며
<br>
이로인해 코드의 복잡성이 증가할 수 있다.
<br>
또한 어플리케이션이 커질수록 객체 간의 상호작용과 의존성이 많아지고 그럴수록 복잡성은 증가한다.

<br>

* **성능**
<br>
<br>
객체를 생성하고 관리하기 위한 추가적인 오버헤드가 있으므로 성능 저하가 발생 할 수 있다.
<br>
또한 캡슐화 때문에 데이터에 접근하기 위한 추가비용이 들어가고 이는 데이터에 직접 접근하는 
<br>
절차지향 프로그래밍 보다 느릴 수 있다.

<br>

* **설계**
<br>
<br>
명확한 구조와 규칙을 필요로 하고 객체간의 관계를 적절히 설계해야 하는 등 설계에 많은 리소스가 들어간다.

<br>

* **상속 남용**
<br>
<br>
상속을 남용하면 중복코드가 생기고 클래스간의 관계가 복잡해질 수 있고 
<br>
하위 클래스가 상위클래스에 의존하게 되어 하위클래스 수정이 상위클래스까지 영향을 미칠 수 있다.

<br>
<br>
<br>
<br>

## OOP의 특징

<br>

### OOP와 캡슐화
<br>
객체를 추상화 하고, 객체의 내부 상태와 동작을 외부로부터 보호하는것을 의미한다.
<br>
객체의 내부 구현을 외부에 숨기고, 객체와 객체간의 상호작용을 인터페이스를 통해서 해서
<br>
객체의 상태를 외부에서 변경할 수 없도록 하고, 변경에 대한 책임을 객체 스스로가 갖도록 한다.
<br>
즉, 객체의 구현 세부사항을 숨기고 객체간의 결합도를 낮추는 효과를 가져온다.
<br>
객체의 구현 세부 사항을 숨기는 것을 객체지향설계 에선 **정보은닉** 이라고 부른다.
<br>
상속과 다형성의 개념과도 관련이 있는데,
<br>
부모클래스의 캡슐화된 멤버 변수와 메서드를 재사용할 수 있도록 하고
<br>
캡슐화된 인터페이스를 이용해 서로 다른 객체를 동일한 방식으로 다룰 수 있도록 한다.
<br>
캡슐화는 **OOP** 에서 객체의 추상화, 모듈화, 재사용성 등의 장점을 실현하는데 중요한 역할을 한다.

<br>
<br>
<br>
<br>

### OOP와 상속

#### 서브클래싱
#### 서브타이핑

<br>
<br>
<br>
<br>

### OOP와 추상화
책에서는 모델링이라고 설명한다.
<br>
대상에 집중하지말고 문제에 집중을 하면 올바른 추상화에 가까이 갈 수 있다.
<br>
대상은 문제를 풀기 충분한 정도의 속성만 가지고 있으면 되고, 이 문제를 푸는데 불필요한 
<br>
속성은 제거하는 편이 낫다.

<br>
<br>
<br>
<br>

### OOP와 다형성
한가지 메서드로 여러가지의 역할을 할 수 있다. 일종의 분기
<br>
다형성과 리스코프치환 원칙은 비슷함

<br>
<br>
<br>
<br>

## OOP와 Getter / Setter




<br>
<br>
<br>
<br>


<br>