---
layout: single
title:  "3주차"
categories: TIL
tag: [java]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## Property
자바는 property가 없고 코틀린이나 자바스크립트는 property를 사용 
* 이건 왜그래?
* property의 정확한 정의에 대해 알아보자 

<br>

## String
* String을 특별대우 하는 이유?
* String은 불변(immutable)하기 때문에 값을 변경할 수 없다?
* constant pool?
* String을 더할 때 안좋은 이유?
	* StringBuffer
	* StringBuilder
	* 자바 1.5 이후에 컴파일러가 자동으로 StringBuffer / StringBuilder 로 최적화 해주지만 for문을 돌아서 더해주거나 할때는 컴파일러가 최적화를 못해주네? 자세히 알아보자

<br>

## Annotation
맨날 쓰는 Annotation 이것에 대한 기본기를 확실하게 다져보자
* 어노테이션의 정의는?
* 어노테이션은 주석과 같다?
* 어노테이션은 결정된 값을 담아야 하는 제약이 있다? -> 컴파일 단계에서 다 알아야해?
* 어노테이션의 타겟?
* 어노테이션을 어디까지 붙일 수 있을까?


<br>

# To Do

## Exception
* ***Checked Exception***

* ***UnChecked Exception***

* try/catch 를 쓰지 않아도 우리의 프레임 워크는 알아서 Exception을 메인메서드까지 던지는걸 막아준다. 그 결과 어플리케이션은 죽지 않고 500에러 등으로 내려주네? 자세히 알아보자

<br>

## 자바는 왜 Checked Exception을 도입했는가?
* 왜 도입했고 요즘은 좀 다른데 어떤 분위기인가?

<br>

## 의문점
가비지컬렉터는 알아서 메모리를 관리해 주는데, 결국 한계점에선 Major GC를 실행할 수 밖에 없고
<br>
이것이 실행되는 동안에는 결국 `stop the world` 즉, JVM이 멈추게 되는 현상이 발생하는데 그렇기 때문에
<br>
과거에는 GC를 튜닝해서(도메인에 따라 메모리 관리가 틀리기 때문에) 이런 현상이 최대한 적게 일어나게
<br>
하는것이 한동안 이슈였다.  
<br>
그렇다면 하나의 큰 JVM 말고 여러개의 소규모 컨테이너로 JVM을 실행하면? 마치 로드밸런싱과도 비슷한데..
<br>
이렇게 하면 하나의 JVM에서 Major GC가 발생해도 어플리케이션 전체가 `stop the world`에 빠지진 않는데?
<br>
하지만 이 방법은 JVM이 나뉘어 짐에 따라 스택프레임을 공유할 수 없다는 단점이 있는데
<br>
<br>
요즘은 웬만한 프로그램도 웹어플리케이션으로 패러다임이 움직임에 따라 프로그램은 
<br>
request -> response 이후 스레드가 종료되는 단순한 형태로 바뀌기 시작했고
<br>
그 결과 스택프레임을 공유하는 빈도 수 가 줄면서 GC튜닝 이슈는 좀 사그라 들었다.
<br>
하지만 완벽한 해결법은 아니고 자바 11 이후 GC의 방식이 조금 바뀌었다. 하지만 이것도 장단점..

* 자바 11 이후 바뀐 가비지컬렉터에 대해 자세히 알아보자
* 스택프레임에 대해 알고있는 것보다 더 자세히 알아보자
* 하나의 JVM으로 띄우는 것과 여러개의 컨테이너로 띄우는 것의 장단점에 대해 자세히 알아보자
	* 노드js에선 쓰고있는거 같던데?
* 하나의 프로세스는 하나의 cpu core를 사용하는건가? 
	* 맞다면 그 안에서 멀티 스레딩 처리를 하는데 만약 cpu가 multicore라면 JVM은 어떤 방식으로 돌아가지?
* 로드밸런싱에 대해서 자세히 알아보자



<br>
