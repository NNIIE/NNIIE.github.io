---
layout: single
title:  "3주차"
categories: TIL
tag: [java]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## Property
자바는 property가 없고 코틀린이나 자바스크립트는 property를 사용 
* 이건 왜그래?
* property의 정확한 정의에 대해 알아보자 

<br>

## String
* String을 특별대우 하는 이유?
* String은 불변(immutable)하기 때문에 값을 변경할 수 없다?
* constant pool?
* String을 더할 때 안좋은 이유?
	* StringBuffer
	* StringBuilder
	* 자바 1.5 이후에 컴파일러가 자동으로 StringBuffer / StringBuilder 로 최적화 해주지만 for문을 돌아서 더해주거나 할때는 컴파일러가 최적화를 못해주네? 자세히 알아보자

<br>

## Annotation
맨날 쓰는 Annotation 이것에 대한 기본기를 확실하게 다져보자
* 어노테이션의 정의는?
* 어노테이션은 주석과 같다?
* 어노테이션은 결정된 값을 담아야 하는 제약이 있다? -> 컴파일 단계에서 다 알아야해?
* 어노테이션의 타겟?
* 어노테이션을 어디까지 붙일 수 있을까?


<br>

# To Do

## Exception
예외는 기본적으로 폭탄돌리기와 같다.
<br>
처리하거나 처리 `try catch` 할 수 없다면 `throw` 즉, 던져야 한다.
<br>
예외를 처리하지 못하고 계속 던지게 되면 결국 메인메서드까지 던져지게 되고 결국 어플리케이션이 종료된다.

![이미지](/images/2021-05-10-first-posting/exception%EA%B3%84%EC%B8%B5.png)

* Throwable : 최상위 예외 이며, 객체이기 때문에 `Object`를 상속받는다.

* Error : 메모리부족, 시스템 오류같은 어플리케이션 레벨에서 복구가 불가능한 시스템 장애이다.
<br>
`Exception`과 `Error`는 다르다

* ***상위 예외를 잡으면 하위 예외까지*** 잡아버리기 때문에 어플리케이션에선 `Exception` 예외부터 필요한 예외로 잡아야 한다.
<br>
또한, `Layer`에 역할에 맞는 `Exception`을 던질 필요가 있다.

<br>

### ***Checked Exception***
`Exception`을 상속받는 예외는 `checked exception`이 되며 `Exception`은 어플리케이션에서 사용할 수 있는 실질적인 최상위 예외이다. 컴파일러가 체크하며 잡아서 처리하거나, 또는 밖으로 던지도록 선언해야 한다.
<br>
예외 발생 시 트랜잭션 `roll-back` 처리를 하지 않는다. 
<br>
(복구가 가능하다는 매커니즘을 가지고 있기 때문에 복구를 하라고 하고 롤백은 처리하지 않겠다 아닐까?)
<br>
***단, RuntimeException을 상속받는 경우 unchecked exception이 된다.***

* ***장점***
	* 예외를 처리하거나 밖으로 던지는 `throw` 를 필수로 선언해야 컴파일 오류가 발생하지 않기 때문에 
	<br>
	개발자가 실수로 누락하는 상황이 발생하지 않는다.
* ***단점***
	* 모든 체크예외를 반드시 잡거나 던지도록 처리해야 한다.
	* 의존관계 문제가 발생한다.
		* 예를들어 `Controller / Service` 등에서 SQL예외를 던졌을때 해당 클래스에서 `SQLException`을 의존하게 된다. 이럴경우 JDBC가 아닌 JPA같은 기술로 변경할 시 모든 코드를 고쳐야한다. 
		<br>
		즉, `OCP / DI`를 위반한다.
* ***활용***
<br>
	기본적으로 `unecked exception`을 사용하자. `checked exception`은 비즈니스 로직상 반드시 처리해야 하는 경우에만 (계좌 이체 실패, 결제시 포인트 부족 등)
	<br>
	즉, 개발자가 실수로 놓치게 되면 치명적인 문제가 발생하는 경우에 컴파일러의 도움을 받기위해 사용하자.
	<br>
	또한, `catch` 절에서 딱히 할일이 없을 경우 사용하지 말고 확실히 할일이 있는 경우에 사용하자

* 대표적인 `Exception`
	* `IOException`
	* `SQLException`

<br>

### ***UnChecked Exception***
`RuntimeException`과 그걸 상속받는 예외들은 `unchecked exception`이다.
<br>
컴파일러가 체크하지 않는 예외이며 `throw`를 생략할 수 있고 이럴 경우 자동으로 예외를 던진다.
<br>
즉, 예외를 잡아서 처리하지 않아도 `throw`를 생략할 수 있다.
<br>
예외 발생 시 트랜잭션 `roll-back` 처리를 한다.

* ***장점***
	* `throw` 생략으로 예외를 무시할 수 있다.
	* 시스템에서 발생하는 복구가 불가능한 예외에 대해 신경쓰지 않아도 된다.
	* 신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.
* ***단점***
	* 컴파일 단계에서 체크가 안되기 때문에 실수할 가능성이 있다.
* 대표적인 `Exception`
	* `NullPointerException`
	* `IllegalArgumentException`

<br>

### 예외 던져도 안죽던데?
웹 어플리케이션은 `servlet`의 오류 페이지나, 또는 `Spring MVC`가 제공하는 `ControllerAdvice` 에서 이런 예외를 공통으로 처리해 주기 때문에 예외가 메인메서드까지 가지 않는다.
* 하지만 이런 문제들은 클라이언트 입장에선 어떤 문제가 발생했는지 자세히 알기 어렵다.
* `API`라면 HTTP 상태코드 `500`으로 응답을 내려준다.
* 수정하기 전까진 해결되지 않으므로 별도의 오류 로그를 남기고 메일, 알림등을 통해 
<br>
개발자가 빨리 인지할 수 있도록 처리해두는게 좋다.

<br>

### 자바 Checked Exception???
자바의 `Checked Exception`은 자바만의 독특한 특징이다.
<br>
***"강제성이 없기 때문에 실수할 여지가 있다"*** 를 해결하기위해 도입했지만
컴파일단계에서 예외를 처리하라고 
<br>
강요하는 `Checked Exception` 은 자바 이후 설계된 `C#` 이나 `ruby`등에서도 채택되지 않았다.
<br>
요즘은 극단적으로 자바의 `Checked Exception` 도입은 실패라는 주장도 심심치 않게 보인다.
<br>
`JDBC API`에서는 `Checked Exception`을 남발하고 `catch`절에서 아무것도 하지 않았고 
<br>
이런 문제점을 알고 그후에 `JDBC`를 활용한 `Spring-JdbcTemplet`, `Hibernate`, `JPA` 등에서는 
<br>
`Checked Exception`인 `SQLException`을 볼수 없게 설계되었고 이런 사례들을 보면 자바의 
<br>
`Checked Exception`은 도입은 논란의 여지가 있는듯 하다.

<br>

## nested class
* inner class
* static inner class
* 둘의 차이 ex)가비지컬렉션

<br>

## 의문점
가비지컬렉터는 알아서 메모리를 관리해 주는데, 결국 한계점에선 Major GC를 실행할 수 밖에 없고
<br>
이것이 실행되는 동안에는 결국 `stop the world` 즉, JVM이 멈추게 되는 현상이 발생하는데 그렇기 때문에
<br>
과거에는 GC를 튜닝해서(도메인에 따라 메모리 관리가 틀리기 때문에) 이런 현상이 최대한 적게 일어나게
<br>
하는것이 한동안 이슈였다.  
<br>
그렇다면 하나의 큰 JVM 말고 여러개의 소규모 컨테이너로 JVM을 실행하면? 마치 로드밸런싱과도 비슷한데..
<br>
이렇게 하면 하나의 JVM에서 Major GC가 발생해도 어플리케이션 전체가 `stop the world`에 빠지진 않는데?
<br>
하지만 이 방법은 JVM이 나뉘어 짐에 따라 스택프레임을 공유할 수 없다는 단점이 있는데
<br>
<br>
요즘은 웬만한 프로그램도 웹어플리케이션으로 패러다임이 움직임에 따라 프로그램은 
<br>
request -> response 이후 스레드가 종료되는 단순한 형태로 바뀌기 시작했고
<br>
그 결과 스택프레임을 공유하는 빈도 수 가 줄면서 GC튜닝 이슈는 좀 사그라 들었다.
<br>
하지만 완벽한 해결법은 아니고 자바 11 이후 GC의 방식이 조금 바뀌었다. 하지만 이것도 장단점..

* 자바 11 이후 바뀐 가비지컬렉터에 대해 자세히 알아보자
* 스택프레임에 대해 알고있는 것보다 더 자세히 알아보자
* 하나의 JVM으로 띄우는 것과 여러개의 컨테이너로 띄우는 것의 장단점에 대해 자세히 알아보자
	* 노드js에선 쓰고있는거 같던데?
* 하나의 프로세스는 하나의 cpu core를 사용하는건가? 
	* 맞다면 그 안에서 멀티 스레딩 처리를 하는데 만약 cpu가 multicore라면 JVM은 어떤 방식으로 돌아가지?
* 로드밸런싱에 대해서 자세히 알아보자



<br>
