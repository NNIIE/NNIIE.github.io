---
layout: single
title:  "7 Week"
categories: TIL
tag: [MVC, MVP, MVVM, JDBC, Connection Pool]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>

# JDBC
## JDBC의 정의
데이터베이스 접근기술

<br>

## JDBC Driver
서로 다른 디비들에 대한 연결방법이 모두 다르기 때문에 거기에 대응하기 위해서 사용한다.
<br>
결국 디비가 서로 다르고 다른 연결방식 이어도 모두 같은방식으로 다루고 싶고
<br>
또한 프로그래밍 단에서는 하나의 방식으로 사용하고 싶기 때문에 사용한다.

<br>

## JDBC API
드라이버가 매꿔준 걸 이용해서 같은방식으로 디비에 대한 접근을 제공하는 **인터페이스**
<br>
API는 `Application Programming Interface`의 약자이고
<br>
`JDBC API`란 여기에 접근하기 위해 추상적으로 공개한 루트이다.
<br>
이것도 결국 프로그래밍 단에서 다른걸 신경쓰지 않고 하나의 방법으로 사용하고 싶기 때문

<br>

## Connection Pool
데이터베이스에 대한 커넥션을 미리 생성해두고 재사용 하기 위한 방법
<br>
어플리케이션 시작 시점에 필요한 만큼의 커넥션을 미리 확보해서 풀에 보관한다.
<br>
<br>
<br>
**왜쓰는데?**
<br>

DB Driver는 데이터베이스와 **TCP/IP** 커넥션을 연결하는데, 이 과정에서 `3 way handshake` 같은
<br> 
네트워크 동작이 발생하게 된다.
<br>
`3 way handshake` 는 **Network Pass** 를 확보하는데 3번의 통신을 해야 서로가 신뢰를
<br>
가지고 **Pass** 를 확정하기 때문에 이 과정에서 시간이라는 리소스가 많이 들어가게 된다.
<br>
비용적인 측면에서 **느린거로**는 네트워크가 압도적이기 때문에 `Connection Pool` 을 사용한다.


<br>
<br>
<br>
<br>

# To Do

<br>
<br>
<br>
<br>

# MVC
어플리케이션을 **Model-View-Controller** 의 세가지 컴포넌트로
<br>
각각 담당하는 역할을 구분한 디자인패턴
1. 사용자가 입력을 담당하는 **View** 를 통해 요청을 보낸다.
2. 해당 요청을 **Controller** 가 받고 **Model** 을 통해 데이터를 가져온다.
3. 해당 데이터를 바탕으로 출력을 담당하는 **View** 를 통해 사용자에게 전달한다.
<br>
MVC패턴은 모델1과 모델2가 있다.

* 모델 1 
	* JSP에서 출력과 로직을 전부 담당
	* 사용자 요청을 JSP가 `JavaBean Service Class` 를 사용해 전부 처리
	* 빠르고 쉽게 개발할 수 있지만 유지보수맟 확장에 어려움
* 모델 2 
	* JSP에서 출력만 담당
	* 사용자 요청을 서블릿이 받음
	* 설계가 어렵지만 분업이 가능하며 유지보수 및 확장에 용이

<br>

**Model**
* 어플리케이션의 정보, 데이터 등을 담당하고 정보들의 가공을 책임지는 컴포넌트
* 비즈니스 로직 처리
* 편집하기 원하는 모든 데이터를 가지고 있어야 한다.
* 변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.
* **View / Controller** 에 대해 의존하지 말아야 한다.

<br>

**View**
* 데이터의 입력과 보여지는 출력을 담당
* **Model** 의 정보를 가지고 있지 말아야 한다.
* 변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.
* **Model / Controller** 에 의존하지 말아야 한다.

<br>

**Controller**
* **Model / View** 의 중간다리 역할을 한다.
* 요청에 대해 해당 요청을 담당하는 **Model** 을 호출한다.
* **Model** 의 작업결과를 리턴받아 **View** 에게 전달한다.
	* **Model / View** 에 대해 알고있어야 한다.

<br>

**Web에 적용할 시**
1. 유저가 웹사이트에 접속
2. **Controller** 는 접속요청에 대해 **Model** 호출
3. **Model** 은 디비나 파일같은 데이터를 비즈니스 로직을 통해 처리 후 리턴
4. **Controller** 는 리턴받은 결과를 **View** 에 전달
5. 리턴받은 결과는 **View** 를 통해 유저에게 보여짐

<br>

**왜쓰는데?**
<br>
<br>
사용자 **UI / 비즈니스 로직 / 중간다리** 이렇게 3가지로 구분하여 어플리케이션을
<br>
설계하면 각각 자신의 역할에만 집중할 수 있다.
<br>
이로인해 유지보수, 확장성, 유연성이 증가하고 중복을 줄일 수 있다.

<br>

**단점**
<br>
<br>
설계에 리소스가 들어간다. 예를들어
* **Model / View** 가 다른 컴포넌트 들에게 독립적이게 설계하는 것
* **Model** 의 설계를 잘해야 변경에 유연할 수 있는것
<br>

제대로 설계를 하지 않으면 **View** 와 **Model** 의 분리가 어려운데
<br>
**Controller** 를 통해 하나의 View에 연결될 수 있는 **Model** 도 여러 개가 될 수 있어
<br>
**View** 와 **Model** 이 서로 의존성을 띄게 될 수 있다.
<br>
즉, **Controller** 하나에 다수의 **Model / View** 가 복잡하게 얽히는 상황이 일어날 수 있다.


<br>
<br>
<br>
<br>

# MVP

<br>
<br>
<br>
<br>

# MVVM

<br>
<br>
<br>
<br>






<br>