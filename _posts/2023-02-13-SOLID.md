---
layout: single
title:  "SOLID"
categories: TIL
tag: [SRP, OCP, LSP, ISP, DIP]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>

# SOLID
객체지향 프로그래밍에서 소프트웨어 디자인 품질을 향상시키기 위한 다섯 가지 원칙이다.
<br>
이 원칙을 따르면 아래와 같은 장점이 있다.

* 유지보수성 향상
* 재사용성 항샹
* 확장성 향상
* 변경에 대한 유연성 향상
* 코드의 가독성 향상
* 결합도 감소
* 테스트 용이성 향상
* 오류발생 가능성 감소


<br>

## SRP - 단일 책임 원칙
하나의 클래스는 하나의 책임을 가져야 한다는 원칙이다.
<br>
이것은 클래스가 변경되어야 하는 이유는 단 하나여야 함을 의미한다.
<br>
클래스의 응집력은 높이고 결합도는 낮춰서 유지보수, 재사용성, 확장성에 용이하게 하는 원칙으로, 
<br>
클래스 하나가 여러 책임을 가지게 되면 그 클래스를 변경해야 하는 이유도 여러가지가 생기므로, 
<br>
코드를 변경할때 다른 책임과 관련된 코드까지 함께 변경해야 한다. 
<br>
<br>
**SRP** 원칙을 지키기 위해서는 클래스가 자신의 책임을 명확하게 정의하고, 
<br>
다른 책임을 수행하는 클래스와의 의존성을 최소화 해야한다.

```java
// Order 클래스는 너무 많은 책임을 가지고 있다.
public class Order {
	private List<Item> items;
    private Customer customer;
    
    public void addItem(Item item) {
        // 주문서에 상품 추가
    }
    
    public void removeItem(Item item) {
        // 주문서에서 상품 제거
    }
    
    public double calculateTotalPrice() {
        // 주문서 총액 계산
    }
    
    public void sendConfirmEmail() {
        // 고객에게 confirm 이메일 발송
    }
}

// 아래처럼 클래스의 책임을 분리함으로써, 클래스간 의존성이 낮아지게 된다.
// 이렇게 단일책임원칙을 따르게 되면 유지보수, 재사용성, 확장성이 향상된다.
public class OrderItem {
	// 주문항목을 관리하는 클래스
    private Item item;
    private int quantity;
}

public class OrderCalculator {
    public double calculateTotalPrice(List<OrderItem> orderItems) {
        // 주문서 총액 계산
    }
}

public class EmailSender {
	public void sendConfirmEmail(Customer customer) {
        // 고객에게 confirm 이메일 발송
    }
}
```

<br>

## OCP - 개방 / 폐쇄 원칙


<br>

## LSP - 리스코프 치환 원칙


<br>

## ISP - 인터페이스 분리 원칙


<br>

## DIP - 의존관계 역전 원칙


<br>

## 책임이란?
솔리드원칙에서도 말하지만 기능이 변경될 때 같이 변경되면 이건 다른 책임이다?



<br>
<br>
<br>
<br>


<br>