---
layout: single
title:  "5주차"
categories: TIL
tag: [SOLID, 스레드, 인터프리터 언어]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>



# SOLID
객체지향의 5가지 설계원칙

<br>

***단일 책임 원칙 (SRP) - 한 클래스는 하나의 책임만 가져야 한다.***
<br>
<br>
모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다.
<br>
한 클래스가 수행할 수 있는 책임 (기능)이 여러가지라면, 클래스 내부 함수끼리의 강한 결합이
<br>
발생할 가능성이 높아지고 이는 유지보수에 비효율적이다.
<br>
한 클래스를 변경하기 위해 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고있는 것이다.

<br>
<br>

***개방-폐쇄 원칙 (OCP) - 확장에는 열려있고 변경에는 닫혀 있어야 한다.***
<br>
<br>
수많은 모듈 중 하나를 수정할 때, 해당 모듈을 이용하는 다른 모듈들을 고쳐야 한다면 비효율적이다.
<br>
즉, 기능을 추가하거나 변경해도 이미 제대로 동작하고 있던 코드를 변경하지 않아도 기존의 코드에
<br>
새로운 코드를 추가함으로써 기능의 추가나 변경이 가능한걸 의미한다.
<br>
추상화는 개방-폐쇄 원칙의 핵심요소이다.
<br>
자주 변화하는 부분을 추상화 함으로써 유연함을 높인다.
<br>
모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 추상화의 파생클래스를 만드는것으로 확장이 가능하다.
<br>
객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성을 위한 핵심원칙이다.

<br>
<br>

***리스코프 치환원칙 (LSP) - 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야 한다.***
<br>
<br>
하위타입객체는 상위타입객체에서 가능한 행위를 수행할 수 있어야 한다.
<br>
즉, 상위타입객체를 하위타입객체로 치환해도 정상적으로 동작해야 한다. == IS-A
<br>
객체지향 초기에는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만 시간이 지나면서 인터페이스와 구현체에도 적용되는 광범위한 원칙으로 바뀌었다.

<br>
<br>

***인터페이스 분리원칙 (ISP) - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.***
<br>
<br>
클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.
<br>
큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
<br>
이는 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않게 한다.

<br>
<br>

***의존관계 역전원칙 (DIP) - 추상화에 의존해야하고, 구체화에 의존하면 안된다.***
<br>
<br>
의존 관계를 맺을 때, 
<br>
변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 한다
<br>
즉, 구체화된 클래스 보단 추상클래스나 인터페이스에 의존해야 한다.
<br>
<br>
상위계층이 하위계층의 구현으로부터 독립적이어야 한다.
* 상위모듈은 하위모듈에 의존해선 안되고, 상위모듈과 하위모듈 모두 추상화에 의존해야한다.
* 추상화는 세부사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

<br>
<br>
<br>
<br>

# 스레드
운영체제에 메모리를 할당받아 실행중인 프로그램을 프로세스라고 한다.
<br>
스레드란 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다.
<br>
모든 프로세스는 한 개 이상의 스레드가 존재하며 1개는 단일스레드 2개 이상은 멀티스레드 라고 한다.
<br>
<br>
독립적인 프로세스들은 자원 및 데이터를 공유하지않아 리소스가 많이들어가지만 
<br>
멀티스레드의 경우는 자원 및 데이터 공유를 공유하기 때문에 리소스가 적게들어간다.
<br>
물론 데이터를 공유하기 때문에 동기화가 중요하다 -> `thread-safe`

모든 자바 어플리케이션은 메인스레드가 `main()` 메서드를 실행하면서 시작한다.
<br>
이러한 Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 
<br>
만들어 병렬로 코드를 실행할 수 있다. 단일 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만 
<br>
멀티 스레드는 **메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.**

<br>

**생성**
* Runnable 인터페이스 구현
* Thread 클래스 상속
* 람다

```java
class OfThreadClass extends Thread {
	@Override
	public void run() {}
}

class OfRunnableInterface implements Runnable {
	@Override
	public void run() {}
}

class OfLambda {
	Thread thread = new Thread(() -> {
		String threadName = Thread.currentThread().getName();
		System.out.println(threadName);
	});
    thread.setName("Thread #1");
    thread.start();
}
```

자바에서는 다중상속이 안되기 때문에, `Thread` 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없다. 
<br>
하지만 `Runnable` 인터페이스를 구현하는 경우에는 다른 인터페이스를 구현할 수도 있고 다른클래스도 상속 받을수 있다는 장점이 있다.

<br>
<br>
<br>
<br>

# 자바는 느리다?
자바는 `Python` , `JavaScript` 같은 인터프리터 , 스크립트 언어 보다는 빠르다.
<br>
하지만 `C/C++` , `Pascal` , `Fortran` 같은 네이티브 바이너리 코드를 만드는 언어에 비해선 느리다.
<br>
그 이유는 여러가지가 있지만 크게 2가지를 들 수 있다.
* 객체지향 언어의 특성
* JVM이라는 가상머신 사용

자바는 개발자의 편의성을 위해 성능을 희생하고 있는데 시간이 지나면서
<br>
자바의 소프트웨어와 하드웨어가 발전해서 초기이슈였던 성능이슈는 잠잠해 졌지만
<br>
여전히 부족한 하드웨어 스펙을 쓰는 소규모 장비에선 C언어를 주로 사용한다.

<br>

***객체지향의 특성***
<br>
<br>
자바는 클래스 단위로 모든 코드를 작성한다. C언어와 같은 함수단위가 아니기때문에
<br>
다른 클래스에 있는 메서드나 정보를 사용하기 위해선 해당 클래스 전체를 인스턴스로 만들어야 한다.
<br>
그만큼 메모리와 코드를 찾아 로드하는 시간에 많은 리소스가 들게되고 이것을 피하려고 `static` 사용이나
<br>
클래스 단위를 잘게 쪼개서 작성할 경우 객체를 다루는 효율성이 떨어지게 된다.
<br>
그렇기 때문에 자바는 C언어와 달리 모든 코드를 미리 메모리에 올려두지 않고 필요할 때 마다 가져다 쓰는
<br>
**동적 할당 방식**을 사용하기 때문에 C언어보다 상대적으로 느릴 수 밖에 없다.

<br>

***JVM***
<br>
<br>
C언어는 컴파일 시 코드를 모드 기계어로 번역해 메모리에 올려두고 실행한다. 하지만 자바에서는
<br>
바이트코드로 먼저 컴파일 한 뒤, 동적할당 된 코드를 JVM의 JIT과 같은 방식으로 실행한다.
<br>
이렇게 함으로써 운영체제에 종속적이지 않게 된다는 이점이 있지만 그만큼 성능을 희생하게 된다.
<br>
또한 C언어에서는 동적할당한 메모리를 개발자가 직접 바로 해제하지만, 자바는 GC가 메모리를 해제하기 때문에
<br>
이 GC또한 프로그램이기 때문에 메모리와 연산작업을 동반하게 된다.

<br>

***인터프리터 / 스크립트 언어***
<br>
<br>
`Python`과 같은 인터프리터 방식의 언어는 **코드를 한줄씩** 읽어 기계어로 번역한다.
<br>
그리고 같은 기능을 하는 코드가 다시 나와도 또 다시 해석하여 결과를 출력한다. 
<br>
이 때문에 일반적으로 컴파일 방식의 언어보다 수행 속도가 느리다.
<br>
하지만 수정사항이 발생했을 때, 컴파일러가 소스코드를 읽어 실행 파일을 만드는 자바는 소스코드를
<br> 
다시 컴파일 해야하지만 인터프리터 언어는 소스코드를 수정해서 실행시키면 끝나기 때문에 수정이
<br>
아주 간단하다는 장점이 있다. 즉, 개발편의성이 좋다는 의미이다.
<br>
`Python`은 이 약점을 극복하기 위해 라이브러리들의 내부는 C / C++ 으로 되어있다.
<br>
<br>
그리고 이 장점을 최대한 살린것이 스크립트 언어이다.

<br>

## IO / NIO
자바는 직접 메모리를 관리하고 운영체제의 **시스템 콜** 을 직접 사용하기 힘들다.
<br>
자바가 특별히 성능이 좋지 않은 부분이 `IO` 이고 이걸 개선한 것이 `NIO` 패키지 이다.

<br>

* ***IO***
	* ***Blocking API***
	<br>
	API 를 호출한 스레드가 API의 작업이 끝날 때까지 다른동작을 하지 않는 API 를 말한다. `(idle 상태)`
	<br>
	자바의 기본 IO는 이 `Blocking API`로 사용되어 왔기 때문에 `File IO` 뿐만 아니라
	<br>
	`Network IO` 또한 오래 걸리기 때문에 더욱 자바에게 느리다는 인상을 심어준 녀석이다.

	* ***Stream 기반***
	<br>
	스트림 기반의 IO는 스트림으로부터 한번에 여러 바이트를 읽는다. 데이터는 캐싱되어 있지 않고
	<br>
	스트림 속 데이터에서 앞뒤로 이동할 수 없다. 만약 스트림으로 읽은 데이터 내부에서 앞뒤로
	<br>
	이동해야 한다면 버퍼를 만들어 캐싱을 해야한다.

<br>

* ***NIO***
	* ***Non Blocking API***
	<br>
	API 호출 시 요청한 작업의 완료여부와 상관없이 즉각적으로 현재 상태에 대한 답이 온다.
	<br>
	그렇기 때문에 API 호출 후 스레드 제어권이 있기 때문에 다른작업을 진행할 수 있다.

	* ***Buffer 기반***
	<br>
	이미 처리된 버퍼로부터 데이터를 읽는다. 필요하다면 버퍼 내부에서 앞뒤로 이동할 수 있다.
	<br>
	즉, 데이터를 처리하는 동안 좀 더 유연함을 제공해 주지만 데이터를 완벽하게 처리하려면
	<br>
	필요한 데이터가 모두 버퍼 안에 있어야 한다. 또한 버퍼에서 더많은 데이터를 읽을때 버퍼속에서
	<br>
	아직 전처리되지 않은 데이터를 사용하지 않도록 확실히 해야한다.






<br>
<br>
<br>
<br>

# To Do

<br>
<br>
<br>
<br>






<br>