---
layout: single
title:  "TIL-01"
categories: TIL
tag: [List, JIT Compiler, Graal VM, Class Loader]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>

# List
## ArrayList
동적배열을 기반으로 배열의 크기가 가득찰때마다 더 큰 배열을 생성하고 기존의 요소들을 새 배열로 복사한다.
<br>
데이터 검색에 유리하고 추가 / 삭제에 불리한 구현체이다.
<br>
대량에 데이터를 추가할 때 가능한 addAll 메서드로 한번에 추가하는 것이 내부적인 배열복사로 인한 성능감소에 효과적이다.
* 장점
	* 배열기반으로 인덱스를 통한 빠른 접근이 가능하다. o(1)
	* 연속된 메모리 공간에 데이터를 저장한다.
* 단점
	* 리스트 중간에 요소를 추가 / 삭제 할때 나머지 요소들을 이동시켜야 하므로 o(n)의 시간복잡도를 가진다.

## LinkedList
불연속적으로 존재하는 데이터를 서로 연결한 형태인 노드의 연결로 이루어져 있고 
<br>
데이터를 저장하는 각 노드가 이전노드와 다음노드의 상태만을 알고있다.
<br>

데이터 추가 / 삭제에 유리하고 검색에 불리한 구현체이다.
* 장점
	* 데이터 추가 / 삭제에 이전노드와 다음노드의 상태만 변경하면 되기 때문에 o(1)의 시간복잡도를 가진다.
	* 이전요소와 다음요소의 참조를 모두 가지고 있어 양방향 순회가 가능하다.
* 단점
	* 데이터 검색시에 최악의 경우 o(n)의 시간복잡도를 가진다.
	* 각 요소가 추가적으로 이전노드와 다음노드 2개의 참조를 가지고 있기 때문에 ArrayList보다 더 많은 메모리를 사용한다.

<br>
<br>
<br>
<br>

# JIT Compiler
* 런타임 시 바이트 코드를 바이너리 코드로 컴파일 하여 애플리케이션의 성능을 향상시키는데 도움을 준다.
* 컴파일된 바이트코드는 JVM내에서 인터프리터 방식으로 실행되지만 많이 사용되는 코드는 JIT컴파일러의 대상이 되어서 컴파일 된다.
* 기본적으로 JIT 컴파일러는 사용으로 설정된다.
* -XcompilationThreads 옵션으로 JIT컴파일 스레드 개수를 조절할 수 있다.

## 동작원리
1. JVM은 인터프리터 방식으로 바이트 코드를 실행한다.
2. 실행이 빈번하게 발생하는 코드(핫스팟)을 식별한다.
3. 핫스팟으로 식별된 바이트코드 영역은 JIT컴파일러에 의해 기계어로 컴파일된다.
4. JIT컴파일러에 의해 변환된 기계어는 인터프리터를 거치지 않고 직접 실행된다.
5. 한번 JIT컴파일된 코드는 JVM이 관리하는 코드캐시 또는 메소드 캐시라 불리는 메모리영역에 캐싱되어, 같은코드가 실행될 때 빠르게 접근할 수 있다.

## 핫스팟탐지
다음은 JVM의 핫스팟 탐지 매커니즘 중 하나이다.
* JVM은 각 메서드가 호출될 때마다 그 호출 횟수와 실행에 소요된 시간을 추적하고 특정 호출 횟수에 도달하거나 실행시간이 임계값을 초과하면 해당 메서드는 JIT 컴파일의 대상이 된다.
* 호출 횟수가 기준에 미치지 못하면 JIT컴파일 되지 않을 수 있다.
* 이미 JIT컴파일의 대상이 되었어도 JVM은 실행 시간 동안 프로그램의 동작을 지속적으로 분석하고, 특정 조건하에서 메서드를 다시 컴파일하거나 더 고급의 최적화 기법을 적용할 수 있다.

<br>
<br>
<br>
<br>

# Graal VM

<br>
<br>
<br>
<br>

# Class Loader
바이트 코드를 JVM이 읽을 수 있도록 JVM 메모리 영역에 런타임중에 적재하는 역할을 한다.

## 순서
* 로딩
	* class 파일을 찾아 JVM 메모리에 로드한다.
	* 각 클래스는 JVM내에서 고유한 java.lang.Class 로 표현된다.
* 링킹
	* 검증 : 클래스파일의 유효성을 체크한다. 이때 믿을 수 있는 클래스 파일만 있는 경우 성능향상을 위해 -Xverify:none 옵션으로 검증하지 않을 수 있다.
	* 준비 : 클래스가 필요로 하는 메모리를 할당한다. (static 변수와 기본값)
	* 해석 : 심볼릭 메모리 주소를 실제 힙 메모리 영역에 있는 인스턴스에 대한 주소로 바꾼다.
* 초기화
	* 메모리를 할당한 static 변수와 기본값에 실제 값들을 할당한다.

## 구조
* 부트스트랩 클래스로더
	* JVM이 가장먼저 사용하는 클래스로더
	* jre / lib / jar 및 기타 핵심 라이브러리 같은 JDK 내부 클래스를 로드한다
* 확장 클래스 로더
	* 부트스트랩 클래스 로더를 부모라 가진다.
	* 확장 자바클래스들을 로드한다.
* 시스템 클래스 로더
	* classpath에 있는 즉, 우리가 만든 어플리케이션의 클래스들을 로드한다.


<br>
<br>
<br>
<br>

# 유틸성 클래스의 사용이 객체 지향 설계 원칙에 어떤 영향을 미치며, 어떻게 개선할 수 있을까요?

유틸성 클래스 사용은 응집도를 떨어뜨리고 객체 지향적인 설계와 거리가 있을 수 있다.

* 유틸성 클래스를 사용할 때 응집도와 결합도에 미치는 영향은 무엇인가요?
* 유틸성 클래스 대신 객체 지향적인 설계를 적용하기 위한 구체적인 방법은 무엇인가요?
* 유틸성 클래스의 사용을 줄이기 위해 디자인 패턴을 어떻게 적용할 수 있을까요?

<br>
<br>
<br>
<br>

# 자바의 가비지 컬렉션 메커니즘은 어떻게 동작하나요?
* 가비지 컬렉션의 대상이 되는 객체를 판별하는 기준은 무엇인가요?
* 가비지 컬렉터의 종류와 각각의 특징은 무엇인가요?
* 가비지 컬렉션으로 인한 성능 저하를 최소화하기 위한 방법은 무엇인가요?
* 가비지 컬렉션 로그를 분석하는 방법은 무엇인가요?
* 실시간 시스템에서 가비지 컬렉션을 관리하는 방법은 무엇인가요?

<br>
<br>
<br>
<br>

# 가비지 컬렉터의 작동 원리와 종류에 대해 설명하고, 각각의 장단점은 무엇인가요?
* 가비지 컬렉션 과정에서 발생할 수 있는 문제점과 해결 방법은 무엇인가요?
* 실시간 시스템에서 가비지 컬렉터의 영향을 최소화하기 위한 전략은 무엇인가요?
* 다양한 가비지 컬렉터 중 특정 애플리케이션에 적합한 가비지 컬렉터를 선택하는 기준은 무엇인가요?

<br>
<br>
<br>
<br>

# 스프링 스케줄러와 스프링 배치의 차이점을 설명하고, 각각의 적절한 사용 사례를 제시하세요.

스프링 스케줄러와 스프링 배치는 비동기 작업 처리에 사용되지만, 사용 목적과 방식에 차이가 있다

* 스프링 스케줄러의 내부 구현 방식과 스케줄링 알고리즘은 무엇인가요?
* 스프링 배치의 주요 구성 요소와 각 요소의 역할은 무엇인가요?
* 대용량 데이터 처리를 위한 스프링 배치의 최적화 방법은 무엇인가요?

<br>
<br>
<br>
<br>

# RDB에 바로 데이터를 쌓는 방식의 위험성을 설명하고, 이를 해결하기 위한 대안적인 데이터 관리 전략은 무엇인가요?

RDB에 바로 데이터를 쌓는 방식은 관리가 어렵고, 데이터의 일관성을 유지하기 어렵다.

* RDB에 데이터를 직접 쌓을 때 발생할 수 있는 성능 문제와 이를 해결하기 위한 방법은 무엇인가요?
* 데이터 무결성을 유지하기 위해 RDB와 함께 사용할 수 있는 기술은 무엇인가요?
* 대용량 데이터 처리를 위한 데이터 파이프라인 구축 시 고려해야 할 사항은 무엇인가요?

<br>
<br>
<br>
<br>

# TCP 통신과 REST API의 기본 원리를 설명하고, 각각의 장단점 및 적절한 사용 사례를 제시하세요.

TCP 통신과 REST API는 각각 다른 목적과 환경에서 사용되며, 이해와 적용이 중요하다.

* TCP 통신에서 발생할 수 있는 문제와 이를 해결하기 위한 방법은 무엇인가요?
* REST API 설계 시 고려해야 할 주요 원칙은 무엇인가요?
* 대규모 시스템에서 REST API의 성능을 향상시키기 위한 전략은 무엇인가요?

<br>
<br>
<br>
<br>

# 자바에서 동기화(Synchronization)의 필요성과 구현 방법은 무엇인가요?
* 동기화를 구현할 때의 잠재적인 문제점은 무엇인가요?
* synchronized 키워드와 ReentrantLock의 차이점은 무엇인가요?
* 동기화된 컬렉션과 Concurrent 컬렉션의 차이점은 무엇인가요?
* wait()와 notify() 메서드의 역할은 무엇이며, 어떻게 사용하나요?
* 자바의 메모리 모델과 동기화의 관계에 대해 설명해주세요.

<br>
<br>
<br>
<br>

# 자바의 예외 처리 메커니즘에 대해 설명하고, checked 예외와 unchecked 예외의 차이점은 무엇인가요?
* 사용자 정의 예외를 만드는 방법과 그 필요성은 무엇인가요?
* try-with-resources 구문의 동작 원리와 장점은 무엇인가요?
* throw와 throws 키워드의 차이점은 무엇인가요?
* 예외 체인이란 무엇이며, 어떻게 사용하나요?
* finally 블록에서 리턴문을 사용할 때의 주의점은 무엇인가요?

<br>
<br>
<br>
<br>

# 자바의 컬렉션 프레임워크에서 List, Set, Map의 차이점은 무엇이며, 각각 언제 사용하는 것이 적합한가요?
* ArrayList와 LinkedList의 차이점과 사용 시 고려해야 할 사항은 무엇인가요?
* HashSet, LinkedHashSet, TreeSet의 차이점은 무엇인가요?
* HashMap과 Hashtable의 차이점은 무엇이며, ConcurrentHashMap은 어떤 문제를 해결하나요?
* Collections 클래스에서 제공하는 동기화 래퍼(synchronized wrapper)의 사용 방법과 목적은 무엇인가요?
* 컬렉션의 스트림 API 사용 예제를 들어 설명해주세요.

<br>
<br>
<br>
<br>

# 캐싱의 원리와 적용 사례 연구하기
캐싱은 성능 최적화 기법으로, 자주 사용되는 데이터를 빠르게 접근할 수 있도록 메모리에 저장한다.

<br>
<br>
<br>
<br>

# GraalVM에 대해 조사하고 그 특성 이해하기
GraalVM은 다양한 언어를 지원하는 고성능 가상 머신으로, 빌드 시간을 단축시키고 실행 성능을 향상시킨다.

<br>
<br>
<br>
<br>

# 자바 컴파일 과정과 클래스 로더에 대해 학습하기


