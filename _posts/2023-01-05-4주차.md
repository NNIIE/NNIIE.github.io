---
layout: single
title:  "4주차"
categories: TIL
tag: [Generic, 시공간복잡도, Nested Class]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>




 
# Today I Learned

## CQRS Pattern
Command and Query Responsibility Segregation (명령과 조회의 책임 분리)
<br>
즉, 명령(command)및 쿼리의 책임을 분리하는 패턴이다. 책임분리를 위해서는 코드의 모듈이 분리되어야 한다.
<br>
read 와 write를 분리하는것을 뜻하며 어플리케이션까지만 적용할 수도 있고, DB의 모델까지만 분리할 수도 있고, DB 그 자체를 분리하여 적용할 수도 있다.

* 명령은 데이터중심이 아니라 작업 기반이어야 한다.
* 명령은 동기적으로 처리되지 않고 비동기처리를 위해 큐에 배치될 수 있다.
* 쿼리는 데이터베이스를 수정하지 않는다. 쿼리는 도메인 지식을 캡슐화하지 않는 DTO를 반환한다.

### 장점
---
* 읽기 모델과 쓰기 모델을 필요에 따라 독립적으로 확장 가능
* 읽기 모델은 쿼리에 최적화된 스키마를 사용 가능
* 호출되는 도메인 엔티티에 대해 확인하는 로직 구현이 더 쉬움
* 보통 복잡한 비지니스 로직 구현은 대부분 쓰기 모델에 속하며, 읽기 모델은 간단하게 구현된다. 그에 따라 읽기와 쓰기를 분리하면 유지관리가 더 쉽고 유연한 모델이 구현될 수 있다.
* DB에 논리적인 View가 아닌, Materialized View를 저장함으로써 애플리케이션에서 복잡한 조인이 사용된 쿼리문을 피할 수 있다.

### 언제 쓰면 좋을까?
---
* 많은 사용자가 동일한 테이터에 병렬로 엑세스 하는 공동작업 도메인일 경우
* 한팀은 쓰기모델에 포함되는 복잡한 도메인 모델에 집중하고 다른팀은 읽기모델과 사용자 인터페이스에 집중할 수 있을 환경일 경우
* 시스템이 시간이 자나면서 진화할 것으로예상되어 여러 버전의 모델을 포함할 수 있거나 비즈니스 규칙이 정기적으로 변하는 경우

<br>

## Generic
아주 유용한 문법이고 대부분 최신 언어에선 사용한다.
<br>
타입시스템을 더 견고하게 사용하기 위해 제네릭을 사용한다

* 타입시스템이란? 그리고 자바의 타입시스템
* 타입을 재사용하고 싶어서? -> 이유는 제네릭 다이아몬드 문법 안에 어쩌고? 
* 공변? 반공변?
	* 무엇인지 정도만
* 자바는 공변설정이 약하다?
* 평소 우리가 제네릭을 제일많이 쓰는곳은 Map<Integer, Integer> 같은거 
* 자바는 강타입 언어 자바스크립트는 약타입 언어
	* 자바는 서버언어로 쓰는데 서버는 다르다... 안정성이 제일 중요하다?
		* 왜냐하면 서버에서 고치는것보다 컴파일단계에서 서버에 올라가기 전에 고치는게 훨씬 좋다 -> 그래서 최대한 빠른단계에서(컴파일) 실수를 잡는게 좋다. 디비에 올라간거 고치기 힘들잖아

* 자바는 컴파일 통과하면 런타임에선 타입정보가 다 지워진다. 그래서 제네릭으로 파라미터를 받으면 파라미터의 타입정보가 없다?

<br>

## 시간/공간 복잡도의 상관관계
* 시간복잡도 : 특정크기의 연산에 걸리는 절대적인 시간 즉, 연산 횟수
* 공간복잡도 : 특정크기의 연산에 드는 메모리 사용량

<br>
우리가 하는 거의 모든 작업들은 시간복잡도와 공간복잡도를 서로 교환 한다.
<br>
물론 이 둘이 모든 상황에서 정 반대에 있는건 아니다.

<br>

### Caching
---
* 시간복잡도의 리소스를 공간복잡도의 리소스로 바꾸는거다.
* `redis`를 사용 해서 데이터를 보다 빠르게 조회할 수 있다면 그만큼 탐색범위를 줄여 시간복잡도를
<br>
줄일 수 있지만 그만큼 캐싱에 들어가는 메모리를 사용해서 공간복잡도는 올라가게 된다.

<br>

### HashMap
---
* 해시알고리즘으로 만든 key를 메모리에 올려두고 그 key값만 찾아가면 되기때문에 데이터 크기에 상관 없이 시간복잡도가 O(1)인 대신 그만큼 key값을 저장하는 메모리 공간을 사용하기 때문에 공간복잡도는 올라간다.

<br>

### 만약 메모리가 부족하다면?
---
메모리를 적게 써야하는 상황이라면 공간복잡도를 줄여서 시간을 많이쓰는
<br>
즉, 탐색을 더해서 시간복잡도를 올려야 한다.

<br>

### 의문점
---
보통 공간복잡도 보다 시간복잡도를 더 우위에 두고 작업을 하기 마련이다.
<br>
그렇다면 그 이유는 과거에 비해 하드웨어의 발전이 많이 이루어 졌기 때문이고
<br>
웹 어플리케이션의 등장으로 request / response의 단순함으로 인해 
<br>
메모리에 올려둔 객체들의 생명주기가 짧아져 가비지컬렉터에 의해 금방금방 지워지기 때문일까?

- - -

틀린 접근은 아니다. 세상이 발전함에 따라 과거보다 현재 시간복잡도가 더 중요하게 되었다.
* 하드웨어의 폭발적인 발전
* 멀티코어를 통한 동시성 개발
* request / response 사이클로 인한 짧은 객체의 생명주기

하지만 우리가 접할 기회가 흔한건 아니지만
<br>
여전히 공간복잡도의 한계가 있는 경우가 있다.

* 빅데이터
* 백데이터의 크기
	* ex) 구글이 검색을 제공하기 위한 백데이터의 크기
* 머신러닝이 학습하는 학습데이터는 거대한 메모리를 사용할까? 오랜 학습시간을 들일까?

- - -

명확하지 않은 결론을 내리자면,
<br>
우리는 현재는 시간복잡도를 더 우선해서 경감하는게 더 장점이 많은 시대에 살고있고 
<br>
현업에서 어떠한 규칙으로 삼아도 될 정도이지만 몇십만명이 될지도 모르는 회원정보를 
<br>
`redis`에 올리지 않는 것처럼 경우에 따라 적절하게 사용하는것이 중요하겠다.

<br>

# To Do

## Nested Class
중첩클래스(nested class)는 클래스 내에 정의된 클래스를 말한다. 
<br>
중첩클래스는 `static`으로 선언되지 않은 내부클래스(inner class)와
<br>
`static`으로 선언된 정적 클래스(static class)로 나뉜다.

```java
class OuterClass {
	...
	class NestedClass {
		...
	}
}
```

<br>

### Inner Class
---
```java
class OuterClass {
	private int a = 10;

	private class InnerClass {
		public void print() {
			System.out.println("OuterClass.a = " + a);
		}
	}
}
```

* `inner class`를 인스턴스화 하려면 외부 클래스를 먼저 인스턴스화 해야 한다.
	* 외부클래스와 `innerClass` 두 객체의 참조값은 서로 다르다.
* `inner class`는 자신을 둘러싼 외부 클래스의 인스턴스 변수 / 메서드에 접근할 수 있다.
	* 외부클래스 인스턴스에 대한 외부참조를 가지기 때문이다.
		* 따라서 가비지컬렉션이 수거하지못해 `memory leak`의 위험성이 존재한다.
* 외부클래스에선 `inner class` 멤버를 사용할수 없다. (사용하려면 객체를 직접 발생시켜야함)
* `inner class`는 외부클래스의 멤버와 동일한 이름을 사용할 경우 외부클래스 멤버에 접근하고 싶으면 
<br>
명시적으로 나타내야 한다. (OuterClass.this.a)
* 외부클래스의 `private` 멤버에 접근할 수 있다.
* `inner class`는 외부 클래스의 멤버이므로 접근제한자를 사용할 수 있다.
* 정적 멤버선언(static)이 불가능하다.
	* `final`키워드를 사용하면 가능하다.
	* 자바 16 이후부터는 `inner class`에서 정적멤버 생성이 가능하다.

<br>

### Static Inner Class
---
```java
class OuterClass {
	...
	static class StaticInnerClass {
		...
	}
}
```

* 같은 `static inner class`의 객체를 2개 만들어도 두 객체의 참조값은 서로 다르다.
* 정적클래스는 외부 클래스를 인스턴스화 할 필요가 없기 때문에 외부클래스의 변수 / 메서드에 접근할 수 없다. 
<br>
(외부클래스의 static 멤버만 접근 가능)
* 정적클래스 내부에서 `static` 멤버를 사용할 수 있다.

<br>

### 익명클래스
---
펑션을 상속받는? 이름이 없는 로컬클래스.
<br>
이름이 없기 때문에 익명클래스는 객체를 여러번 생성할 수 없으며 생성자를 만들수도 없다.
<br>
클래스가 딱 한번만 필요할 때 유용하다.

<br>

### Lambda
---

<br>

### 활용
---
* `inner class`는 참조값을 담아야 하기 때문에 인스턴스 생성시 시간,공간적으로 성능이 낮아진다.
* `static inner class`는 외부 인스턴스에 대한 참조가 존재하기 때문에, 
<br>
***가비지 컬렉션이 인스턴스 수거를 하지 못하여 memory leak이 생길 수 있다.***
* `static inner class`를 사용하는 것이 좋으며 `static` 키워드를 사용하고싶지 않으면 별개의 클래스로 만드는 것이 좋다.
* 하지만 ***Lambda*** 의 경우 얘기가 조금 달라지는데...

<br>

### 의문점
---
* ***Lambda*** 로 파라미터를 넘기면 그건 객체, 그게 바로 익명클래스라는데 알아보자
* ***Lambda*** 는 일종의 `inner class` 인데 가비지컬렉터의 메모리 누수에는 안전하다 알아보자
	* 객체는 또 다르다던데?

<br>

## Collection

<br>

## 중복
### 중복이 나쁜경우
---
### 중복이 차라리 나은경우
---




<br>
