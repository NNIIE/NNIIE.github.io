---
layout: single
title:  "6 Week"
categories: TIL
tag: [Tomcat, Filter, Web, Session, OSI 7계층, TCP / UDP, Bulk 처리, SSR, CSR, HTTPS, Base64]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>



# Web
아래 내용들을 무엇이다 라고 정의해보려고 했는데 명쾌하게 떠오르지 않았다.
<br>
이참에 한번 짚고 넘어가자.
<br>
<br>
<br>
**World Wide Web**
<br>
<br>
인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간

* 텍스트, 그림, 소리, 영상 등의 멀티미디어 정보를 하이퍼텍스트 방식으로 연결
	* 하이퍼텍스트 : 문서 내부에 또다른 문서가 연결되는 참조를 넣음


웹페이지들은 각각 연결되어 있는데 이로 인해 거미줄처럼 얽혀있는 정보의 모음이라고도 불림

<br>

**웹페이지**
<br>
<br>
정보제공을 목적으로한 `정적`인 사이트
<br>
수동적으로 정보를 관람함

<br>

**웹어플리케이션**
<br>
<br>
`동적`기능을 가진 웹으로 상호작용을 통해 유저가 
<br>
능동적으로 어플리케이션 상의 서비스를 이용하는것을 목적으로 함

<br>
<br>
<br>
<br>

# Browser Rendering

<br>

## SSR
**서버사이드 렌더링 - Server Side Rendering**
<br>
서버로부터 완전하게 만들어진 `HTML`  파일을 받아오는 방식
<br>
렌더링이 서버에서 일어난다.
<br>
* **동작**
1. 클라이언트가 요청을 보냄
2. 서버는 `HTML` 에 데이터, `CSS`, `JS` 를 렌더링하여 컴파일 후 보낸다.
3. 클라이언트는 즉시 `HTML` 을 먼저 렌더링 하고 그 후 `JS` 코드를 받아 실행한다.
<br>
<br>
* **장점**
	* 빠른 초기 로딩
	* `HTML` 안에 모든 데이터가 포함되어 있어 검색엔진에 노출이 잘됨 (크롤링)
<br>
<br>
* **단점**
	* 요청시마다 새로고침 (깜빡임)
	* 서버부하 (작은 변경이라도 서버에서 모든걸 다시 받아옴)

<br>

## CSR
**클라이언트 사이드 렌더링 - Client Side Rendering**
<br>
사용자에 요청에 따라 필요한 부분만 응답받아 렌더링 하는 방식
<br>
렌더링이 클라이언트 쪽에서 일어난다.
<br>
* **동작**
1. 클라이언트에서 초기화면을 로드하기 위해 서버에 요청을 보냄
2. 서버는 화면에 표시하는데 필요한 완전한 리소스 응답
<br>
<br>
* **장점**
	* 빠른속도 (초기화면 렌더링X)
	* 서버부하 감소 (클라이언트에서 변경부분만 요청)
	* 유저경험 증가 (깜빡임)
<br>
<br>
* **단점**
	* 초기화면 로딩 느림 (`JS`포함 모든 파일을 받아야 함)
	* 검색엔진에 노출이 잘 안됨 (`HTML` 자체는 깡통이므로)

<br>
<br>
<br>
<br>

# HTTP의 전송방식
`GET`, `POST` 등의 전송방식이 있지만 모두 텍스트 형식이다.
<br>
HTTP 전송방식에 왜 텍스트를 사용했을까?
* 다양한 환경에 맞는 (범용적, 유연함) 규약이 필요했다.
* 왜나햐면 `Web`은 말그대로 전세계 모든 사람이 이용하는, 엄창나게 많은 곳에서 쓰인다. 
* 일단 텍스트는 눈으로 보고 어느정도 의미를 유추할 수 있고
* 클라이언트에 상황에 구애받지 않는 텍스트가 가장 보편적이었다.
* 따라서 바이트코드나 비트같이 가볍지만 제약이 따르는 것들 대신 보편적인 텍스트를 쓰는것이다.

<br>

**그렇다면 HTTPS는?**
<br>
<br>
하이퍼 텍스트 전송 프로토콜 즉, `HTTP`는 `HTML`을 전송하기 위한 통신 규약이다.
<br>
하지만 암호화 되지 않은 방법으로 데이터를 전송하기 때문에 보안에 취약하다.
<br>
그래서 이를 보완한 것이 `SSL` 또는 `TLS` 사용해 암호화된 `HTTPS` 이다.
<br>
`SSL, TLS` 는 응용계층`(HTTP)` 과 전송계층`(TCP)` 사이에 위치해 있다.

* **SSL** : 서버와 브라우저 사이에 전송되는 데이터를 암호화 함
* **TSL** : `SSL`의 향상된 버전, 통신하는 대상간의 데이터의 무결성을 제공하는걸 목표로 함
<br>
<br>

**인증서 동작**
<br>
<br>
`SSL/TSL` 세션은 핸드셰이크라는 과정을 통해 클라이언트-서버 간에 암호화 된 연결을 수립한다.
* **인증**
	* 클라이언트가 시작하는 모든 신규 세션에 대해 서버는 각각 다른 `SSL` 인증서를 교환하고 검증한다.
* **암호화**
	* 서버는 클라이언트와 공개 키를 공유하고 클라이언트는 이 키를 사용해 프리마스터 키를 생성해 암호화한다. 이를 키교환이라고 한다.
* **복호화**
	* 서버는 개인 키를 사용해 프리마스터 키를 복호화 하고, 세션기간동안 사용되는 암호화된 보안연결을 수립한다.

<br>
<br>
<br>
<br>

# Base64
**Binary Data 를 Text로 바꾸는 인코딩** 의 하나로써 `Binary Data` 를 Character set에 영향을 받지 않는 공통 `ASCII` 영역의 문자로만 이루어진 문자열로 바꾸는 인코딩이다.
<br>
`Base64`는 직역하면 64진법인데, 64진법은 2의 제곱수에 기반한 진법 중 화면에 표시되는 `ASCII` 문자들로 표시할 수 있는 가장큰 진법이다.
* **인코딩** : 정보의 형태나 형식을 표준화, 보안, 처리속도향상 등을위해 다른 형태나 형식으로 변환하는 처리

<br>

**왜쓰는데?**
<br>
<br>
`Base64`로 인코딩하면 데이터양이 약 33% 늘어나고 다시 디코딩하는 추가연산도 필요하다. 근데 왜쓸까?
<br>
HTTP로 `Binary Data`(이미지, 오디오 등)를 전송하면 문제가 발생하는데, 대표적으로
* `ASCII`는 `7bits` 인코딩 인데 나머지 `1bit` 를 처리하는 방식이 시스템 별로 상이하다.
* 일부 제어문자 (e.g. Line ending)의 경우 시스템 별로 다른 코드값을 갖는다.
<br>

즉,`Binary Data`의 손실이 일어나기 때문에, **ASCII는 시스템간 데이터를 전달하기에 안전하지가 않다.** 
<br>
그래서 `ASCII` 중 제어문자와 일부 특수문자를 제외한 64개의 안전한 출력 문자만 사용하는 `Base64`를 사용한다.


<br>
<br>
<br>
<br>

# Bulk 처리
대량의 데이터를 한번의 트랜잭션으로 삽입하는 방법이다.
<br>
<br>
insert 로 예를들면
<br>
`MyBatis` 기준 insert 구문 수행 시 values 리스트를 다중으로 사용한다.
<br>

```sql
insert into A values(a, b, c), (a, b, c), (a, b, c) ...


insert into A(a, b, c) values
<foreach collection="list" item="item" separator=",">
	#{item}
</foreach>
```

<br>

**왜쓰는데?**
<br>
<br>
DB와의 트랜잭션은 커넥션을 열고 닫는 등의 생각보다 복잡하고 리소스가 큰데 10000건의 데이터를 
<br>
저장하는 경우를 생각해 보면 데이터를 저장하는데 10000번의 트랜잭션이 일어나게 된다.
<br>
하지만 `bulk insert` 의 경우 단 한번의 트랜잭션으로 처리를 할 수 있기 때문에
<br>
데이터 수가 많을수록 비약적으로 성능이 향상된다.
<br>
실제로도 예전에 거의 안쓰이는 스케쥴러 처리한 `insert` 용도의 `API` 가 있는데 어느순간
<br>
급격히 사용량이 많아져서 데이터 처리에 딜레이가 발생하는 상황이 생긴적이 있는데
<br>
이때 `bulk` 처리 하나로 비약적인 성능향상과 이슈를 해결한 적이 있었다.
<br>
물론 신경써야할 것도 있는데 그건 아래 단점에서..

<br>
<br>

**단점**
<br>
<br>
`bulk insert` 로 10000건의 데이터를 insert 하던 중 마지막 `low` 에서 에러가 발생한다면?
<br>
이럴경우 모두 롤백된다.
<br>
<br>
10000번의 트랜잭션을 1번의 트랜잭션으로 해결해서 비약적인 성능향상을 가져올 수 있지만 하나라도 
<br>
실패하는 순간 트랜잭션은 롤백되고 그 트랜잭션 안에 10000건이 있기 때문에 이렇게 되면 매우 비효율적이다.
<br>
그래서 너무 대량의 데이터를 `bulk` 처리 하는건 좋지않고,
<br>
실패할 경우를 대비해 `retry` 하는 코드도 별도로 짜주는게 좋다.
<br>
제일 좋은건 정합성이 뛰어난 데이터여서 실패할 가능성이 거의 없을때 사용하는게 좋겠다.

<br>
<br>
<br>
<br>

# To Do

<br>
<br>
<br>
<br>

# 세션이 왜필요할까?
쿠키도 있는데 말이야..

<br>
<br>
<br>
<br>

# Tomcat

<br>
<br>
<br>
<br>

# Filter

<br>
<br>
<br>
<br>

# ServletContextListener

<br>
<br>
<br>
<br>

# TCP / UDP

<br>
<br>
<br>
<br>

# 배치시스템 vs 스트리밍 시스템

<br>
<br>
<br>
<br>

# OSI 7 계층
계층이 올라간다는건 무슨 의미일까?
<br>
<br>
TCP 기반의 HTTP가 UDP통신을 도입하고 있는데 과연 데이터 정합성의 문제는?

* 데이터 정합성의 검증을 한 계층 더 올려서 거기서 한다는데?
* 그러니까 TCP를 사용하는 계층에선 정합성의 문제에서 자유로우니 UDP 통신을 이용한다?

<br>
<br>
<br>
<br>


<br>