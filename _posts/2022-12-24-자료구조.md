---
layout: single
title:  "자료구조"
categories: Data_Structure
tag: [data structure]
author_profile: false
toc: true
toc_label: "TIL"
toc_sticky: true
# toc_icon: "heart"  # corresponding Font Awesome icon name (without fa prefix)
---
<br><br><br>



# Hash
임의의 크기를 가진 데이터를 고정된 크기의 데이터로 바꾸는 것.
<br>
단방향 암호화 기법으로 해시함수 또는 해시 알고리즘를 이용해 고정된 길이의 비트열로 변경한다.
<br>
10 X 10 = 100 이라는 것은 쉽게 알지만, 몇과 몇을 곱해야 100이 나오는지는 많은 경우의 수가 나오는데
<br>
해싱은 이런식으로 복호화가 어렵다.
<br>
하지만 동일한 문자열은 `항상 같은 해시값`이 나온다는 단점이 있다.
<br>
예를들어 동일한 비밀번호는 항상 `해시값이 같다.`


* ***HashTable***
<br>
key와 value의 쌍으로 이루어진 데이터 구조이다.
<br>
해시충돌이 일어나지 않는 가정 하에 평균 시간복잡도 O(1)로 효율적이다. 
<br>
이는 배열에서 `index`를 알고 접근하는 것과 동일한 시간복잡도를 보인다.

* ***key*** : 해시함수의 input이 되는 고유 값, 키는 해시함수를 통해 해시로 변경되고 `index` 역할을 하게된다.
* ***value*** : 저장소(버킷, 슬롯)에 최종적으로 저장되는 값.
* ***Hash*** : 임의의 값을 가지는 key값을 고정된 길이로 변환하는 것
* ***Hash Function*** : 임의의 값을 고정된 크기의 값으로 변환하는 함수.  key -> hash
* ***저장소(Bucket, Slot)*** : Hash Table 에서 하나의 데이터가 저장되는 공간
* ***해시충돌*** : 서로 다른 key가 같은 hash값이 되는 경우

	* ***데이터 저장***
		<br>
		해시함수를 이용해 키값을 해시로 변경한 후 미리 준비해둔 저장소(버킷, 슬롯)중 
		<br>
		알맞는 해시값을 찾아 value를 저장한다.
		<br>
		이 과정의 시간복잡도는 O(1) 이다.

	* ***데이터 삭제***
		<br>
		버킷에서 삭제하려고 하는 key와 매핑되는 value값을 찾아서 삭제한다
		<br>
		이 과정의 시간복잡도는 O(1) 이다.

	* ***데이터 검색***
		<br>
		key를 이용해 value를 찾아내는 과정.
		<br>
		먼저 key값과 해시함수를 이용해 hash를 찾아내고 해당 hash로 value를 찾는다.
		<br>
		이 과정의 시간복잡도는 O(1) 이다.

<br>

* ***자바의 Hash?***
	* 자바에서는 `Object`클래스의 hashCode() 메서드로 모든 객체의 해시코드를 쉽게 구할 수 있다 
	* 자바는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 중복되지 않는 값을 제공한다.
	* String의 경우 `Object`로부터 상속받은 hashCode()를 오버라이딩 하여 문자열의 내용으로 해시코드를 만들어 낸다. 그렇기 때문에 다른 인스턴스의 String이어도 문자열이 같다면 같은 해시코드값을 가진다.
	* HashMap도 같은 방법으로 객체를 구별하기 때문에 이미 존재하는 키와 동일한 값을 저장하면 기존의 값을 덮어쓰게 된다.

<br>

* ***HashTable과 HashMap***
	<br>
	둘의 차이는 `Thread-Safe` 의 차이이다. 
	<br>
	HashTable은 동기화가 걸려있어 안전하지만 느리고 HashMap은 동기화가 없어서 불안전하지만 빠르다.

<br>

* ***단점***
	* 정렬이나 순차적인 데이터 저장에 적합하지 않다
	* 데이터가 저장되기 전에 저장공간을 확보해야 하기 때문에 공간효율성이 떨어진다.
	* Hash Function이 복잡할수록 연산속도가 증가한다.
	* 해시충돌이 발생할 경우 최악의 경우 시간복잡도가 O(N) 에 점점 수렴함

<br>

# Set 자료구조 확인하기
데이터의 집합이며 순서가 없고 집합이므로 중복된 데이터를 허용하지 않는다.
<br>
중복되지 않은 데이터를 구할 때 유용하고 빠른 검색 속도를 가진다.
<br>
인덱스가 따로 존재하지 않기 때문에 iterator를 사용함
* 성능적으로 어떻게 사용하면 훨씬 효율적일까? 예를들면 contains

<br>

# List

<br>

# Array

<br>

# Map

<br>

# Stack

<br>

# Queue

<br>

# Tree

<br>

# Graph
