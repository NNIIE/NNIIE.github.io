<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-18T17:42:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">1주차</title><link href="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="1주차" /><published>2022-12-15T00:00:00+09:00</published><updated>2022-12-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="today-i-learned">Today I Learned</h1>

<h2 id="객체와-클래스-그리고-인스턴스">객체와 클래스 그리고 인스턴스</h2>
<ul>
  <li><strong><em>객체</em></strong>
    <ul>
      <li>물리적, 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.</li>
      <li>소프트웨어 에서 구현할 대상</li>
    </ul>
  </li>
  <li><strong><em>클래스</em></strong>
    <ul>
      <li>java에서 객체를 생성하기 위한 일종의 설계도</li>
      <li>속성(필드)을 가지고 있고, 행위(메소드)를 가지고있다.</li>
      <li>oop의 관점에서 클래스 타입으로 선언되었을 때 ‘객체’라고 부른다.</li>
    </ul>
  </li>
  <li><strong><em>인스턴스</em></strong>
    <ul>
      <li>클래스를 가지고 객체를 실체화 한것.</li>
      <li>메모리에 할당되어 실제로 사용되는 객체</li>
    </ul>
  </li>
</ul>

<h2 id="절차형-객체지향-함수형-패러다임">절차형, 객체지향, 함수형 패러다임</h2>
<ul>
  <li><strong><em>절차형 프로그래밍 (Procedural Programming)</em></strong>
<br />
위에서부터 아래로의 순차적인 처리를 중요시 하며 루틴, 서브루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임
    <ul>
      <li><strong><em>장점</em></strong>
        <ul>
          <li>컴퓨터 처리구조와 유사해 실행속도가 빠르다.</li>
        </ul>
      </li>
      <li><strong><em>단점</em></strong>
        <ul>
          <li>코드가 길어지면 가독성이 떨어지며 유지보수가 어렵다.</li>
          <li>정해진 순서대로 입력을 해야하므로 순서가 바뀌면 결과를 보장할 수 없다.</li>
          <li>대형 프로젝트에 적합하지 않다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><em>객체지향 프로그래밍 (OOP)</em></strong>
<br />
모든 것을 객체로 취급하고 객체가 처리요청을 받았을 때, 객체 내부의 기능을 사용해 처리하는 방법이다.
<br />
클래스 디자인과 객체들의 관계를 중심으로 설계가 이루어진다.
<br />
따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있고, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라진다.
    <ul>
      <li><strong><em>특징</em></strong>
        <ul>
          <li>캡슐화 - 정보를 은닉하고 노출시키지 않는다.</li>
          <li>추상화 - 공통적인 속성이나 기능을 묶는다.</li>
          <li>상속 - 아래 더 자세히..</li>
          <li>다형성 - 아래 더 자세히..</li>
        </ul>
      </li>
      <li><strong><em>장점</em></strong>
        <ul>
          <li>재사용에 용이하다. (확장, 유지보수)</li>
          <li>분석과 설계의 전환이 쉽다.</li>
        </ul>
      </li>
      <li><strong><em>단점</em></strong>
        <ul>
          <li>처리속도가 상대적으로 느리다.</li>
          <li>모든 객체의 역할과 기능을 설계해야 하기 때문에 많은 시간이 소요된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><em>함수형 프로그래밍</em></strong>
<br />
순수함수를 사용해 상태를 제어하지 않고 빠른 처리에 집중하는 방식, 함수 자체가 일급객체가 된다. 
<br />
OOP와는 데이터(상태)를 다루는 개념과, 간결한 코드 작성에 대한 관점차이가 있다.
<br />
<br />
<strong><em>일급객체</em></strong> - 다른 요소들과 아무런 차별이 없는 객체, 함수를 변수로 사용할 수 있다는 의미도 된다.
<br /></p>

    <ul>
      <li><strong><em>장점</em></strong>
        <ul>
          <li>함수가 하는일은 명확하기 때문에 코드의 가독성이 좋아지고 테스트가 쉬워진다.</li>
          <li>값이 한번 변수에 할당되면 이후에 변경되지 않기 때문에 부수효과가 발생하지 않으며 참조투명성을 가진다. 즉, 멀티코어 프로세스에서 교착상태에 빠지지 않는다.</li>
          <li>동시성 프로그래밍에 용이하다.</li>
        </ul>
      </li>
      <li><strong><em>단점</em></strong>
        <ul>
          <li>상태의 조작이 불가능하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li><strong><em>그래서 뭐가 좋은데?</em></strong>
<br />
자바8에서 함수형 프로그래밍을 도입했다. 
<br />
객체지향을 추구하는 자바진영에서 왜 함수형 프로그래밍을 도입했을까?
<br />
데이터 자체를 핸들링하는 함수형 프로그래밍은 어떤 데이터가 들어가도 로직 수행 후 의도한 데이터를 리턴한다. 
하지만 객체지향은 여기에 상태까지 관리해 줘야 하기 때문에 신경 쓸것이 많다. 
<br />
현대 어플리케이션은 함수형과 객체지향을 모두 사용한다. 
<br />
예를들면, 내가 매일 작업하는 로직들은 함수형 이지만, 디비에 접근하는 순간만큼은 함수형일 수가 없다. 
<br />
데이터를 저장해야 하고 값을 리턴받아야 하고 등의 상태값이 존재하기 때문이다. 
<br />
이외에도 여러가지가 있겠지만 자바8에 추가된 람다의 함수형 프로그래밍도 이와 같다. 
<br />
람다로 코드를 짤 경우 데이터의 무결성을 보장한다. 
<br />
왜냐하면 전통적인 for루프의 경우 객체를 작업하지만 람다의 경우 데이터 그 자체를 핸들링 하기 때문이다.
<br />
결국 시대의 흐름에 맞게 병렬 프로세싱을 잘 활용하기위해 자바 8에서 도입을 했고 
<br />
뭐가 더 좋다기 보단 둘다 적재적소에 사용하는게 중요하겠다.</li>
</ul>

<h2 id="기본형-타입과-참조형-타입">기본형 타입과 참조형 타입</h2>
<ul>
  <li><strong><em>원시타입(Primitive type)</em></strong>
    <ul>
      <li>정수, 실수, 문자, 논리 리터럴등의 실제 데이터값을 저장하는 타입</li>
      <li>기본값이 있기때문에 Null이 존재하지 않는다. 기본형 타입에 Null을 넣고싶다면 래퍼클래스를 활용한다.</li>
      <li>제네릭 타입에서 사용할 수 없다.</li>
      <li>실제값을 저장하는 공간으로 Stack 영역에 저장된다.</li>
      <li>실제값이 Stack영역에 있으므로 참조타입보다 접근속도가 빠르다</li>
    </ul>
  </li>
  <li><strong><em>참조타입(Reference type)</em></strong>
    <ul>
      <li>객체의 주소를 저장하는 타입으로 메모리 번지값을 통해 객체를 참조하는 타입</li>
      <li>기본형 타입을 제외한 모든 타입은 참조형 타입이다. (문자열, 배열, 클래서, 열거, 인터페이스 등)</li>
      <li>제네릭 타입에서 사용할 수 있다.</li>
      <li>실제 객체는 Heap 영역에 저장되고 Stack영역에 객체의 주소를 저장해서 참조한다.</li>
      <li>실제값이 Heap 영역에 있고 Stack메모리에는 참조값만 있으므로 값이 필요할 때마다 최소 2번 메모리 접근을 해야하고 박싱/언박싱 과정을 거쳐야 해서 원시타입보다 접근속도가 느리다.</li>
      <li>실제 사용하는 메모리양도 원시타입보다 월등히 많다.</li>
    </ul>
  </li>
  <li><strong><em>String?</em></strong>
    <ul>
      <li>참조타입에 속하지만 기본적인 사용은 원시타입이다.</li>
      <li>불변객체이다. 그래서 String 클래스의 값을 변경하는 메소드를 사용해도 값이 변경되는 것이 아닌 새로운 String 객체를 만든다.</li>
      <li>기본형 비교는 == 사용이지만 String 간 객체비교는 equals()메소드를 사용한다.</li>
    </ul>
  </li>
</ul>

<h2 id="wrapper-class는-무엇이며-왜쓰는가">wrapper class는 무엇이며 왜쓰는가?</h2>
<p>원시타입을 객체로 다루기 위해 사용하는 클래스이다. 기본타입의 값을 내부에 두고 포장해서 포장객체 라고도 불리는데 래퍼클래스로 감싸고 있는 값은 외부에서 변경이 불가능하고 변경하려면 새로운 포장객체를 만들어야 한다. 자바의 모든 객체가 그러하듯 Object를 상속받는다.</p>
<ul>
  <li><strong><em>박싱 / 언박싱</em></strong>
    <ul>
      <li>원시타입을 포장객체로 만드는게 박싱, 반대로 포장객체에서 원시타입을 얻는게 언박싱이다.</li>
      <li>JDK 1.5 이후로 오토 박싱/언박싱을 지원 한다.</li>
      <li>래퍼객체 내부값을 비교하려면 equals를 사용해야 한다. == 는 래퍼 객체의 참조 주소를 비교하기 때문이다.</li>
      <li>래퍼클래스와 원시타입 비교는 둘다 가능하다. JDK 1.5 이후로 오토 박싱/언박싱을 지원하기 때문이다</li>
    </ul>
  </li>
  <li><strong><em>왜 쓰는데?</em></strong>
    <ul>
      <li>원시타입을 클래스화 하여 클래스의 장점을 활용할 수 있다. (클래스에 지원되는 여러 메소드들)</li>
      <li>null 지원</li>
      <li>기본타입을 객체로 써야할 경우가 있음
        <ul>
          <li>ex) List<Integer> 에 원시타입 값을 넣는다던가... (오토박싱/언박싱 지원)</Integer></li>
        </ul>
      </li>
      <li>제네릭에 원시타입은 쓸수가 없음</li>
      <li><strong><em>일급콜렉션</em></strong>
        <ul>
          <li>콜렉션을 래핑할때, 그 외에 다른 멤버변수가 없는 상태를 일급콜렉션 이라한다.</li>
          <li>이렇게 되면 하나의 인스턴스에서 비즈니스 로직을 관리할 수 있게 되는 장점이 있다.
            <ul>
              <li>ex) 같은 객체를 여러개 생성해야 할때, 이 모든 인스턴스들을 담는 일급콜렉션을 만들다던가..</li>
              <li>비즈니스 로직을 도메인에서 관리 (비즈니스에 종속적인 자료구조를 만들 수 있음)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="동일성과-동등성">동일성과 동등성</h2>
<ul>
  <li><strong><em>동일성</em></strong>
    <ul>
      <li>두 객체가 완전히 같은 경우.
  <br />
  주소값이 같기 때문에 하나의 객체로 봐도 무방하며 두 변수가 같은 객체를 참조한다.</li>
      <li>== 연산자를 사용해 판별할 수 있다.</li>
      <li>원시타입은 객체가 아닌 스택메모리에 직접 값이 올라가기 때문에 == 결과가 같으면 동일하다.</li>
    </ul>
  </li>
  <li><strong><em>동등성</em></strong>
    <ul>
      <li>두 객체가 같은 정보를 가지고 있는 경우.
  <br />
  두 객체의 주소가 달라도 내용이 같으면 동등하다고 말할 수 있다.</li>
      <li>equals를 사용해 판별할 수 있다.</li>
      <li><strong><em>equals</em></strong>
        <ul>
          <li>equals 메소드를 재정의 하지 않으면 == 연산자와 다르지 않다.</li>
          <li>객체에서 재정의 할 경우 == 연산자를 통해 두객체가 동일하면 true를 반환하고, 다르다면 동등성을 판단한다.
  재정의 하지 않을 경우 동일성 여부만 판단하기 때문에 동등성비교가 필요하다면 꼭 재정의 해주어야 한다.</li>
        </ul>
      </li>
      <li><strong><em>hashcode?</em></strong>
        <ul>
          <li>equals를 재정의 해줄 때, hashcode도 같이 재정의하는걸 권장한다. 이유가 무엇일까?</li>
          <li>Hash Table을 사용하는 자료형일 경우 문제가 된다. 
  <br />
  동등한 객체 2개를 생성해서 Set에 담게되면 의도한 대로 담기지 않는다. 
  <br />
  Set 자료구조는 중복을 허용하지 않기 때문인데, Hash Table을 사용하는 자료형은 해싱 알고리즘을 사용한다. 해싱된 결과를 주소값으로 찾아가서 같은 자료가 있는지 확인하는데 동등한 두 객체는 다른 주소값을 가지고 있기 때문에 객체의 동등성을 위해 equals메소드와 hashcode메소드는 같이 오버라이드 되어야 지만 동등성을 보장받을 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="to-do">To Do</h1>

<h2 id="자바의-신-2권">자바의 신 2권</h2>
<h2 id="자바의-4가지-접근제어자">자바의 4가지 접근제어자</h2>
<ul>
  <li>접근제어자
객체지향 패러다임에서 정보은닉이란 필요한 정보만 오픈한다는 개념이다.
<br />
자바에서는 정보은닉을 위해 접근제어자 라는 기능을 제공하여 클래스 외부에서 직접적인 접근을 허용하지 않는
변수, 메서드, 생성자를 설정할 수 있다.
<br />
<strong><em>단, 인터페이스의 접근제어자는 무조건 public 이다.</em></strong> 
<br />
인터페이스는 구현클래스가 아니라 추상클래스 이기 때문에
해당 인터페이스를 구현하는 구현클래스에서 구현이 꼭 필요하다. 그렇기 때문에 접근제어자를 생략하더라도 컴파일시 public으로 열어둔다.
    <h2 id="상속">상속</h2>
    <h2 id="다형성">다형성</h2>
  </li>
</ul>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">22.12</title><link href="http://localhost:4000/til/1-TIL/" rel="alternate" type="text/html" title="22.12" /><published>2022-12-04T00:00:00+09:00</published><updated>2022-12-04T00:00:00+09:00</updated><id>http://localhost:4000/til/1-TIL</id><content type="html" xml:base="http://localhost:4000/til/1-TIL/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="lombok">lombok</h1>
<h2 id="getter---prefix">@getter - prefix</h2>
<p>lombok은 boolean 타입일 때 변수의 prefix가 is인 경우 getIsXXX 대신 isXXX 으로 get메서드를 만들어준다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">lombok.Getter</span><span class="o">;</span>

<span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이때 @Getter 로 만들어진 메서드는 getIsMan() 가 아니고 isMan() 가 된다.
<br />
결국 이 DTO 를 받을 경우 아래와 같다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"man"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p><strong><em>해결방법 1. boolean -&gt; Boolean</em></strong>
<br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>원시타입 대신 래퍼타입을 사용한다.
<br />
하지만 래퍼타입이라 null값이 들어가게 되므로 지양하자
<br />
<br />
<strong><em>해결방법 2. get 메서드 직접 작성</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">getIsMan</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="builder">@Builder</h2>
<p>생성자 대신 builder 패턴 적용</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="nd">@Builder</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 사용</span>
    <span class="nc">Person</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">"이름"</span><span class="o">).</span><span class="na">age</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
같은 이름과 같은 매게변수를 가진 메서드가 있으면 @Getter는 메서드를 생성하지 않는다.</p>

<h2 id="noargsconstructor">@NoArgsConstructor</h2>
<p>파라미터 없는 기본생성자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 기본생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="allargsconstructor">@AllArgsConstructor</h2>
<p>모든 필드값을 파라미터로 받는 생성자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 모든 필드를 가진 생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="requireargsconstructor">@RequireArgsConstructor</h2>
<p>final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequireArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span> 
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// final이나 @NonNull인 필드를 가진 생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="data">@Data</h2>
<p>@Getter @Setter @ToString @EqualsAndHashCode @RequiredArgsConstructor 자동생성
<br />
최대한 지양하자</p>
<ul>
  <li>무분별한 getter / setter 남용</li>
  <li>ToString으로 인한 양방향 연관관계시 순환 참조 문제</li>
</ul>

<p><br /></p>

<h1 id="maven--gradle">maven / gradle</h1>
<p>빌드관리도구
<br /></p>
<ul>
  <li>소스코드에서 어플리케이션 생성을 하면서 여러가지 여부 라이브러리를 사용하는데, 빌드 관리 도구는 사용자가 직접 관리할 필요 없이 필요한 라이브러리들을 자동으로 관리한다.</li>
</ul>

<h2 id="maven">maven</h2>
<ul>
  <li>java용 프로젝트 관리 도구로 Apache 의 Ant 대안으로 만들어졌다.</li>
  <li>빌드중인 프로젝트, 빌드순서, 외부라이브러리 종속성 관계를 pom.xml파일에 명시</li>
  <li>멀티프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 <strong><em>상속</em></strong>방식 사용</li>
</ul>

<h2 id="gradle">gradle</h2>
<ul>
  <li>JVM의 스크립트 언어인 groovy로 만들어졌다.</li>
  <li>멀티프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 <strong><em>설정주입</em></strong>방식 사용</li>
</ul>

<h2 id="maven-vs-gradle">maven vs gradle</h2>
<ul>
  <li>gradle 은 빌드시 <strong><em>변경된 파일만 작업</em></strong>하기 때문에 maven 보다 빠름 (10~100배)</li>
  <li>gradle 은 스크립트 언어로 프로젝트가 커질수록 가독성이 maven 보다 좋음</li>
  <li>gradle 이 멀티 프로젝트에 maven보다 적합하다.</li>
</ul>

<p><br /></p>

<h1 id="oom-java-out-of-memory">OOM (java Out Of Memory)</h1>
<h2 id="자바의-메모리">자바의 메모리</h2>
<p>자바는 가비지컬렉터로 메모리 관리를 한다.
<br />
덕분에 개발자는 메모리에 큰 신경을 쓰지 않고 코드를 작성할수 있다
<br />
하지만 가비지컬렉터가 정리해야 할 메모리가 정리되지 못하고 계속 메모리에 남아있게 되는걸 Memory Leak(메모리 누수)
라고 한다. 
<br />
메모리 릭이 계속 될 경우 결국 JVM이 종료되고 만다. 
<br />
메모리 릭의 양이 아주 작고 메모리는 많은 경우에는 주기적으로 JVM을 재시작 하면서 크게 신경안써도 될 경우도 있지만, 메모리릭이 빠르게 증가하는 경우에는 반드시 해결해줘야 한다</p>

<h2 id="왜-발생">왜 발생?</h2>
<p>메모리가 부족하기 때문이다. 한정된 서버 자원에 여러 어플리케이션을 띄운다던가
<br />
static같은 정적 메모리를 남발하여 지워지지 않고 계속 쌓일경우 이다.</p>

<h2 id="어떻게-찾을까">어떻게 찾을까?</h2>
<ol>
  <li>JVM이 oom 에러로 정지된걸 확인</li>
  <li>정지된 JVM 메모리영역을 확인했더니 특정 영역이 Full로 가득차있고, GC후 메모리할당에 실패하는걸 확인</li>
  <li>코드레벨 (대게 싱글톤이나 static 잘못사용)</li>
  <li>쓰레드생성이나 JNI에서 oom이 일어날 경우 OS의 자원소진일 수 있다. 이경우 외부자원을 조심스럽게 쓰던지 외부자원량을 늘림</li>
  <li>외부 라이브러리가 많을 경우 문제해결이 쉽지않다. JVM옵션과 tool의 도움을 받자</li>
  <li>옵션 추가
    <ul>
      <li>JVM 시작시 -verbose:gc옵션을 추가 - 가비지콜렉션 로그를 자세히 볼수있음</li>
      <li>JVM 시작시에 -XX:+HeapDumpOnOutOfMemoryError 추가 - JVM 정지시에 힙덤프를 받아놓을수 있음</li>
      <li>JVM 시작시에  –verbose:class옵션을 추가 - 클래스 로드, 언로드 상황을 볼수 있음</li>
    </ul>
  </li>
  <li>힙덤프 내역을 분석</li>
</ol>

<h2 id="함수형">함수형</h2>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="lombok" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">이펙티브 자바 - 객체 생성과 파괴</title><link href="http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/" rel="alternate" type="text/html" title="이펙티브 자바 - 객체 생성과 파괴" /><published>2022-11-30T00:00:00+09:00</published><updated>2022-11-30T00:00:00+09:00</updated><id>http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94</id><content type="html" xml:base="http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="정적-팩토리-메소드">정적 팩토리 메소드</h1>
<p><br />
<strong><em>생성자 대신 정적 팩토리 메서드를 고려하라</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정적 팩토리 메소드 ex</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">of</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자 이다.
<br />
하지만 클래스는 public 생성자와 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다.
<br /></p>

<h2 id="장점">장점</h2>
<h3 id="1-이름을-가질-수-있다">1. 이름을 가질 수 있다.</h3>

<p>생성자에 넘기는 매개변수와 생성자 만으로는 반환될 객체의 특성을 제대로 파악하기 힘들다.
<br />
그러나 정적 팩터리는 네이밍이 가능함으로 반환될 객체의 특성을 쉽게 파악할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">brand</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">String</span> <span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">brand</span> <span class="o">=</span> <span class="n">brand</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Car</span> <span class="nf">brandFrom</span><span class="o">(</span><span class="nc">String</span> <span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Car</span><span class="o">(</span><span class="n">brand</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-호출될-때마다-인스턴스를-새로-생성하지-않을-수-있다">2. 호출될 때마다 인스턴스를 새로 생성하지 않을 수 있다.</h3>
<p>불변클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 
<br />
불필요한 객체 생성을 피할 수 있다.
<br />
enum과 같이 자주 사용되는 요소의 개수가 정해져있다면 해당 개수만큼 미리 생성해놓고 
<br />
조회(캐싱)할 수 있는 구조로 만들수 있다.
<br />
정적 팩터리 메서드와 캐싱구조를 함께 사용하면 매번 새로운 객체를 생성할 필요가 없어진다.
<br />
즉, 객체 생성 비용이 큰 객체가 자주 생성된다면 성능상 이점을 볼 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumberCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">MIN_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">MAX_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lottoNumberCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LottoNumber</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">LottoNumber</span> <span class="nf">from</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lottoNumberCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-하위-객체를-반환할-수-있다">3. 하위 객체를 반환할 수 있다.</h3>
<p>상속을 사용할 때 확인할 수 있다.
<br />
클라이언트에게 구현체를 노출하지 않고 반환할 수 있고 결국 API의 개념적 무게가 가벼워 진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Grade</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">score</span> <span class="o">&lt;</span> <span class="mi">70</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Fail</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Pass</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Fail</span> <span class="kd">extends</span> <span class="nc">Grade</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Pass</span> <span class="kd">extends</span> <span class="nc">Grade</span> <span class="o">{}</span>
</code></pre></div></div>

<h2 id="단점">단점</h2>
<h3 id="1-상속문제">1. 상속문제</h3>
<p>인스턴스 통제 클래스를 구현하기 위해서는 new 키워드를 사용하여 임의로 객체를 생성함을 막아야한다. 
<br />
이를 위해 생성자의 접근 제어자를 private 로 설정해야하는데, 생성자가 private 인 클래스는 상속을 할 수 없다. 
<br />
즉, 부모 클래스가 될 수 없다.
<br />
이 제약은 컴포지션을 사용하도록 유도하고 불변타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로
받아들여 진다는데, 
<br />
이해가 가지 않는다. 이펙티브 자바를 조금더 공부해 보자</p>

<h3 id="2-정적-팩터리-메서드는-프로그래머가-찾기-어렵다">2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.</h3>

<h2 id="네이밍-컨벤션">네이밍 컨벤션</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">from</code> : 하나의 매개 변수를 받아서 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">of</code> : 여러개의 매개 변수를 받아서 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">getInstance</code> &amp; <code class="language-plaintext highlighter-rouge">instance</code> : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">newInstance</code> &amp; <code class="language-plaintext highlighter-rouge">create</code> : 새로운 인스턴스를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">get[OtherType]</code> : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">new[OtherType]</code> : 다른 타입의 새로운 인스턴스를 생성.</li>
</ul>]]></content><author><name>NNIIE</name></author><category term="Effective_Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">22.11</title><link href="http://localhost:4000/til/TIL/" rel="alternate" type="text/html" title="22.11" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/til/TIL</id><content type="html" xml:base="http://localhost:4000/til/TIL/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="equals--hashcode">equals &amp; hashcode</h1>
<p>Object 클래스의 메소드이다.
<br />
모든 클래스가 Object를 상속받기 때문에
<br />
어떤 객체라도 Object의 메소드인 equals와 hashcode를 사용할 수 있다.
<br /></p>

<h2 id="equals">equals</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Object의 equals()</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>equals()는 오로지 참조값(객체의 주소값)이 같은지 즉, 동일 객체인지 확인하는 기능이다.
<br />
equals 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 반환한다.
<br />
논리적으로 동등하다는 것은 둘의 참조값이 다르더라도 객체 내부의 value는 같다는걸 의미한다.
<br /></p>
<ul>
  <li><strong><em>동일성</em></strong> : ==비교. 객체 인스턴스 주소 값을 비교</li>
  <li><strong><em>동등성</em></strong> : equals() 메소드를 사용해 객체 내부의 값을 비교한다.</li>
</ul>

<h2 id="hashcode">hashcode</h2>
<p>객체 해시코드란 객체를 식별하는 하나의 정수값을 말한다. 
<br />
Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다.
<br /><br />
<strong><em>hashcode 를 재정의 하지 않으면</em></strong></p>
<ul>
  <li>같은 값을 가진 객체가 서로 다른 해시값을 갖게 될 수 있다.</li>
  <li>특히 HashMap의 key 값으로 해당 객체를 사용할 경우 문제가 발생한다.</li>
</ul>

<h3 id="hashtable">HashTable</h3>
<p>HashTable은 &lt;key,value&gt; 형태로 데이터를 저장한다. 이 때 해시 함수(Hash Function)을 이용하여 key값을 기준으로 고유한 식별값인 해시값을 만든다. (hashcode가 해시값을 만드는 역할을 한다.) 
<br />
이 해시값을 버킷(Bucket)에 저장한다.
<br />
하지만 HashTable 크기는 한정적이기 때문에 같은 서로 다른 객체라 하더라도 같은 해시값을 갖게 될 수도 있다.
<br />
이것을 <strong>해시 충돌(Hash Collisions)</strong>이라고 한다.
<br />
이런 경우 아래와 같이 해당 버킷(Bucket)에 LinkedList 형태로 객체를 추가한다.
<br /><br />
이처럼 같은 해시값의 버킷 안에 다른 객체가 있는 경우 equals 메서드가 사용된다.
<br /><br />
HashTable에 put 메서드로 객체를 추가하는 경우
<br /></p>
<ul>
  <li>값이 같은 객체가 이미 있다면(equals()가 true) 기존 객체를 덮어쓴다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) 해당 entry를 LinkedList에 추가한다.
<br /><br /></li>
</ul>

<p>HashTable에 get 메서드로 객체를 조회하는 경우</p>

<ul>
  <li>값이 같은 객체가 있다면 (equals()가 true) 그 객체를 리턴한다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) null을 리턴한다.</li>
</ul>

<h2 id="equals-와-hashcode를-같이-재정의-하는-이유">equals() 와 hashcode()를 같이 재정의 하는 이유</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">LottoNumber</span> <span class="n">that</span> <span class="o">=</span> <span class="o">(</span><span class="nc">LottoNumber</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">(),</span> <span class="n">that</span><span class="o">.</span><span class="na">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>만약 equals()와 hashcode() 중 하나만 재정의 하면 어떻게 될까?
<br /> 
위 예에서도 봤듯이 hashcode()를 재정의 하지 않으면 같은 값 객체라도 해시값이 다를 수 있다. 따라서 HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없다.
<br />
반대로 equals()를 재정의하지 않으면 hashcode()가 만든 해시값을 이용해 객체가 저장된 버킷을 찾을 수는 있지만 해당 객체가 자신과 같은 객체인지 값을 비교할 수 없기 때문에 null을 리턴하게 된다. 
<br />
따라서 역시 원하는 객체를 찾을 수 없다.
<br />
이러한 이유로 객체의 정확한 동등 비교를 위해서는 (특히 Hash 관련 컬렉션 프레임워크를 사용할때!) Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.</p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry></feed>