<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-23T04:17:45+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">Test</title><link href="http://localhost:4000/til/Test1/" rel="alternate" type="text/html" title="Test" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/til/Test1</id><content type="html" xml:base="http://localhost:4000/til/Test1/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="테스트-피라미드">테스트 피라미드</h1>

<p><br />
<br />
<br />
<br /></p>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="테스트피라미드" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Stream</title><link href="http://localhost:4000/til/Stream1/" rel="alternate" type="text/html" title="Stream" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/til/Stream1</id><content type="html" xml:base="http://localhost:4000/til/Stream1/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="stream">Stream</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="parallel-stream">Parallel Stream</h1>

<h2 id="1">1</h2>

<h2 id="2">2</h2>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Stream" /><category term="Parallel Stream" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Spring Basic</title><link href="http://localhost:4000/til/Spring1/" rel="alternate" type="text/html" title="Spring Basic" /><published>2023-02-21T00:00:00+09:00</published><updated>2023-02-21T00:00:00+09:00</updated><id>http://localhost:4000/til/Spring1</id><content type="html" xml:base="http://localhost:4000/til/Spring1/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="ioc-컨테이너">IoC 컨테이너</h1>
<p><strong>IoC(제어의 역전)</strong> - 객체간의 결합도를 줄이기 위한 디자인 패턴중의 하나이다.
<br />
<br />
IoC 컨테이너는 객체들의 생명주기와 객체간의 의존성을 관리한다.
<br />
IoC 컨테이너는 <strong>BeanFactory</strong> 인터페이스를 구현한 <strong>ApplicationContext</strong> 를 통해 사용된다.
<br />
<strong>ApplicationContext</strong> 는 <strong>빈</strong> 이라고 불리는 객체들의 라이프사이클, 빈 간의 의존성 등을 
<br />
관리하며 필요한 시점에 빈을 제공해준다.
<br />
<br />
<strong>한마디로 객체의 생성과 관리를 전적으로 스프링 프레임워크에 맡기는 것이다.</strong></p>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>객체들 간의 결합도를 낮출수 있다.
    <ul>
      <li>유지보수성, 확장성 향상</li>
    </ul>
  </li>
  <li>겍체간의 의존성을 쉽게 변경할 수 있어 테스트에 용이하다.</li>
  <li>객체들의 라이프사이클을 맡기고 비즈니스 로직에 집중할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>스프링 프레임워크에 대한 러닝커브</li>
  <li>직접 객체의 라이프사이클을 관리할 수 없다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="bean">Bean</h1>
<p>IoC 컨테이너에 의해 생성되고 관리되는 객체를 의미한다. 일반적으로 스프링의 모든 객체를 의미한다.
<br />
<strong>XML, 어노테이션, Configuration</strong> 파일등을 통해 정의되고 
<br />
<strong>ApplicationContext</strong> 에 의해 생성되고 빈 간의 의존성을 처리한다.
<br />
기본적으로 싱글톤 스코프를 가지고 다음과 같은 다양한 스코프를 지원한다.</p>
<ul>
  <li><strong>Singleton</strong> : 하나의 Bean 인스턴스만 생성되며, 모든 요청에 대해 같은 인스턴스가 반환</li>
  <li><strong>Prototype</strong> : 요청마다 새로운 Bean 인스턴스가 생성</li>
  <li><strong>Request</strong> : 각 HTTP 요청마다 새로운 Bean 인스턴스가 생성</li>
  <li><strong>Session</strong> : 각 세션마다 새로운 Bean 인스턴스가 생성</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="di">DI</h1>
<p>IoC 컨테이너가 제공하는 DI 기능으로 객체간의 의존성을 설정하고 관리할 수 있다.
<br />
예를들어, A객체가 B객체를 사용할 경우, A가 B객체를 생성하고 관리하는게 아니라
<br />
IoC 컨테이너가 B객체를 생성하고, A객체가 B객체를 사용할 수 있도록 주입해준다.
<br />
즉, 개발자 직접 처리하는게 아닌 IoC 컨테이너가 자동으로 처리한다.</p>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>어플리케이션에서 발생하는 객체간의 결합도를 줄일 수 있다.
    <ul>
      <li>이를 통해 유지보수, 확장성을 향상시킬 수 있다.</li>
    </ul>
  </li>
  <li>의존성을 주입할 때 인터페이스를 사용해서 <strong>의존성 역전 원칙</strong> 을 지킬 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>스프링 프레임워크에 대한 러닝커브</li>
  <li>잘못 구현할 경우 객체간의 의존성이 너무 복잡해 질 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="aop">AOP</h1>
<p>다양한 관점으로 코드를 모듈화 하고 관심사를 분리하는 것이다.
<br />
예를들어, 비즈니스 로직에서 반복적으로 사용되는 공통 기능 (로깅, 트랜잭션, 보안 등) 을
<br />
별도의 모듈로 분리하여 관리하고 적용할 수 있다.
<br />
<strong>즉, 로직과 관련없는 부가적인 관심을 코드에서 분리하여 모듈화 하는 기법이다.</strong>
<br />
<br />
다음과 같은 주요 구성요소로 구성된다.</p>

<ul>
  <li><strong>Aspect</strong>
    <ul>
      <li>특정 관심사를 처리하는 모듈 (모듈화된 로직)</li>
      <li>보통 공통으로 적용되는 부가 기능 (로깅, 트랜잭션 처리 등)을 담당한다.</li>
    </ul>
  </li>
  <li><strong>Join point</strong>
    <ul>
      <li>언제나 관심사가 적용될 수 있는 코드 지점 (메서드 호출 등)</li>
    </ul>
  </li>
  <li><strong>Advice</strong>
    <ul>
      <li><strong>Aspect</strong> 가 <strong>Join point</strong> 에 적용하는 실제 로직(코드)</li>
      <li>Before, After, Around 등의 <strong>Advice유형</strong> 이 있다.</li>
    </ul>
  </li>
  <li><strong>Pointcut</strong>
    <ul>
      <li><strong>Join point</strong> 중에서 <strong>Aspect</strong> 가 적용되는 대상(메서드, 클래스 등)을 지정하는 패턴</li>
    </ul>
  </li>
  <li><strong>Weaving</strong>
    <ul>
      <li><strong>Aspect</strong> 를 대상 코드에 적용하는 과정</li>
      <li>스프링에서는 컴파일 타임, 로드 타임, 런타임에 모두 <strong>Weaving</strong> 이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>비즈니스 로직과 부가기능의 분리
    <ul>
      <li>가독성, 유지보수성 향상</li>
    </ul>
  </li>
  <li>중복되는 부가기능을 한곳에서 관리할 수 있어 중복을 제거할 수 있다.</li>
  <li>부가기능이 추가 / 변경 될때, 비즈니스 로직을 수정할 필요가 없다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>복잡성이 증가할 수 있다.</li>
  <li>러닝커브</li>
  <li>프록시 기반으로 동작하기 때문에 다양한 기능 (final/private 메서드 등) 이 제한될 수 있다.
    <ul>
      <li>AspectJ 등의 다른 AOP 프레임워크 사용으로 해결 가능</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="psa">PSA</h1>
<p>여러개의 서비스 구현체를 추상화 하여 사용할 수 있도록 일관된 인터페이스를 제공하는 기법이다.
<br />
스프링에서는 <strong>JDBC, JMS, 캐시, 메일 등</strong> 의 서비스에 대해 <strong>PSA</strong> 를 적용하고 있다.
<br />
예를들어, <strong>JdbcTemplate</strong> 은 <strong>JDBC</strong> 서비스에 대한 <strong>PSA</strong> 를 제공하며 클라이언트 코드에서 
<br />
<strong>서비스 구현체를 직접 참조하지 않고, 일관된 방법으로 서비스를 사용할 수 있게 된다.</strong>
<br />
<strong>또한 서비스 구현체를 변경하더라도, 클라이언트 코드가 변경되지 않도록 해주는 역할을 한다.</strong></p>

<ul>
  <li><strong>인터페이스 추상화</strong>
    <ul>
      <li>서비스를 추상화 하기 위해 인터페이스를 사용</li>
      <li>인터페이스는 일반적으로 서비스의 기능을 제공하는 메서드로 구성</li>
      <li><strong>인터페이스 추상화</strong> 는 서비스 구현체를 추상화 하는데 사용</li>
      <li>클라이언트는 인터페이스를 사용하여 서비스를 호출한다.</li>
    </ul>
  </li>
  <li><strong>팩토리 추상화</strong>
    <ul>
      <li>서비스 구현체를 생성하고 제공하기 위한 일관된 방법을 제공하는 추상화</li>
      <li><strong>팩토리 추상화</strong> 는 서비스 구현체를 생성하고 관리하는 데 사용</li>
      <li>클라이언트는 팩토리를 사용하여 서비스 구현체를 얻을 수 있다.</li>
    </ul>
  </li>
  <li><strong>예외 추상화</strong>
    <ul>
      <li>서비스에서 발생하는 예외를 일관된 방식으로 처리하기 위한 추상화</li>
      <li><strong>예외 추상화</strong> 는 서비스에서 발생하는 예외를 처리하기 위한 일관된 방법을 제공하는 데 사용</li>
      <li>클라이언트는 예외 추상화를 사용하여 서비스에서 발생하는 예외를 처리할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>클라이언트는 서비스 구현체를 직접 참조하지 않고, 일관된 방식으로 서비스를 호출할 수 있다.</li>
  <li>클라이언트 코드에서 서비스 구현체를 직접적으로 참조하지 않기 때문에, 서비스 구현체가 변경되더라도 클라이언트 코드를 수정할 필요가 없다.</li>
  <li>다양한 기술과 프레임워크에서 동일한 인터페이스를 사용하여 서비스를 호출할 수 있도록 한다.</li>
  <li><strong>인터페이스 추상화</strong> 와 <strong>팩토리 추상화</strong> 를 통해 서비스를 모듈화할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>인터페이스 추상화와 팩토리 추상화 등을 정의해야 하기 때문에 코드의 양과 복잡성이 증가할 수 있다.</li>
  <li>특정한 프레임워크에서만 적용될 수 있기 때문에, 표준화가 되어 있지 않은 경우에는 다른 프레임워크나 라이브러리에서는 적용할 수 없다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="IoC컨테이너" /><category term="Bean" /><category term="DI" /><category term="AOP" /><category term="PSA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Design Pattern</title><link href="http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41/" rel="alternate" type="text/html" title="Design Pattern" /><published>2023-02-16T00:00:00+09:00</published><updated>2023-02-16T00:00:00+09:00</updated><id>http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41</id><content type="html" xml:base="http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="디자인패턴">디자인패턴</h1>
<p>일종의 설계 템플릿으로, 구체적인 구현방법을 제시하는것이 아니라 어떤 문제에 대해
<br />
어떤 구조와 접근법이 적절한지에 대한 <strong>가이드라인</strong>이다.
<br />
소프트웨어가 점점 복잡해지면서 다양한 문제가 발생하게 되었고, 이런 문제를 해결하기 위해
<br />
많은 개발자들이 각자의 방식으로 접근하다보니 비슷한 문제를 다른방식으로 해결하는 경우가 많았다.
<br />
결국 유지보수 등의 어려움을 겪게되고, 이러한 문제를 해결하기 위해 많은 개발자들의 전문지식을 모아
<br />
이미 검증된 방식을 <strong>템플릿 형태</strong>로 모아 <strong>가이드라인</strong>을 제시하게 되었다. 
<br />
이로써, 소프트웨어의 유연성, 확장성, 생산성, 픔질 향상에 큰 도움이 된다.</p>

<p><br />
<br />
<br />
<br /></p>

<h2 id="어댑터-패턴">어댑터 패턴</h2>
<p><strong>Adapter Pattern</strong>
<br />
호환되지 않는 여러 객체를 하나의 <strong>인터페이스</strong> 로 묶어서 사용할 수 있는 디자인 패턴이다.
<br />
이를통해, 재사용성, 유지보수성 을 향상시킬 수 있다.</p>

<p><br /></p>

<p><strong><em>인터페이스가 호환되지 않는 클래스들을 함께 사용하기 위해 사용한다.</em></strong></p>
<ul>
  <li>기존 코드나 라이브러리를 재사용하면서 새로운 시스템을 구축할 때</li>
  <li>호환성없는 두 클래스를 연결해 사용해야 할때</li>
  <li>인터페이스나 메소드가 다른 두 클래스 사이에서 호환성 문제를 해결해야 할 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>기존코드의 수정없이 호환되지 않는 객체를 연결할 수 있다.</li>
  <li>객체간의 결합도를 줄일 수 있다.</li>
  <li>호환성이 없는 여러 객체를 하나의 어댑터로 묶어서 사용할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>객체가 추가될 때 마다 어댑터 클래스가 늘어난다.</li>
  <li>어댑터가 객체를 감싸는 구조를 가지기 때문에 어댑터로 연결된 객체는 성능상 손실이 있을 수 있다.</li>
  <li>코드가 복잡해진다.</li>
</ul>

<p><br /></p>

<h3 id="구현">구현</h3>

<hr />

<p><strong>일반적인 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Generic animal sound"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Wolf 클래스는 Animal 클래스와 호환되지 않는 인터페이스를 가지고 있다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wolf</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">howl</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Howl"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
WolfAdapter 클래스는 Animal 클래스를 상속받고, makeSound() 메서드를 오버라이드 해서 
Wolf 클래스의 howl() 메서드를 호출하도록 구현한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WolfAdapter</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Wolf</span> <span class="n">wolf</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">WolfAdapter</span><span class="o">(</span><span class="nc">Wolf</span> <span class="n">wolf</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wolf</span> <span class="o">=</span> <span class="n">wolf</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">wolf</span><span class="o">.</span><span class="na">howl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 어댑터패턴으로 호환되지 않는 인터페이스를 연결하면 기존 코드를 수정하지 않아도 다른 객체와 같이 동작할 수 있게 된다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdapterExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// "Generic animal sound" 출력</span>
        
        <span class="nc">Wolf</span> <span class="n">wolf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Wolf</span><span class="o">();</span>
        <span class="nc">WolfAdapter</span> <span class="n">adapter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WolfAdapter</span><span class="o">(</span><span class="n">wolf</span><span class="o">);</span>
        <span class="n">adapter</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// "Howl" 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>JDBC API에 사용된 어댑터 패턴</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
Class.forName() 메서드로 Driver 클래스를 로드한다. 이 클래스는 MySQL 제조사가 제공하는 드라이버이다.
그런다음 DriverManager.getConnection() 메서드를 사용하여 데이터베이스와 연결한다. 
이 메서드는 실제로 Driver 인터페이스를 구현한 객체를 생성하여 Connection 인터페이스와 연결한다.
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// JDBC 드라이버 로드</span>
    <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">);</span>
    
    <span class="c1">// 데이터베이스 연결</span>
    <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost/test"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">user</span> <span class="o">=</span> <span class="s">"user"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>
    <span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/*
JDBC 는 데이터베이스와 연결하기 위해 인터페이스를 제공한다. 데이테베이스 제조사마다 제공하는
드라이버의 인터페이스가 다르기 떄문에 DriverManager클래스에 어댑터 패턴을 사용한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DriverManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">(</span><span class="nc">String</span> <span class="n">url</span><span class="o">,</span> <span class="nc">String</span> <span class="n">user</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 데이터베이스 제조사가 제공하는 드라이버를 찾아서 Driver 인터페이스를 구현한 객체를 생성</span>
        <span class="nc">Driver</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">findDriver</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
        <span class="c1">// Driver 인터페이스를 구현</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="프록시-패턴">프록시 패턴</h2>
<p><strong>Proxy Pattern</strong>
<br />
Proxy 를 사용하여 객체에 대한 접근을 제어하고 간접적으로 제어하는 디자인 패턴이다.
<br />
객체에 대한 직접적인 접근을 대신해 <strong>Proxy 객체</strong> 를 사용해 객체에 접근을 하고 <strong>Proxy 객체</strong> 는
<br />
실제 객체를 대신해 객체의 <strong>대리자 역할</strong> 을 수행하며 객체와 동일한 인터페이스를 제공한다
<br />
Proxy 객체는 실제 객체의 인터페이스를 구현하며, 실제 객체의 메서드를 호출하기전 추가작업을 할 수 있다.</p>

<p><br /></p>

<p><strong><em>객체에 대한 접근을 제어하고 보안, 성능 최적화 등의 추가 기능을 제공하기 위해 사용한다.</em></strong></p>
<ul>
  <li>원격 객체에 대한 접근을 제어하고 네트워크 부하를 줄이기 위해</li>
  <li>복잡한 객체에 대한 접근을 제어하고 메모리 사용량을 줄이기 위해</li>
  <li>객체에 대한 보안적인 제한 및 부가적인 기능을 제공하기 위해</li>
</ul>

<p><br /></p>

<h3 id="trade-off-1">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>객체 생성과 초기화를 지연시킬 수 있어, 성능을 개선할 수 있다.
    <ul>
      <li>원본객체의 생성 또는 초기화에 많은 비용이 들어갈 경우 유용하다.</li>
      <li>실제객체가 원격서버에 있는경우, 프록시객체로 서버접근에 대한 리소스를 줄일 수 있다.</li>
      <li>프록시객체는 원본객체의 인스턴스를 생성하지 않고, 요청이 들어올 경우 생성하고 요청을 처리한다.</li>
    </ul>
  </li>
  <li>실제객체에 대한 접근을 제어할 수 있어, 보안성을 높일 수 있다.
    <ul>
      <li>원본객체가 보안성이 중요할 경우 유용하다.</li>
    </ul>
  </li>
  <li>객체의 메서드의 실행 전후로 추가적인 작업을 수행할 수 있어 유연성이 증가한다.
    <ul>
      <li>이를 통해 로깅, 캐싱, 트랜잭션 등 다양한 처리가 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>프록시 객체는 실제객체에 접근하기 위해 추가적인 리소스가 들어가므로 성능이 저하될 수 있다.</li>
  <li>프록시 객체라는 추가적은 클래스가 필요하고, 이는 복잡성이 증가하고 유지보수를 어렵게 할 수 있다.</li>
  <li>중간에 다른 객체가 끼어있기 때문에 디버깅이 어려워질 수 있어 추가적인 로깅이나 디버깅 작업이 필요하다.</li>
  <li>프록시객체가 실제객체를 대신하기 때문에 실제객체가 생성되지 않아 에상하지 못한 문제가 발생할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="구현-1">구현</h3>

<hr />

<p><strong>정적 프록시 방식</strong>
<br />
프록시 객체를 컴파일 시점에 미리 생성하는 방식</p>
<ul>
  <li>컴파일 시점에 생성되므로 런타임에 추가적인 비용이 발생하지 않는다.</li>
  <li>인터페이스를 구현하는 클래스만 프록시 객체를 생성할 수 있다.</li>
  <li>프록시객체를 수정하려면 컴파일을 다시 해야한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Animal is eating"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
프록시 객체가 구현할 AnimalInterface 인터페이스를 구현한다.
AnimalProxy 클래스는 AnimalInterface 인터페이스를 구현한다.
생성자를 통해 실제 객체를 전달받고, eat() 메서드에서 실제 객체의 eat() 메서드를 호출하기 전에 
수행할 작업과 호출한 후에 수행할 작업을 정의한다.
마지막으로 클라이언트에서 프록시 객체를 생성하고 사용한다.
이를 통해 클라이언트는 실제 객체를 알 필요가 없고, 프록시 객체를 이용해 추가적인 작업을 수행할 수 있다.
*/</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalProxy</span> <span class="kd">implements</span> <span class="nc">AnimalInterface</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalProxy</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before eating"</span><span class="o">);</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After eating"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 클라이언트</span>
<span class="nc">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span>
<span class="nc">AnimalInterface</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnimalProxy</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
<span class="n">proxy</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><strong>동적 프록시 방식</strong>
<br />
프록시 객체를 런타임에 동적으로 생성하는 방식
<br />
일반적으로 유연성이 높고 프록시 객체를 동적으로 수정할 수 있어 더 많이 사용된다.</p>
<ul>
  <li>인터페이스를 구현하지 않은 클래스도 프록시 객체를 생성할 수 있다.</li>
  <li>프록시 객체를 동적으로 수정할 수 있다.</li>
  <li>더 다양한 기능을 수행할 수 있어 AOP 같은 패러다임에 사용하기 적합하다.</li>
  <li>런타임에 프록시객체를 생성하므로, 정적프록시 방식에 비해 성능이 떨어질 수 있다.</li>
  <li>컴파일 시점에 프록시객체를 알수 없어서 디버깅이 어려울 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog is eating."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
AnimalInvocationHandler 클래스는 InvocationHandler 인터페이스를 구현하여 invoke() 메서드를 재정의 한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalInvocationHandler</span> <span class="kd">implements</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalInvocationHandler</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 이 메서드는 실제 객체의 메서드를 호출하기 전후의 실행시간을 출력한다.</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">animal</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Execution time: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ns"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
Dog 객체를 생성한 후 Proxy.newProxyInstance 메서드를 사용해 Animal 인터페이스를 구현하는 동적 프록시 객체를 생성한다.
이때, AnimalInvocationHandler 클래스를 InvocationHandler로 사용한다. 
마지막으로, 프록시 객체의 eat() 메서드를 호출하여 AOP가 적용된 결과를 출력한다.
*/</span>
<span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
<span class="nc">Animal</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Animal</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
    <span class="nc">Animal</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span>
    <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Animal</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span>
    <span class="k">new</span> <span class="nf">AnimalInvocationHandler</span><span class="o">(</span><span class="n">dog</span><span class="o">)</span>
<span class="o">);</span>
<span class="n">proxy</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="데코레이터-패턴">데코레이터 패턴</h2>
<p><strong>Decorator Pattern</strong>
<br />
객체의 기능을 동적으로 추가 / 변경 할 수 있도록 해주는 디자인 패턴이다.
<br />
객체를 래핑하고, 래핑된 객체에 새로운 기능을 추가해 새로운 객체를 생성하는 방식으로 동작한다.
<br />
이렇게 생성된 객체는 래핑된 객체의 기능을 그대로 사용하면서 새로운 기능을 추가한 객체가 된다.
<br />
이를통해, 확장성, 유연성이 높아지고 객체 간의 결합도가 낮아지게 된다.</p>

<p><br /></p>

<p><strong><em>객체를 수정하지 않고 기능을 동적으로 확장하기 위해 사용한다.</em></strong></p>
<ul>
  <li>객체에 대해 동적으로 새로운 기능을 추가하거나 기존 기능을 변경할 필요가 있을 때</li>
  <li>상속으로 인한 클래스의 확장이 어려운 경우에 확장이 필요한 기능을 데코레이터 클래스로 추가할 때</li>
  <li>객체의 수정 없이 기능을 추가하고 싶을 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off-2">trade-off</h3>

<hr />
<p><strong>장점</strong></p>
<ul>
  <li>객체의 기능을 동적으로 추가 / 변경 할 수 있어서 기존 코드를 변경하지 않고 기능을 추가할 수 있다.
    <ul>
      <li>데코레이터 패턴은 <strong>OCP원칙</strong> 을 준수한다.</li>
    </ul>
  </li>
  <li>객체간의 결합도가 낮다.</li>
  <li>객체를 책임별로 분리하기 용이하고 여러개의 데코레이터를 조합해 다양한 기능을 구현할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>새로운 데코레이터 클래스를 만들어야 하기 때문에 클래스가 늘어난다.</li>
  <li>런타임에 객체를 생성하기 때문에 아주 약간의 오버헤드가 발생한다.</li>
  <li>초기 설계에 리소스가 든다.</li>
</ul>

<p><br /></p>

<h3 id="구현-2">구현</h3>

<hr />

<p><strong>인터페이스를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal을 데코레이팅하는 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalDecorator</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">decorate</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// AnimalDecorator를 구현한 구현 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogWithHat</span> <span class="kd">implements</span> <span class="nc">AnimalDecorator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">DogWithHat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decorate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모자를 쓴 강아지"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 기존의 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog1</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>

        <span class="c1">// 모자를 쓴 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="n">dog2</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>추상클래스를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 구현클래스</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal을 데코레이팅하는 데코레이터 추상 클래스</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AnimalDecorator</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalDecorator</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalDecorator를 구현한 Hat 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hat</span> <span class="kd">extends</span> <span class="nc">AnimalDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Hat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모자를 쓴 강아지"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 기존의 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog1</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>

        <span class="c1">// 모자를 쓴 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="n">dog2</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>람다를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"멍멍"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Hat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">decorate</span><span class="o">;</span>  <span class="c1">// 함수형 인터페이스 사용</span>

    <span class="kd">public</span> <span class="nf">Hat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
        <span class="n">decorate</span> <span class="o">=</span> <span class="o">(</span><span class="n">sound</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">sound</span> <span class="o">+</span> <span class="s">", 모자쓴 강아지"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">decorate</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span> <span class="c1">// "멍멍"</span>

        <span class="nc">Animal</span> <span class="n">dogWithHat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dogWithHat</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span> <span class="c1">// "멍멍, 모자쓴 강아지"</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="싱글톤-패턴">싱글톤 패턴</h2>
<p><strong>Singleton Pattern</strong>
<br />
어떤 클래스의 인스턴스가 오직 한 개만 존재하도록 보장하고, 전역적인 접근점을 제공하는 디자인 패턴이다.</p>

<p><br /></p>

<p><strong><em>애플리케이션에서 단 하나의 인스턴스만을 생성하고 이에 대한 전역적인 접근을 제공하기 위해 사용한다.</em></strong></p>
<ul>
  <li>자원의 공유가 필요한 경우에 여러 객체를 생성하는 것이 비효율적인 경우</li>
  <li>상태를 유지해야 하는 로깅이나 캐싱 등의 객체가 필요한 경우</li>
  <li>불필요한 객체 생성을 방지하고 메모리 사용량을 줄이기 위해 객체를 관리할 필요가 있는 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-3">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>인스턴스를 오직 하나만 생성하기 때문에, 메모리 사용량이 줄어든다.</li>
  <li>유일한 인스턴스에 대한 접근점이 하나뿐이기 때문에, 인스턴스를 다른 클래스에서 변경할 수 없다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>멀티스레드 환경에서 동시성 문제가 발생할 수 있다.
    <ul>
      <li>동기화 처리가 필요하기 때문에 성능저하를 가져올 수 있다.</li>
    </ul>
  </li>
  <li><strong>OCP원칙</strong> 을 위반한다.
    <ul>
      <li>싱글톤객체를 사용하는 객체가 다른 객체에 의존할 경우, 변경 시 싱글톤객체도 같이 변경해야 할 수 있다.</li>
    </ul>
  </li>
  <li>전역적으로 사용할 수 있기 때문에 다른 객체들과의 결합도가 높아질 수 있다.
    <ul>
      <li><strong>Dependency Injection</strong> 사용으로 해결할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="구현-3">구현</h3>

<hr />

<p><strong>Eager Initialization 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 클래스가 로딩될 때, 인스턴스를 미리 생성하는 방식, thread safe 하지 않다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>Lazy Initialization 방식</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Double-Checked Locking</span>
<span class="c1">// 인스턴스가 필요한 시점에 생성하는 방식, thread safe 하다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>스프링 프레임워크 방식</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
스프링에서는 빈(Bean)이라는 개념을 사용하며, 이 빈들은 스프링 컨테이너에서 생성되고 관리된다. 
이때, 스프링 컨테이너는 기본적으로 싱글톤 패턴을 적용하므로, 모든 빈들은 기본적으로 싱글톤으로 생성된다.
thread safe 하다.
*/</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyComponent</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="템플릿-메서드-패턴">템플릿 메서드 패턴</h2>
<p><strong>Template Method Pattern</strong>
<br />
상위 클래스에서 공통적인 로직을 구현하고 하위클래스에서 구체적으로 구현하기 위한 디자인 패턴이다.
<br />
추상클래스를 사용하는데, 공통로직을 구현하는 템플릿 메서드를 정의하고 하위클래스에선 이 템플릿 메서드를
<br />
상속받아 구체적인 구현을 한다. 상위클래스에서는 추상메서드를 선언해 하위클래스에서 구현을 강제할 수 있다.</p>

<p><br /></p>

<p><strong><em>상위클래스에서 공통부분을 정의하고 하위클래스에서 그 일부를 구체적으로 구현하기 위해 사용한다.</em></strong></p>
<ul>
  <li>일련의 공통작업이 있지만, 그 중 일부는 하위클래스에서 구현해야 하는 경우
    <ul>
      <li>다양한 구현 방법을 지원하면서 일관성을 유지해야 하는 경우</li>
    </ul>
  </li>
  <li>복잡한 알고리즘을 캡슐화하여 코드의 가독성을 높이고 유지보수를 용이하게 하는 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-4">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>중복코드를 줄일 수 있다.
    <ul>
      <li>공통으로 사용되어야 하는 로직이 있을경우, 추상클래스로 정의하여 한곳에서 관리할 수 있다.</li>
    </ul>
  </li>
  <li>일관성을 유지할 수 있다.
    <ul>
      <li>추상클래스에서 공통로직을 정의하므로, 여러 하위클래스에서 일관성있는 코드를 유지할 수 있다.</li>
    </ul>
  </li>
  <li>추상 클래스에서 정의한걸 상속받아 하위 클래스에서 구현하므로, 유연한 확장성을 가진다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>추상클래스와 구체클래스 간의 결합도가 높다.</li>
  <li>상 클래스가 변경될 경우 하위 클래스들도 함께 수정해야 한다.</li>
  <li>상속을 사용하기 때문에 하위 클래스의 개수가 많아질 경우 클래스의 수가 증가할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="구현-4">구현</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 추상클래스로 play() 메서드에서 공통로직을 정의하고, makeSound(), move() 의 구현을 강제한다.</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">makeSound</span><span class="o">();</span>
        <span class="n">move</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 클래스를 상속받은 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Running!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal 클래스를 상속받은 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Meow!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Jumping!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>

        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cat</span><span class="o">();</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="팩토리-메서드-패턴">팩토리 메서드 패턴</h2>
<p><strong>Factory Method Pattern</strong>
<br />
객체 생성 코드를 클라이언트에서 분리시켜 객체 생성을 캡슐화하는 디자인 패턴이다.
<br />
객체 생성의 책임을 서브클래스에 위임하여 서브클래스가 어떤 클래스의 인스턴스를 만들지 결정하게 한다. 
<br />
이렇게 함으로써 코드를 수정하지 않고도 객체의 타입을 바꿀 수 있는 유연성을 제공한다.
<br /></p>

<p><br /></p>

<p><strong><em>객체 생성을 서브클래스에서 처리하도록 하여 객체 생성 과정을 유연하게 관리하기 위해 사용한다.</em></strong></p>
<ul>
  <li>객체 생성에 필요한 정보가 런타임 시에 결정되는 경우</li>
  <li>객체 생성 방법을 변경해야 할 때 전체 코드를 수정하지 않고 유지보수성을 높이고 싶을 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off-5">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>객체생성 코드를 캡슐화 할 수 있다.</li>
  <li>객체생성 코드를 중앙화 하여 한곳에서 관리해 가독성을 높일 수 있다.</li>
  <li>서브클래스를 추가하거나 수정해 객채생성에 대한 확장성이 높아진다.</li>
  <li>다형성을 활용한 디자인 패턴이다.
    <ul>
      <li>클라이언트 코드가 객체의 타입이 아닌 인터페이스를 통해 객체에 접근할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>서브클래스를 추가해야 하므로 클래스 수가 증가한다.</li>
  <li>추상화 수준이 높아지기 때문에 가독성이 떨어진다.</li>
</ul>

<p><br /></p>

<h3 id="구현-5">구현</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Animal 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getAnimalName</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 인터페이스를 구현하는 Dog 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAnimalName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Dog"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal 인터페이스를 구현하는 Cat 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAnimalName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Cat"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalFactory 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalFactory</span> <span class="o">{</span>
    <span class="nc">Animal</span> <span class="nf">createAnimal</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// AnimalFactory 인터페이스를 구현하는 DogFactory 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogFactory</span> <span class="kd">implements</span> <span class="nc">AnimalFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Animal</span> <span class="nf">createAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Dog</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalFactory 인터페이스를 구현하는 CatFactory 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CatFactory</span> <span class="kd">implements</span> <span class="nc">AnimalFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Animal</span> <span class="nf">createAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Cat</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AnimalFactory</span> <span class="n">dogFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DogFactory</span><span class="o">();</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">dogFactory</span><span class="o">.</span><span class="na">createAnimal</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="na">getAnimalName</span><span class="o">());</span> <span class="c1">// "Dog" 출력</span>

        <span class="nc">AnimalFactory</span> <span class="n">catFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CatFactory</span><span class="o">();</span>
        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">catFactory</span><span class="o">.</span><span class="na">createAnimal</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">getAnimalName</span><span class="o">());</span> <span class="c1">// "Cat" 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="전략-패턴">전략 패턴</h2>
<p><strong>Strategy Pattern</strong>
<br />
알고리즘의 집합을 정의하고 각각을 캡슐화하여 동적으로 교체하여 사용할 수 있는 디자인 패턴</p>

<p><br /></p>

<p><strong><em>알고리즘을 캡슐화하여 동적으로 교환할 수 있도록 만들어 유연한 애플리케이션을 구현하기 위해 사용한다.</em></strong></p>
<ul>
  <li>런타임 시에 알고리즘을 선택할 필요가 있는 경우</li>
  <li>비슷한 알고리즘을 여러 개 가지고 있고, 이를 쉽게 변경하고 유지보수하고 싶은 경우</li>
  <li>알고리즘의 구현 내용을 클라이언트와 분리하여 의존성을 낮추고 싶은 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-6">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>알고리즘을 동적으로 교체할 수 있고 캡슐화 할 수 있다.</li>
  <li>전략객체를 독립적으로 변경할 수 있기 때문에 객체간 결합도가 감소한다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>인터페이스와 클래스 수가 많아진다.</li>
  <li>많은 전략을 사용할 수 있지만 이걸 모두 객체로 생성하는건 무리다.</li>
  <li>컨텍스트, 전략객체, 인터페이스 사용으로 비용이 증가할 수 있다</li>
</ul>

<p><br /></p>

<h3 id="구현-6">구현</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 전략(알고리즘)을 캡슐화한 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MoveStrategy</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">move</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 전략(알고리즘)을 구현한 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WalkStrategy</span> <span class="kd">implements</span> <span class="nc">MoveStrategy</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"걷는다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 전략(알고리즘)을 구현한 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunStrategy</span> <span class="kd">implements</span> <span class="nc">MoveStrategy</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"달린다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 컨텍스트(전략을 사용하는 클래스)</span>
<span class="c1">// 생성자를 통해 MoveStrategy 인터페이스를 구현한 객체를 받아서 실행한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">MoveStrategy</span> <span class="n">moveStrategy</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Animal</span><span class="o">(</span><span class="nc">MoveStrategy</span> <span class="n">moveStrategy</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">moveStrategy</span> <span class="o">=</span> <span class="n">moveStrategy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">moveStrategy</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal 객체를 생성할 때 원하는 전략 객체를 주입하여 원하는 동작을 실행한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="k">new</span> <span class="nc">WalkStrategy</span><span class="o">());</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>

        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunStrategy</span><span class="o">());</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="템플릿-콜백-패턴">템플릿 콜백 패턴</h2>
<p><strong>Template Callback Pattern</strong>
<br />
알고리즘의 구조를 정의하고 구체적인 단계나 구현 방법을 서브클래스에서 결정하는 방식의 디자인 패턴
<br />
자바에선 인터페이스나 추상클래스를 상위 클래스로 사용하고 하위클래스에서 구현한 메서드(콜백) 를
<br />
상위클래스에서 호출하면서, 하위클래스가 직접 실행할 수 있는 유연성을 제공한다.
<br />
<br />
<strong>템플릿 콜백 패턴은 템플릿 메서드 패턴을 확장한 개념으로, 기본적인 구조는 매우 유사하다.</strong>
<br />
<strong>다른점은, 하위클래스에서 콜백메서드를 제공하고 상위클래스에서 호출하는 방식으로 동작한다.</strong></p>

<p><br /></p>

<p><strong><em>중복 코드를 줄이고 알고리즘을 캡슐화하여 재사용성과 유지보수성을 높이기 위해 사용한다.</em></strong></p>
<ul>
  <li>알고리즘의 골격을 유지하면서 상세한 구현 부분을 변경할 수 있는 경우
    <ul>
      <li>비슷한 알고리즘에 대해 중복 코드를 줄이면서 구현을 변경하고 싶을 때</li>
    </ul>
  </li>
  <li>다양한 클라이언트 요구사항을 만족시키면서 일관성을 유지해야 하는 경우
    <ul>
      <li>여러 클라이언트 요구사항을 수용하면서 알고리즘을 유지보수 가능한 방식으로 구현하고 싶을 때</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="trade-off-7">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>상위클래스에서 정의한 알고리즘 구조를 여러 하위클래스에서 재사용 및 수정 할 수 있다.
    <ul>
      <li>콜백메서드를 추가하거나 하위클래스를 추가하여 확장성에서도 용이하다.</li>
    </ul>
  </li>
  <li><strong>다형성</strong>
    <ul>
      <li>추상메서드를 상위클래스에 선언하고 하위클래스에서 구체적으로 구현하는 방식</li>
      <li>상위클래스에선 구현에 대한 세부정보를 몰라도 되고, 콜백메서드를 호출함으로써 다형성 활용</li>
    </ul>
  </li>
  <li><strong>제어의 역전</strong>
    <ul>
      <li>상위클래스에서 하위클래스의 콜백 메서드를 호출하기 때문에 제어의 흐름이 역전된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>추상클래스 또는 인터페이스 등을 사용해야 하기 때문에 복잡해진다.</li>
  <li>알고리즘 구조를 변경하려면 상위클래스를 수정해야 한다.</li>
  <li>다수의 메서드 호출이 발생하기 때문에 약간의 오버헤드 발생</li>
</ul>

<p><br /></p>

<h3 id="구현-7">구현</h3>

<hr />

<p><strong>추상클래스를 사용한 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
performActivity() 메서드를 실행하여 알고리즘의 구조를 정의하고, 
하위 클래스에서 구현할 specificActivity() 메서드를 추상 메서드로 선언
*/</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">doActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Getting ready to do activity..."</span><span class="o">);</span>
        <span class="n">performActivity</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Activity is completed!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 하위 클래스에서 구현해야 할 콜백 메서드</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">performActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Performing activity..."</span><span class="o">);</span>
        <span class="n">specificActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 콜백 메서드인 specificActivity() 메서드를 구현</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dog is barking."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">doActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>인터페이스를 사용한 방식</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
performActivity() 메서드를 실행하여 알고리즘의 구조를 정의하고, 
하위 클래스에서 구현할 specificActivity() 메서드를 선언
*/</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">doActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Getting ready to do activity..."</span><span class="o">);</span>
        <span class="n">performActivity</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Activity is completed!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 하위 클래스에서 구현해야 할 콜백 메서드</span>
    <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">();</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">performActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Performing activity..."</span><span class="o">);</span>
        <span class="n">specificActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 콜백 메서드인 specificActivity() 메서드를 구현</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dog is barking."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">doActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="어댑터 패턴" /><category term="프록시 패턴" /><category term="데코레이터 패턴" /><category term="싱글톤 패턴" /><category term="템플릿 메서드 패턴" /><category term="팩터리 메서드 패턴" /><category term="전략 패턴" /><category term="템플릿 콜백 패턴" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">OOP</title><link href="http://localhost:4000/til/OOP/" rel="alternate" type="text/html" title="OOP" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/til/OOP</id><content type="html" xml:base="http://localhost:4000/til/OOP/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="oop">OOP</h1>
<p>어플리케이션을 구성하는 요소들을 객체로 보고, 
<br />
객체들을 유기적으로 연결하여 상호작용하는 방식으로 프로그래밍 하는걸 말한다. 
<br />
데이터와 이를 처리하는 루틴을 하나의 <strong>독립된 객체</strong> 로 보고 기능적으로 관련된 
<br />
데이터와 메서드를 묶는 것을 중심으로 한다.
<br />
재사용성, 유지보수 에 용이하고 대형 프로젝트에 적합하다.
<br />
하지만 속도가 상대적으로 느리고, 설계 시 많은 리소스가 들어간다.</p>

<p><br /></p>

<ul>
  <li><strong>객체</strong>
    <ul>
      <li>속성과 동작을 가진다.</li>
      <li>속성은 객체의 상태를 나타내고, 동작은 객체의 행동을 나타낸다.</li>
      <li>자동차 객체를 예로 들면
        <ul>
          <li>속성 : 색상, 모델, 브랜드 등</li>
          <li>동작 : 가속, 감속, 정지 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>추상화</strong>
    <ul>
      <li>목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>캡슐화</strong>
    <ul>
      <li>정보은닉 - 접근제어자</li>
      <li>코드의 의존성을 줄이고, 결합도를 낮추는 것</li>
      <li>필요한 부분만 외부에 노출시키고 나머지는 숨긴다.</li>
      <li>외부에서 불필요한 의존을 할 일이 없어지고 의존성이 줄어드는 만큼 유지보수도 편해진다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속</strong>
    <ul>
      <li>코드의 재사용성에 이점이 있지만 코드의 재사용성만을 위해 사용은 지양한다.</li>
      <li>흔히 재사용성 뿐 아니라 계층구조 같은 구조를 만들 때 사용하자</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>다형성</strong>
    <ul>
      <li>객체지향의 꽃이라고도 불린다.</li>
      <li>형태가 같지만 다른 기능을 하는 것을 말한다.</li>
      <li>하나의 타입에 여러 객체를 대입할 수 있는 성질이다.
        <ul>
          <li>업캐스팅
            <ul>
              <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 한다.</li>
            </ul>
          </li>
          <li>동적바인딩
            <ul>
              <li>메시지를 수신했을 때 실행도리 메서드가 런타임에 결정된다.</li>
            </ul>
          </li>
          <li>오버로딩</li>
          <li>오버라이딩</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop-왜쓰는데">OOP 왜쓰는데?</h2>
<ul>
  <li><strong>재사용성</strong>
<br />
<br />
클래스와 상속을 사용해 이미 작성된 코드를 쉽게 재사용 할 수 있고,
<br />
이로인해 코드의 일관성을 유지할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>코드의 구조화와 유지보수</strong>
<br />
<br />
객체를 사용해 기능적으로 관련된 데이터와 메서드를 묶어서 관리할 수 있다.
<br />
이로인해 코드의 일관성을 유지할 수 있고,
<br />
새로운 기능이 추가될 때 기존 코드를 변경하지 않아도 되므로 유지보수성을 높일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>캡슐화</strong>
<br />
<br />
객체간의 상호작용을 캡슐화 하여 데이터의 안정성을 유지할 수 있다.
<br />
객체는 자신만의 속성과 동작을 가지고 있으며, 다른 객체와 상호작용 할때 인터페이스를 통해
<br />
메시지를 주고받으므로 데이터가 보호되고, 객체간의 의존성을 줄일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속을 통한 코드 재사용</strong>
<br />
<br />
상속이란 이미 작성된 코드를 확장하거나 변경하여 새로운 클래스를 생성하는 방식이다.
<br />
기존 클래스를 기반으로 함으로 재사용성, 유지보수성을 높일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>다형성</strong>
<br />
<br />
다형성이란 객체가 다양한 형태로 동작할 수 있는 방식이다.
<br />
객체가 동일한 메시지를 받을때, 각각 다르게 동작할 수 있고 이로인해 코드를 유연하게 작성할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>현실세계와의 유사성</strong>
<br />
<br />
현실세계를 반영하므로 코드를 보다 직관적으로 작성할 수 있다.
<br />
예를들어, 자동차 객체를 만들때 자동차의 특징과 동작을 모델링하여 코드를 작성할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>협업</strong>
<br />
<br />
객체는 개별적인 역할과 책임을 가지므로 여러 개발자가 동시에 작업할 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop-단점">OOP 단점</h2>

<ul>
  <li><strong>복잡성</strong>
<br />
<br />
객체지향적인 설계는 추상화를 통해 복잡성을 감추지만, 구현을 위해 많은 코드가 필요하며
<br />
이로인해 코드의 복잡성이 증가할 수 있다.
<br />
또한 어플리케이션이 커질수록 객체 간의 상호작용과 의존성이 많아지고 그럴수록 복잡성은 증가한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>성능</strong>
<br />
<br />
객체를 생성하고 관리하기 위한 추가적인 오버헤드가 있으므로 성능 저하가 발생 할 수 있다.
<br />
또한 캡슐화 때문에 데이터에 접근하기 위한 추가비용이 들어가고 이는 데이터에 직접 접근하는 
<br />
절차지향 프로그래밍 보다 느릴 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>설계</strong>
<br />
<br />
명확한 구조와 규칙을 필요로 하고 객체간의 관계를 적절히 설계해야 하는 등 설계에 많은 리소스가 들어간다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속 남용</strong>
<br />
<br />
상속을 남용하면 중복코드가 생기고 클래스간의 관계가 복잡해질 수 있고 
<br />
하위 클래스가 상위클래스에 의존하게 되어 하위클래스 수정이 상위클래스까지 영향을 미칠 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop의-특징">OOP의 특징</h2>

<p><br /></p>

<h3 id="oop와-캡슐화">OOP와 캡슐화</h3>
<p><br />
객체를 추상화 하고, 객체의 내부 상태와 동작을 외부로부터 보호하는것을 의미한다.
<br />
객체의 내부 구현을 외부에 숨기고, 객체와 객체간의 상호작용을 인터페이스를 통해서 해서
<br />
객체의 상태를 외부에서 변경할 수 없도록 하고, 변경에 대한 책임을 객체 스스로가 갖도록 한다.
<br />
즉, 객체의 구현 세부사항을 숨기고 객체간의 결합도를 낮추는 효과를 가져온다.
<br />
객체의 구현 세부 사항을 숨기는 것을 객체지향설계 에선 <strong>정보은닉</strong> 이라고 부른다.
<br />
상속과 다형성의 개념과도 관련이 있는데,
<br />
부모클래스의 캡슐화된 멤버 변수와 메서드를 재사용할 수 있도록 하고
<br />
캡슐화된 인터페이스를 이용해 서로 다른 객체를 동일한 방식으로 다룰 수 있도록 한다.
<br />
캡슐화는 <strong>OOP</strong> 에서 객체의 추상화, 모듈화, 재사용성 등의 장점을 실현하는데 중요한 역할을 한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-상속">OOP와 상속</h3>
<p><br />
상속이란 부모클래스가 자식클래스에게 자신의 속성과 행위들을 물려주는 것을 의미한다.
<br />
이를 통해 자식클래스는 부모클래스의 기능을 그대로 물려받고, 새로운 속성과 행위를 추가할 수 있다.
<br />
부모 클래스에서 구현한 코드를 자식클래스에서 사용할 수 있으므로 코드의 재사용성이 높아지며
<br />
부모 클래스의 코드를 수정하면 자식클래스에서도 이를 반영하므로 유지보수가 용이해 진다.
<br />
자식클래스는 <strong>오버라이딩</strong> 를 통해 부모클래스의 메서드를 재정의 하여 사용할 수 있고 확장성이 좋아진다.
<br />
<br />
하지만 상속을 남용할 경우, 클래스 간의 복잡한 계층구조가 형성되고 복잡해 지며 유지보수가 어려워 진다.
<br />
또한, 결합도가 높아지기 때문에 부모클래스의 변경이 자식클래스에게도 영향을 미치게 된다.</p>

<p><br />
<strong>상속을 사용할 때</strong>
<br /></p>
<ul>
  <li>부모클래스의 기능을 그대로 사용하면서 새로운 기능을 추가하려는 경우</li>
  <li>부모와 자식클래스 간의 상속관계를 통해 다형성을 구현하려는 경우</li>
  <li>기존 클래스를 수정하지 않고 확장하려는 경우</li>
  <li>공통적인 기능이 있는 클래스들을 만들 때</li>
</ul>

<p><br />
<strong>상속을 사용하지 않을 때</strong>
<br /></p>
<ul>
  <li>계층구조가 복잡할 때</li>
  <li>결합도가 높아질 때</li>
  <li>상속구조가 고정되어 있을때
    <ul>
      <li>이 경우 인터페이스를 이용해 클래스간의 관계를 정의하는 편이 더 나을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>합성(Composition)?</strong>
<br />
<br />
합성은 객체를 조합해 새로운 객체를 만드는 방법이다. 합성을 이용하면 코드의 재사용성을 높이면서
<br />
클래스간의 결합도를 낮출 수 있다. 다른 클래스의 인스턴스를 생성하여 이를 이용하는 방법인데
<br />
상위클래스와 하위클래스 간의 강한 결합을 피할 수 있다.
<br />
상속은 부모와 자식간의 강한 계층구조를 가지지만 합성은 클래스 간의 관계를 느슨하게 유지한다.
<br />
클래스간의 관계를 조정하여 필요한 기능만을 조합하여 사용하기 때문에 클래스간의 결합도가 낮아진다.
<br />
예를들어 자동차 클래스에서 엔진, 타이어, 핸들 클래스를 각각 상속받는게 아니고, 자동차 클래스에서
<br />
엔진, 타이어, 핸들 클래스의 인스턴스를 생성하여 이를 이용하는 방법이다.
<br />
이를통해 자동차, 엔진, 타이어, 핸들 클래스 간의 결합도를 낮출 수 있다.
<br />
<br />
<strong>상속보단 합성?</strong></p>
<ul>
  <li>객체간의 결합도가 낮은 경우 : 객체가 변경되도 다른객체에 영향을 주지 않는다.</li>
  <li>변경이 상위 객체에 영향을 주지 않는 경우 : 객체의 변경에 유연성을 가진다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Engine started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>

    <span class="nc">Car</span> <span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Engine</span> <span class="n">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
        <span class="nc">Car</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
        <span class="n">car</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h4 id="서브클래싱">서브클래싱</h4>
<p><br />
상속을 통해 부모 클래스의 특성을 상속받아 새로운 클래스를 만드는 것을 말한다.
<br />
자식클래스는 부모클래스로부터 상속받은 속성과 메서드를 사용할 수 있고, 
<br />
상속받은 기능을 추가하거나 변경할 수 있다.
<br />
즉, 부모클래스의 기능을 재사용하고, 그 기능을 수정하거나 확장할 수 있다.</p>

<ul>
  <li><strong>장점</strong>
    <ul>
      <li>부모클래스에 구현된 코드로 재사용성을 높임</li>
      <li>서브클래싱으로 같은 인터페이스를 갖는 클래스를 여러개 만들어 다형성을 지원</li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>부모 자식 클래스 간의 강한 결합으로 인한 유지보수의 어려움</li>
      <li>부모클래스의 모든 기능을 상속받기때문에 불필요한 기능 또는 데이터까지 상속받아 객체가 거대해 짐</li>
      <li>서브클래스가 많아 질 수록 클래스간의 계층이 복잡해져서 의존성이 높아지고 가독성과 수정이 어려워짐</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h4 id="서브타이핑">서브타이핑</h4>
<p><br />
상속을 통해 부모클래스와 자식클래스 간의 포함 관계를 정의하는 것을 말한다.
<br />
서브타이핑을 이용하면 자식클래스는 부모클래스의 모든 속성과 메서드를 상속받아 사용할 수 있다.
<br />
또한 자식클래스는 상속받은 특성을 그대로 사용할 수도, 재정의하거나 새로운 메서드를 추가할 수 있다.
<br />
서브타이핑을 통해 부모와 자식클래스 간의 포함 관계를 정의하고, 부모클래스 타입의 변수에 자식클래스
<br />
객체를 할당하여 다형성을 구현하는 다형성의 핵심 개념중 하나이다.
<br />
하지만 부모 자식간의 밀접한 결합이 발생하고, 서브타입 다형성을 사용하면 객체가 어떤 메서드를 호출할지
<br />
런타임에 타입체크를 수행해야 하므로 불필요한 오버헤드가 발생할 수 있다.</p>

<p><br />
<br /></p>

<h4 id="둘의-차이-및-정리">둘의 차이 및 정리</h4>
<p><br />
둘다 객체지향 프로그래밍에서 다형성을 구현하기 위해 사용되는 개념이다.
<br />
<br />
<strong>서브클래싱</strong> 은 부모 클래스에서 상속받은 메서드와 속성을 그대로 사용하면서, 자식클래스에서는
<br />
새로운 기능을 추가하거나 변경하는걸 의미한다. 이는 코드의 재사용성과 확장성을 높이는 역할을 한다.
<br />
<br />
<strong>서브타이핑</strong> 은 부모클래스의 <strong>하위타입</strong> 인 자식클래스를 생성하고, 이를통해 객체의 다형성을 구현하는 것이다.
<br />
즉, <strong>부모클래스의 인스턴스를 자식클래스의 인스턴스로 대체</strong> 할 수 있도록 구현하는 것이다.
<br />
<br />
둘의 가장 큰 차이점은 상속에 대한 의미이다.
<br />
<br />
<strong>서브클래싱</strong> 은 부모 클래스로부터 상속받은 기능을 그대로 사용하면서 기능을 변경하거나 확장하는 것이고,
<br />
클래스의 계층구조를 만들어 코드의 재사용성과 확장성을 높이는데 주로 사용된다.
<br />
<br />
<strong>서브타이핑</strong> 은 부모 자식 클래스 간의 포함관계를 만들어 객체의 다형성을 구현하는것이 목표이다.
<br />
인터페이스와 추상클래스를 사용하여 다형성을 구현하는데 주로 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
서브클래싱
Dog 클래스는 Animal 클래스를 상속받아 eat() 메서드를 사용하면서,
새로운 기능인 bark() 메서드를 추가해서 사용한다.
*/</span>
<span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The animal eats."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog barks."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">bark</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/*
서브타이핑
Animal 인터페이스를 구현한 Dog 클래스에서 eat() 메서드를 구현하고, bark() 메서드를 추가한다.
그리고 Animal 인터페이스를 구현한 Dog 클래스를 생성해 feedAnimal() 메서드에 전달한다.
feedAnimal() 메서드는 Animal 인터페이스 타입의 매개변수를 받기 때문에,
Dog 클래스의 객체를 Animal 인터페이스로 대체할 수 있게 된다.
*/</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog eats."</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog barks."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">feedAnimal</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">feedAnimal</span><span class="o">(</span><span class="n">dog</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-추상화">OOP와 추상화</h3>
<p><br />
<strong>추상화</strong> 는 객체를 설계하는 과정에서 필요한 정보만 선택하고 나머지는 숨겨서 단순하게 만드는걸 말한다.
<br />
<strong>캡슐화</strong> 의 정의와 비슷하지만 <strong>캡슐화</strong> 는 객체의 상태와 행동을 외부로부터 보호하고 객체 간 결합도를 낮추는데
<br />
목적이 있다면, <strong>추상화</strong> 는 객체를 단순화 하여 코드의 가독성과 유지보수성을 높이는데에 목적이 있다.
<br />
<strong>캡슐화</strong> 에선 접근제어자를 사용하지만, <strong>추상화</strong> 에선 인터페이스와 추상클래스를 사용한다.</p>

<ul>
  <li><strong>interface</strong>
    <ul>
      <li>추상메서드와 상수만을 가질 수 있다.</li>
      <li>인터페이스를 구현하는 클래스에선 모든 메서드를 구현해야 한다.</li>
      <li>다중 상속 지원</li>
      <li>
        <p>인터페이스 타입으로 변수 선언 후, 변수에 다양한 구현 객체를 대입할 수 있다.</p>
      </li>
      <li><strong>장점</strong>
        <ul>
          <li>다중상속을 지원해 다양한 클래스 간의 유연한 상호작용 가능</li>
          <li>구현객체간의 관계를 약화시켜 코드의 결합도를 낮출 수 있음</li>
        </ul>
      </li>
      <li><strong>단점</strong>
        <ul>
          <li>인터페이스를 구현하는 클래스에서 모든 메서드를 구현해야 하므로, 코드의 양이 증가</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여러개의 클래스에서 같은 인터페이스를 구현하면, 해당 인터페이스를 모든 코드에서 동일하 게 다룰 수 있다. 즉, 다형성</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="kd">implements</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car start"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car stopp"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Motorcycle</span> <span class="kd">implements</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Motorcycle start"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Motorcycle stopp"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 인터페이스 타입으로 변수를 선언하고, 이 변수에 다양한 구현객체를 대입할 수 있다. 이를 통해 코드의 유연성을 높일 수 있다.</span>
<span class="nc">Vehicle</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span>
<span class="n">car</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">car</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>

<span class="nc">Vehicle</span> <span class="n">motorcycle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Motorcycle</span><span class="o">();</span>
<span class="n">motorcycle</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">motorcycle</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li><strong>abstract class</strong>
    <ul>
      <li>추상메서드와 일반 메서드도 가질 수 있다.</li>
      <li>추상클래스를 구현하는 클래스에선 추상 메서드를 구현해야 한다.</li>
      <li>단일 상속만 지원</li>
      <li>인스턴스 생성 불가</li>
      <li>
        <p>추상클래스 타입으로 변수 선언 후, 변수에 다양한 구현 객체를 대입할 수 있다.</p>
      </li>
      <li><strong>장점</strong>
        <ul>
          <li>공통된 코드를 추상클래스에 구현하여 재사용성을 높일 수 있음</li>
          <li>일반메서드를 포함할 수 있으므로, 공통된 기능을 쉽게 구현할 수 있음</li>
        </ul>
      </li>
      <li><strong>단점</strong>
        <ul>
          <li>단일상속만을 지원해서, 기능확장에 한계가 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="kd">extends</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 자동차 악셀</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 자동차 브레이크</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 추상클래스 타입으로 변수를 선언하고, 이 변수에 다양한 구현객체를 대입할 수 있다.이를 통해 코드의 유연성을 높일 수 있다.</span>
<span class="nc">Vehicle</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span>
<span class="nc">Vehicle</span> <span class="n">motorcycle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Motorcycle</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-다형성">OOP와 다형성</h3>
<p><br />
<strong>다형성</strong> 이란 객체가 동일한 메시지를 받았을 경우, 각각의 객체가 다르게 반응하도록 하는걸 말한다.
<br />
즉, 객체들이 동일한 메서드를 호출할 때, 이 메서드가 각 클래스에 따라 다르게 동작하는 것이다.
<br />
이러면 하나의 메서드가 다양한 형태로 동작하므로 재사용성과 유지보수성이 증가한다.
<br />
여러개의 클래스가 하나의 인터페이스를 구현할 수 있고, 인터페이스에 선언된 메서드는 각 클래스에서
<br />
오버라이딩 되어 동작하므로, 이 인터페이스의 메서드를 호출하는 코드는 각 클래스에 따라 동적으로 변하게 된다.
<br />
<br />
하지만, <strong>다형성</strong> 은 객체의 실제 타입을 런타임에 결정하기 때문에, 컴파일러가 정적으로 최적화 할 수 없어
<br />
성능저하를 가져올 수 있고 런타임 시에 오류가 발생할 수 있다.
<br />
또한 남발되면 객체 생성이 많아지고 코드의 가독성이 떨어지고 디버깅이 힘들어 지게 된다.</p>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop와-getter--setter">OOP와 Getter / Setter</h2>
<p><strong>Getter / Setter</strong> 는 <strong>캡슐화</strong> 의 원칙을 따르는 메서드 이다.
<br />
클래스의 인스턴스 변수에 직접 접근하는 걸 막고 클래스 내부에서 제어를 통해 인스턴스 변수에 접근하도록 한다.
<br />
하지만 과도하게 사용되면 변수에 직접 접근하지 않아도 간접적으로 접근하므로 캡슐화의 장점을 없애게 된다.
<br />
<br />
인스턴스 변수에 직접 접근하는것과 <strong>Getter / Setter</strong> 를 통해 접근하는것과 뭐가 다르냐고 생각할 수 있지만
<br />
인스턴스 변수가 <strong>public</strong> 으로 열려있으면 어디에서든지 접근할 수 있어서 캡슐화에 원칙에 완전히 위배되지만
<br />
<br />
<strong>Getter / Setter</strong> 를 통해 간접적으로 접근을 할 경우 적절한 제어를 통해 캡슐화를 유지할 수 있다.
<br />
여기서 적절한 제어란, <strong>Setter</strong> 에서 유효성 검사를 통해, 잘못된 값이 들어오는 걸 방지하는걸 말한다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="OOP" /><category term="서브클래싱 / 서브타이핑" /><category term="OOP와 상속" /><category term="OOP와 캡슐화" /><category term="OOP와 추상화" /><category term="OOP와 다형성" /><category term="Getter / Setter" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">SOLID</title><link href="http://localhost:4000/til/SOLID/" rel="alternate" type="text/html" title="SOLID" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/til/SOLID</id><content type="html" xml:base="http://localhost:4000/til/SOLID/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="solid">SOLID</h1>
<p>객체지향 프로그래밍에서 소프트웨어 디자인 품질을 향상시키기 위한 다섯 가지 원칙이다.
<br />
이 원칙을 따르면 아래와 같은 장점이 있다.</p>

<ul>
  <li>유지보수성 향상</li>
  <li>재사용성 항샹</li>
  <li>확장성 향상</li>
  <li>변경에 대한 유연성 향상</li>
  <li>코드의 가독성 향상</li>
  <li>결합도 감소</li>
  <li>테스트 용이성 향상</li>
  <li>오류발생 가능성 감소</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="srp---단일-책임-원칙">SRP - 단일 책임 원칙</h2>
<p>하나의 클래스는 하나의 책임을 가져야 한다는 원칙이다.
<br />
이것은 클래스가 변경되어야 하는 이유는 단 하나여야 함을 의미한다.
<br />
클래스의 응집력은 높이고 결합도는 낮춰서 유지보수, 재사용성, 확장성에 용이하게 하는 원칙으로, 
<br />
클래스 하나가 여러 책임을 가지게 되면 그 클래스를 변경해야 하는 이유도 여러가지가 생기므로, 
<br />
코드를 변경할때 다른 책임과 관련된 코드까지 함께 변경해야 한다. 
<br />
<br />
<strong>SRP</strong> 원칙을 지키기 위해서는 클래스가 자신의 책임을 명확하게 정의하고, 
<br />
다른 책임을 수행하는 클래스와의 의존성을 최소화 해야한다.
<br />
<br />
<strong>단점으로는</strong> 클래스와 인터페이스 수가 늘어나게 되고 클래스간의 상호작용을 복잡하게 만들 수 있다.
<br />
<br />
자바에서 <strong>SRP</strong> 를 구현하는 방식에는 <strong>클래스를 단일책임으로 분리</strong>, 
<br />
<strong>인터페이스를 이용해 책임을 분리</strong>, <strong>디자인패턴</strong>, <strong>AOP</strong> 등이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>클래스를 단일 책임으로 분리하는 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Order 클래스는 너무 많은 책임을 가지고 있다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Customer</span> <span class="n">customer</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// 클래스의 책임을 분리함으로써, 클래스간 의존성이 낮아지게 된다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderItem</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Item</span> <span class="n">item</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCalculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderItem</span><span class="o">&gt;</span> <span class="n">orderItems</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>인터페이스로 책임을 분리하는 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 상품 목록을 관리하는 ItemManager 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 이메일을 전송하는 EmailSender 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ItemManager 인터페이스를 구현하는 ItemManagerImpl 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemManagerImpl</span> <span class="kd">implements</span> <span class="nc">ItemManager</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// EmailSender 인터페이스를 구현하는 EmailSenderImpl 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSenderImpl</span> <span class="kd">implements</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="ocp---개방--폐쇄-원칙">OCP - 개방 / 폐쇄 원칙</h2>
<p>소프트웨어 구성요소 (클래스, 모듈, 함수 등) 는 확장에는 열려있어야 하지만, 변경에는 닫혀 있어야 한다. 
<br />
즉, 기존의 코드를 변경하지 않아도 새로운 기능을 추가할 수 있도록 하는 것이다.
<br />
<strong>OCP</strong> 는 다형성, 추상화, 인터페이스 등을 통해 내부 구현을 외부로 노출시키지 않고도 기능을 확장할 수 있는데
<br />
이는 코드의 유지보수, 확장성, 재사용성 등을 향상시킬 수 있다.
<br />
<br />
<strong>단점으로는</strong> 초기 설계와 인터페이스 설계등의 리소스가 많이 들어가게 되며 OCP를 적용하기 위해 
<br />
인터페이스와 추상화를 사용해 내부의 세부 구현사항을 숨기게 되면 코드의 복잡성이 증가하게 된다.
<br />
<br />
자바에서 <strong>OCP</strong> 를 구현하는 방식에는 
<br />
<strong>추상클래스 / 인터페이스</strong>, <strong>전략패턴</strong>, <strong>팩토리 메서드 패턴</strong>, <strong>데코레이터 패턴</strong> 등이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>추상클래스를 이용한 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 새로운 동물인 고양이를 이렇게 기존 코드를 변경하지 않고 확장할 수 있다. Cat 클래스는 Animal 타입으로 선언될 수 있고,</span>
<span class="c1">// Animal 타입으로 다루어 질때 makeSound() 메서드가 호출된다.</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>인터페이스를 이용한 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 기존의 코드를 변경하지 않고 Cat 클래스를 확장</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="lsp---리스코프-치환-원칙">LSP - 리스코프 치환 원칙</h2>
<p>하위타입은 상위타입으로 대체 가능해야 한다는 원칙이다. 
<br />
상속관계에서 부모클래스에 선언된 속성과 메서드는 하위클래스에서 동일하게 동작해야 한다.
<br />
즉, <strong>하위클래스가 상위클래스의 기능을 정확하게 대체할 수 있어야 한다.</strong>
<br />
<strong>LSP</strong> 는 유연한 확장, 재사용성 등에 장점이 있다.
<br />
<br />
<strong>단점으로는</strong> 설계에 리소스가 들어가게 되며 <strong>LSP</strong> 는 인터페이스와 상속관계에서만 적용할 수 있다.
<br />
<br />
자바에서 <strong>LSP</strong> 를 구현하는 방식에는 <strong>인터페이스</strong>, <strong>상속</strong> 이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>LSP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span> 
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BigDog</span> <span class="kd">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Big bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging at speed "</span> <span class="o">+</span> <span class="n">speed</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
BigDog 클래스의 wagTail() 메서드는 Dog 클래스의 wagTail() 메서드와
시그니처가 다르기 때문에 에러가 발생한다.
즉, BigDog 객체가 Dog 객체를 완벽하게 대체하지 못한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">bigDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDog</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">();</span>  <span class="c1">// 컴파일 에러 발생</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>LSP 를 준수한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BigDog</span> <span class="kd">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Big bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">wagTail</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging at speed "</span> <span class="o">+</span> <span class="n">speed</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Dog 클래스와 BidDog 클래스 모두 같은 wagTail() 메서드를 가지게 된다.</span>
<span class="c1">// Dog 객체를 대신하여 BigDog 객체를 사용할 때 문제가 일어나지 않는다.</span>
<span class="c1">// 즉, 부모클래스를 자식클래스로 대체해도 동일한 기능을 수행해서 LSP를 준수한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BigDog</span> <span class="n">bigDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDog</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="isp---인터페이스-분리-원칙">ISP - 인터페이스 분리 원칙</h2>
<p>인터페이스 분리 원칙을 의미한다.
<br />
즉, 인터페이스가 클라이언트에서 필요한 메서드만 가지도록 권장한다.
<br />
이렇게 함으로써 클라이언트 입장에선 필요하지 않은 메서드를 호출하거나
<br />
구현할 필요가 없게되고, 이것은 의존성을 줄이고 유지보수, 재사용성을 증가시킨다.
<br />
<br />
<strong>단점으로는</strong> <strong>인터페이스</strong> 와 <strong>클래스</strong> 가 많아지는 문제가 있다.</p>

<p><br /></p>

<ul>
  <li><strong>ISP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">fly</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bird</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="cm">/*
Bird 클래스는 run() 메서드를 구현하지 않고, Dog 클래스는 fly() 메서드를 구현하지 않는다.
이것은 필요하지 않은 메서드를 구현체에서 구현하기 때문에 ISP 원칙을 위반한다.

Animal 인터페이스를 run() 메서드와 fly() 메서드를 각각 가지는 2개의 인터페이스로 분리하면
ISP 원칙을 준수할 수 있다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">bird</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Bird</span><span class="o">();</span>
        <span class="n">bird</span><span class="o">.</span><span class="na">fly</span><span class="o">();</span>
        
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">fish</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="dip---의존관계-역전-원칙">DIP - 의존관계 역전 원칙</h2>
<p>상위모듈이 하위모듈에게 의존하면 안되며 둘다 추상화에 의존해야 한다는 원칙이다.
<br />
즉, 클래스는 다른 클래스에 의존하지말고 추상화를 통해 상호작용 해야 한다는 의미이다.
<br />
이것은 결합도를 낮추기 위한 방식으로 객체간의 의존성을 느슨하게 만드는 효과가 있다.
<br />
<strong>DIP</strong> 를 준수하면 하위 모듈이 변경되어도 상위 모듈에 영향이 없으므로 유연성과 확장성이 향상된다.
<br />
<br />
<strong>단점으로는</strong> 추상화를 위한 <strong>인터페이스</strong> 와 <strong>추상클래스</strong> 가 많아지고 복잡성이 증가한다.</p>

<p><br /></p>

<ul>
  <li><strong>DIP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UserRepository</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// UserRepository 에 직접 의존하고 있으므로 UserRepository 클래스의 변경이 UserService 에게 영향을 준다.</span>
<span class="kd">class</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>DIP 를 준수한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
UserService 클래스는 UserRepository 인터페이스에만 의존하도록 하고 생성자를 통해 주입받는다.
이제 UserRepository 클래스의 구현체인 DatabaseUserRepository 클래스가 UserRepository 인터페이스를 구현하도록 해서 DatabaseUserRepository 클래스가 변경되더라도 UserService 클래스에 영향을 미치지 않는다.
*/</span>
<span class="kd">class</span> <span class="nc">DatabaseUserRepository</span> <span class="kd">implements</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="책임이란">책임이란?</h2>
<p>객체가 수행하는 역할 또는 기능을 말한다. <strong>책임은 객체의 상태와 행위를 결정한다.</strong>
<br />
<strong>SOLID원칙</strong> 에서 책임은 객체나 모듈은 단 한가지의 책임을 가져야 하고 
<br />
이 객체나 모듈이 변경될 이유는 단 하나여야만 한다.
<br />
즉, 변경이 일어날 때 해당 객체만을 수정하면 단일책임원칙을 따르는 것이고 해당 객체 뿐만이 아니라
<br />
다른객체 까지 수정이 일어나면 단일책임원칙을 준수하지 못한것이다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="SRP" /><category term="OCP" /><category term="LSP" /><category term="ISP" /><category term="DIP" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">8 Week</title><link href="http://localhost:4000/til/8%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="8 Week" /><published>2023-02-02T00:00:00+09:00</published><updated>2023-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til/8%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/8%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="data-binding">Data Binding</h1>
<p>분리된 <strong>View</strong> 와 <strong>Model</strong> 을 하나로 묶어 두개의 데이터 소스를 연결하고 동기화 하는 기술이다.
<br />
<strong>Data Binding</strong> 은 대표적으로 단방향 데이터 바인딩과 양방향 데이터 바인딩으로 나뉜다.
<br />
<br />
백엔드 개발자에게 익숙한 <strong>MVC 패턴</strong> 은 <strong>View</strong> 대신 <strong>json</strong> 을 사용한다고 볼 수 있다.
<br />
프론트에선 요즘은 <strong>MVVM 패턴</strong> 을 자주 사용하는데 여기서 <strong>Data Binding</strong> 을 활용한다.</p>

<p><br /></p>

<ul>
  <li><strong>단방향 데이터 바인딩</strong>
    <ul>
      <li><strong>event</strong> 를 통해 데이터 흐름이 단방향으로 이루어 진다. (부모 -&gt; 자식)</li>
      <li><strong>View</strong> 가 바로 업데이트 되지 않는다.</li>
      <li><strong>양방향 데이터 바인딩</strong> 보다 리소스가 적게 든다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>양방향 데이터 바인딩</strong>
    <ul>
      <li>데이터 변경에 따라 프레임워크를 통해 양방향으로 이루어 진다. (부모 &lt;-&gt; 자식)</li>
      <li><strong>View</strong> 가 즉시 업데이트 된다.</li>
      <li><strong>단방향 데이터 바인딩</strong> 보다 리소스가 많이 든다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
웹 애플리케이션의 복잡도가 갈수록 향상되면서 브라우저 메모리가 
<br />
자바스크립트 객체와 화면에 있는 데이터를 맞추는데 큰 어려움이 생기고 있다.
<br />
이러한 상황을 쉽게 해결 해주기 위해 <strong>Data Binding</strong> 을 사용한다.
<br />
대표적인 프론트엔드 프레임워크인 <strong>Angular, React, Vue</strong> 모두 
<br />
<strong>Data Binding</strong> 을 지원하는데 상황에 따라 적절하게 쓰면 되겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="oop">OOP</h1>
<p>어플리케이션을 구성하는 요소들을 객체로 보고, 객체들을 유기적으로 연결하여 프로그래밍 하는걸 말한다.
<br />
데이터와 이를 처리하는 루틴을 하나의 <strong>독립된 객체</strong> 로 본다.
<br />
재사용성, 유지보수 에 용이하고 대형 프로젝트에 적합하다.
<br />
하지만 속도가 상대적으로 느리고, 설계 시 많은 리소스가 들어간다.</p>
<ul>
  <li><strong>추상화</strong>
    <ul>
      <li>목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념</li>
    </ul>
  </li>
  <li><strong>캡슐화</strong>
    <ul>
      <li>정보은닉 - 접근제어자</li>
      <li>코드의 의존성을 줄이고, 결합도를 낮추는 것</li>
      <li>필요한 부분만 외부에 노출시키고 나머지는 숨긴다.</li>
      <li>외부에서 불필요한 의존을 할 일이 없어지고 의존성이 줄어드는 만큼 유지보수도 편해진다.</li>
    </ul>
  </li>
  <li><strong>상속</strong>
    <ul>
      <li>코드의 재사용성에 이점이 있지만 코드의 재사용성만을 위해 사용은 지양한다.</li>
      <li>흔히 재사용성 뿐 아니라 계층구조 같은 구조를 만들 때 사용하자</li>
    </ul>
  </li>
  <li><strong>다형성</strong>
    <ul>
      <li>객체지향의 꽃이라고도 불린다.</li>
      <li>형태가 같지만 다른 기능을 하는 것을 말한다.</li>
      <li>하나의 타입에 여러 객체를 대입할 수 있는 성질이다.
        <ul>
          <li>업캐스팅
            <ul>
              <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 한다.</li>
            </ul>
          </li>
          <li>동적바인딩
            <ul>
              <li>메시지를 수신했을 때 실행도리 메서드가 런타임에 결정된다.</li>
            </ul>
          </li>
          <li>오버로딩</li>
          <li>오버라이딩</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="oop-왜쓰는데">OOP 왜쓰는데?</h2>

<p><br /></p>

<h2 id="oop와-상속">OOP와 상속</h2>

<p><br /></p>

<h2 id="oop와-추상화">OOP와 추상화</h2>
<p>책에서는 모델링이라고 설명한다.
<br />
대상에 집중하지말고 문제에 집중을 하면 올바른 추상화에 가까이 갈 수 있다.
<br />
대상은 문제를 풀기 충분한 정도의 속성만 가지고 있으면 되고, 이 문제를 푸는데 불필요한 
<br />
속성은 제거하는 편이 낫다.</p>

<p><br /></p>

<h2 id="oop와-캡술화">OOP와 캡술화</h2>

<p><br /></p>

<h2 id="oop와-getter--setter">OOP와 Getter / Setter</h2>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Data Binding" /><category term="OOP" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">7 Week</title><link href="http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="7 Week" /><published>2023-01-26T00:00:00+09:00</published><updated>2023-01-26T00:00:00+09:00</updated><id>http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="jdbc">JDBC</h1>
<h2 id="jdbc의-정의">JDBC의 정의</h2>
<p>데이터베이스 접근기술</p>

<p><br /></p>

<h2 id="jdbc-driver">JDBC Driver</h2>
<p>서로 다른 디비들에 대한 연결방법이 모두 다르기 때문에 거기에 대응하기 위해서 사용한다.
<br />
결국 디비가 서로 다르고 다른 연결방식 이어도 모두 같은방식으로 다루고 싶고
<br />
또한 프로그래밍 단에서는 하나의 방식으로 사용하고 싶기 때문에 사용한다.</p>

<p><br /></p>

<h2 id="jdbc-api">JDBC API</h2>
<p>드라이버가 매꿔준 걸 이용해서 같은방식으로 디비에 대한 접근을 제공하는 <strong>인터페이스</strong>
<br />
API는 <code class="language-plaintext highlighter-rouge">Application Programming Interface</code>의 약자이고
<br />
<code class="language-plaintext highlighter-rouge">JDBC API</code>란 여기에 접근하기 위해 추상적으로 공개한 루트이다.
<br />
이것도 결국 프로그래밍 단에서 다른걸 신경쓰지 않고 하나의 방법으로 사용하고 싶기 때문</p>

<p><br /></p>

<h2 id="connection-pool">Connection Pool</h2>
<p>데이터베이스에 대한 커넥션을 미리 생성해두고 재사용 하기 위한 방법
<br />
어플리케이션 시작 시점에 필요한 만큼의 커넥션을 미리 확보해서 풀에 보관한다.
<br />
<br />
<br />
<strong>왜쓰는데?</strong>
<br /></p>

<p>DB Driver는 데이터베이스와 <strong>TCP/IP</strong> 커넥션을 연결하는데, 이 과정에서 <code class="language-plaintext highlighter-rouge">3 way handshake</code> 같은
<br /> 
네트워크 동작이 발생하게 된다.
<br />
<code class="language-plaintext highlighter-rouge">3 way handshake</code> 는 <strong>Network Pass</strong> 를 확보하는데 3번의 통신을 해야 서로가 신뢰를
<br />
가지고 <strong>Pass</strong> 를 확정하기 때문에 이 과정에서 시간이라는 리소스가 많이 들어가게 된다.
<br />
비용적인 측면에서 <strong>느린거로</strong>는 네트워크가 압도적이기 때문에 <code class="language-plaintext highlighter-rouge">Connection Pool</code> 을 사용한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvc">MVC</h1>
<p>어플리케이션을 <strong>Model-View-Controller</strong> 의 세가지 컴포넌트로
<br />
각각 담당하는 역할을 구분한 디자인패턴</p>
<ol>
  <li>사용자가 입력을 담당하는 <strong>View</strong> 를 통해 요청을 보낸다.</li>
  <li>해당 요청을 <strong>Controller</strong> 가 받고 <strong>Model</strong> 을 통해 데이터를 가져온다.</li>
  <li>해당 데이터를 바탕으로 출력을 담당하는 <strong>View</strong> 를 통해 사용자에게 전달한다.
<br />
MVC패턴은 모델1과 모델2가 있다.</li>
</ol>

<ul>
  <li>모델 1
    <ul>
      <li>JSP에서 출력과 로직을 전부 담당</li>
      <li>사용자 요청을 JSP가 <code class="language-plaintext highlighter-rouge">JavaBean Service Class</code> 를 사용해 전부 처리</li>
      <li>빠르고 쉽게 개발할 수 있지만 유지보수맟 확장에 어려움</li>
    </ul>
  </li>
  <li>모델 2
    <ul>
      <li>JSP에서 출력만 담당</li>
      <li>사용자 요청을 서블릿이 받음</li>
      <li>설계가 어렵지만 분업이 가능하며 유지보수 및 확장에 용이</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Model</strong></p>
<ul>
  <li>어플리케이션의 정보, 데이터 등을 담당하고 정보들의 가공을 책임지는 컴포넌트</li>
  <li>비즈니스 로직 처리</li>
  <li>편집하기 원하는 모든 데이터를 가지고 있어야 한다.</li>
  <li>변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.</li>
  <li><strong>View / Controller</strong> 에 대해 의존하지 말아야 한다.</li>
</ul>

<p><br /></p>

<p><strong>View</strong></p>
<ul>
  <li>데이터의 입력과 보여지는 출력을 담당</li>
  <li><strong>Model</strong> 의 정보를 가지고 있지 말아야 한다.</li>
  <li>변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.</li>
  <li><strong>Model / Controller</strong> 에 의존하지 말아야 한다.</li>
</ul>

<p><br /></p>

<p><strong>Controller</strong></p>
<ul>
  <li><strong>Model / View</strong> 의 중간다리 역할을 한다.</li>
  <li>요청에 대해 해당 요청을 담당하는 <strong>Model</strong> 을 호출한다.</li>
  <li><strong>Model</strong> 의 작업결과를 리턴받아 <strong>View</strong> 에게 전달한다.
    <ul>
      <li><strong>Model / View</strong> 에 대해 알고있어야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Web에 적용할 시</strong></p>
<ol>
  <li>유저가 웹사이트에 접속</li>
  <li><strong>Controller</strong> 는 접속요청에 대해 <strong>Model</strong> 호출</li>
  <li><strong>Model</strong> 은 디비나 파일같은 데이터를 비즈니스 로직을 통해 처리 후 리턴</li>
  <li><strong>Controller</strong> 는 리턴받은 결과를 <strong>View</strong> 에 전달</li>
  <li>리턴받은 결과는 <strong>View</strong> 를 통해 유저에게 보여짐</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
사용자 <strong>UI / 비즈니스 로직 / 중간다리</strong> 이렇게 3가지로 구분하여 어플리케이션을
<br />
설계하면 각각 자신의 역할에만 집중할 수 있다.
<br />
이로인해 유지보수, 확장성, 유연성이 증가하고 중복을 줄일 수 있다.</p>

<p><br /></p>

<p><strong>단점</strong>
<br />
<br />
설계에 리소스가 들어간다. 예를들어</p>
<ul>
  <li><strong>Model / View</strong> 가 다른 컴포넌트 들에게 독립적이게 설계하는 것</li>
  <li><strong>Model</strong> 의 설계를 잘해야 변경에 유연할 수 있는것
<br /></li>
</ul>

<p>제대로 설계를 하지 않으면 <strong>View</strong> 와 <strong>Model</strong> 의 분리가 어려운데
<br />
<strong>Controller</strong> 를 통해 하나의 View에 연결될 수 있는 <strong>Model</strong> 도 여러 개가 될 수 있어
<br />
<strong>View</strong> 와 <strong>Model</strong> 이 서로 의존성을 띄게 될 수 있다.
<br />
즉, <strong>Controller</strong> 하나에 다수의 <strong>Model / View</strong> 가 복잡하게 얽히는 상황이 일어날 수 있다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvp">MVP</h1>
<p><strong>Model-View</strong> 는 <strong>MVC</strong> 패턴과 동일하고 <strong>Controller</strong> 대신 <strong>Presenter</strong> 가 존재하는 패턴
<br />
<strong>MVC</strong> 패턴 과 다른 핵심적인 설계는 <strong>View</strong> 와 <strong>Model</strong> 을 완전히 분리하고 서로간의 상호작용을
<br />
<strong>Presenter</strong> 에게 위임하여 서로의 의존성을 최소화 하는데 있다.</p>
<ul>
  <li><strong>Presenter</strong>
    <ul>
      <li><strong>View</strong> 와 <strong>Model</strong> 의 <strong>인스턴스</strong> 를 가지고 있다.</li>
      <li><strong>Presenter</strong> 와 <strong>View</strong> 는 1:1 관계이다.</li>
      <li><strong>View</strong> 에 직접 연결되는게 아니라 인터페이스를 통해 상호작용 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>동작</strong></p>
<ol>
  <li>사용자 요청은 <strong>View</strong> 를 통해 들어옴</li>
  <li><strong>View</strong> 는 데이터를 <strong>Presenter</strong> 에 요청</li>
  <li><strong>Presenter</strong> 는 <strong>Model</strong> 에게 데이터 요청</li>
  <li><strong>Model</strong> 은 <strong>Presenter</strong> 에게 요청받은 데이터 응답</li>
  <li><strong>Presenter</strong> 는 <strong>View</strong> 에게 데이터를 응답</li>
  <li><strong>View</strong> 는 <strong>Presenter</strong> 가 응답한 데이터를 사용해 화면을 나타냄</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<strong>Presenter</strong> 를 통해서만 데이터를 전달 받기 때문에 <strong>View-Model</strong> 간의 의존성이 없다.
<br />
<strong>View-Model</strong> 을 분리시켜 <strong>View</strong> 와 비즈니스 로직이 완전히 분리되어 MVC 패턴에서 
<br />
하기 힘든 테스트가 쉬워졌다.
<br />
<strong>View-Model</strong> 간의 의존성은 해결되었지만 반대로 <strong>Presenter</strong> 를 통해서만 Data를 전달받기 때문에
<br />
<strong>View-Presenter</strong> 간의 의존성이 높아지고 <strong>Controller</strong> 대신 <strong>Presenter</strong> 가 복잡해 진다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvvm">MVVM</h1>
<p>Command 패턴과 Data Binding 이라는 두 가지 패턴을 사용하여 구현되었다.
<br />
Command 패턴과 Data Binding을 이용하여 <strong>View</strong> 와 <strong>View Model</strong> 사이의 의존성을 없앰
<br />
<strong>Model-View</strong> 는 <strong>MVC</strong> 패턴과 동일하고 <strong>Controller</strong> 대신 <strong>View Model</strong> 이 존재한다.</p>
<ul>
  <li><strong>View Model</strong>
    <ul>
      <li><strong>View</strong> 를 표현하기 위해 만든 <strong>View</strong> 를 위한 <strong>Model</strong> 이다.</li>
      <li><strong>View</strong> 에서 필요로 하는 데이터 처리와 비즈니스 로직을 수행한다.</li>
      <li><strong>View Model</strong> 과 <strong>View</strong> 의 관계는 <strong>1:N</strong> 관계이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li><strong>Data Binding?</strong>
    <ul>
      <li><strong>Model</strong> 과 <strong>UI</strong> 요소간의 싱크를 맞추는 것</li>
      <li>이 패턴을 통해 <strong>View</strong> 와 로직이 분리되어 있어도 한쪽이 바뀌면 다른쪽도 
  <br />
  업데이트가 이루어져 데이터의 일관성을 유지할 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>동작</strong></p>
<ol>
  <li>사용자 요청은 <strong>View</strong> 를 통해 들어옴</li>
  <li><strong>View</strong> 는 Command 패턴으로 <strong>View Model</strong> 에게 요청 전달</li>
  <li><strong>View Model</strong> 은 <strong>Model</strong> 에게 데이터 요청</li>
  <li><strong>Model</strong> 은 <strong>View Model</strong> 에게 요청받은 데이터 응답</li>
  <li><strong>View Model</strong> 은 응답받은 데이터를 가공하여 저장</li>
  <li><strong>View</strong> 는 <strong>View Model</strong> 과 <strong>Data Binding</strong> 하여 화면을 나타냄</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<strong>View-Model</strong> 간의 의존성이 없다. 
<br />
Command 패턴과 Data Binding을 사용하여 <strong>View-View Model</strong> 간의 의존성 또한 없앤 디자인패턴 
<br />
각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있는 장점이 있다.
<br />
하지만 <strong>View Model</strong> 의 설계가 쉽지 않고 Data Binding 이 필수로 요구되는 단점이 있다.
<br />
또한 어플리케이션이 복잡해 질수록 <strong>View Model</strong> 이 거대해진다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="정리">정리</h1>
<p>이 패턴들의 공통적인 특징이자 장점은 처리결과를 화면에 보여주는 로직과 실제 데이터가
<br />
처리되는 로직을 분리 하는 것이다. 정답은 없고 상황에 맞게 적절히 응용하여 사용하는것이 중요하다.
<br />
구조의 단위가 화면인지 컴포넌트인지에 따라 선택하는 것도 좋은 방법이다.</p>

<p><br /></p>

<p><strong>MVC</strong></p>
<ul>
  <li><strong>Model</strong> 과 <strong>View</strong> 로직이 상호간에 의존적이다.</li>
  <li><strong>Controller</strong> 에 의해 특정 <strong>Model</strong> 에 따라 데이터가 처리되면 사전에 정의된 <strong>View</strong> 를 반환해 준다.</li>
</ul>

<p><br /></p>

<p><strong>MVP</strong></p>
<ul>
  <li>사용자 입력을 <strong>View</strong> 에서 직접 받고 <strong>Presenter</strong> 와 상호작용 하는 차이가 있다.</li>
  <li><strong>View</strong> 는 <strong>Presenter</strong> 와만 통신하므로 <strong>Model</strong> 에 대해 알 필요가 없다.
    <ul>
      <li>결과적으로 <strong>Model-View</strong> 간의 의존성이 사라진다.</li>
    </ul>
  </li>
  <li><strong>View</strong> 와 <strong>Presenter</strong> 간의 강한 <strong>1:1</strong> 의존관계가 있다는 단점이 존재한다.</li>
</ul>

<p><br /></p>

<p><strong>MVVM</strong></p>
<ul>
  <li><strong>View</strong> 를 표현하기 위해 만들어진 <strong>View</strong> 만을 위한 <strong>Model</strong> 인 <strong>View Model</strong> 을 사용한다.</li>
  <li><strong>View</strong> 로 전달된 입력에 의해 <strong>Command 패턴</strong>에 따라 <strong>View Model</strong> 에 명령을 내리고, 
<br />
데이터가 변화하면 그것에 따라 <strong>Data Binding</strong> 된다.
    <ul>
      <li><strong>View</strong> 와 <strong>View Model</strong> 간의 의존성은 사라진다.</li>
    </ul>
  </li>
  <li><strong>Binding</strong> 기술 등이 프레임워크 특화이기 때문에 다른 프레임워크 로의 재사용은 어렵다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="MVC" /><category term="MVP" /><category term="MVVM" /><category term="JDBC" /><category term="Connection Pool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">6 Week</title><link href="http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="6 Week" /><published>2023-01-19T00:00:00+09:00</published><updated>2023-01-19T00:00:00+09:00</updated><id>http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="web">Web</h1>
<p>아래 내용들을 무엇이다 라고 정의해보려고 했는데 명쾌하게 떠오르지 않았다.
<br />
이참에 한번 짚고 넘어가자.
<br />
<br />
<br />
<strong>World Wide Web</strong>
<br />
<br />
인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간</p>

<ul>
  <li>텍스트, 그림, 소리, 영상 등의 멀티미디어 정보를 하이퍼텍스트 방식으로 연결
    <ul>
      <li>하이퍼텍스트 : 문서 내부에 또다른 문서가 연결되는 참조를 넣음</li>
    </ul>
  </li>
</ul>

<p>웹페이지들은 각각 연결되어 있는데 이로 인해 거미줄처럼 얽혀있는 정보의 모음이라고도 불림</p>

<p><br /></p>

<p><strong>웹페이지</strong>
<br />
<br />
정보제공을 목적으로한 <code class="language-plaintext highlighter-rouge">정적</code>인 사이트
<br />
수동적으로 정보를 관람함</p>

<p><br /></p>

<p><strong>웹어플리케이션</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">동적</code>기능을 가진 웹으로 상호작용을 통해 유저가 
<br />
능동적으로 어플리케이션 상의 서비스를 이용하는것을 목적으로 함</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="browser-rendering">Browser Rendering</h1>

<p><br /></p>

<h2 id="ssr">SSR</h2>
<p><strong>서버사이드 렌더링 - Server Side Rendering</strong>
<br />
서버로부터 완전하게 만들어진 <code class="language-plaintext highlighter-rouge">HTML</code>  파일을 받아오는 방식
<br />
렌더링이 서버에서 일어난다.
<br /></p>
<ul>
  <li><strong>동작</strong>
    <ol>
      <li>클라이언트가 요청을 보냄</li>
      <li>서버는 <code class="language-plaintext highlighter-rouge">HTML</code> 에 데이터, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">JS</code> 를 렌더링하여 컴파일 후 보낸다.</li>
      <li>클라이언트는 즉시 <code class="language-plaintext highlighter-rouge">HTML</code> 을 먼저 렌더링 하고 그 후 <code class="language-plaintext highlighter-rouge">JS</code> 코드를 받아 실행한다.
<br />
<br /></li>
    </ol>
  </li>
  <li><strong>장점</strong>
    <ul>
      <li>빠른 초기 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">HTML</code> 안에 모든 데이터가 포함되어 있어 검색엔진에 노출이 잘됨 (크롤링)
<br />
<br /></li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>요청시마다 새로고침 (깜빡임)</li>
      <li>서버부하 (작은 변경이라도 서버에서 모든걸 다시 받아옴)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="csr">CSR</h2>
<p><strong>클라이언트 사이드 렌더링 - Client Side Rendering</strong>
<br />
사용자에 요청에 따라 필요한 부분만 응답받아 렌더링 하는 방식
<br />
렌더링이 클라이언트 쪽에서 일어난다.
<br /></p>
<ul>
  <li><strong>동작</strong>
    <ol>
      <li>클라이언트에서 초기화면을 로드하기 위해 서버에 요청을 보냄</li>
      <li>서버는 화면에 표시하는데 필요한 완전한 리소스 응답
<br />
<br /></li>
    </ol>
  </li>
  <li><strong>장점</strong>
    <ul>
      <li>빠른속도 (초기화면 렌더링X)</li>
      <li>서버부하 감소 (클라이언트에서 변경부분만 요청)</li>
      <li>유저경험 증가 (깜빡임)
<br />
<br /></li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>초기화면 로딩 느림 (<code class="language-plaintext highlighter-rouge">JS</code>포함 모든 파일을 받아야 함)</li>
      <li>검색엔진에 노출이 잘 안됨 (<code class="language-plaintext highlighter-rouge">HTML</code> 자체는 깡통이므로)</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="http의-전송방식">HTTP의 전송방식</h1>
<p><code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">POST</code> 등의 전송방식이 있지만 모두 텍스트 형식이다.
<br />
HTTP 전송방식에 왜 텍스트를 사용했을까?</p>
<ul>
  <li>다양한 환경에 맞는 (범용적, 유연함) 규약이 필요했다.</li>
  <li>왜나햐면 <code class="language-plaintext highlighter-rouge">Web</code>은 말그대로 전세계 모든 사람이 이용하는, 엄창나게 많은 곳에서 쓰인다.</li>
  <li>일단 텍스트는 눈으로 보고 어느정도 의미를 유추할 수 있고</li>
  <li>클라이언트에 상황에 구애받지 않는 텍스트가 가장 보편적이었다.</li>
  <li>따라서 바이트코드나 비트같이 가볍지만 제약이 따르는 것들 대신 보편적인 텍스트를 쓰는것이다.</li>
</ul>

<p><br /></p>

<p><strong>그렇다면 HTTPS는?</strong>
<br />
<br />
하이퍼 텍스트 전송 프로토콜 즉, <code class="language-plaintext highlighter-rouge">HTTP</code>는 <code class="language-plaintext highlighter-rouge">HTML</code>을 전송하기 위한 통신 규약이다.
<br />
하지만 암호화 되지 않은 방법으로 데이터를 전송하기 때문에 보안에 취약하다.
<br />
그래서 이를 보완한 것이 <code class="language-plaintext highlighter-rouge">SSL</code> 또는 <code class="language-plaintext highlighter-rouge">TLS</code> 사용해 암호화된 <code class="language-plaintext highlighter-rouge">HTTPS</code> 이다.
<br />
<code class="language-plaintext highlighter-rouge">SSL, TLS</code> 는 응용계층<code class="language-plaintext highlighter-rouge">(HTTP)</code> 과 전송계층<code class="language-plaintext highlighter-rouge">(TCP)</code> 사이에 위치해 있다.</p>

<ul>
  <li><strong>SSL</strong> : 서버와 브라우저 사이에 전송되는 데이터를 암호화 함</li>
  <li><strong>TSL</strong> : <code class="language-plaintext highlighter-rouge">SSL</code>의 향상된 버전, 통신하는 대상간의 데이터의 무결성을 제공하는걸 목표로 함
<br />
<br /></li>
</ul>

<p><strong>인증서 동작</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">SSL/TSL</code> 세션은 핸드셰이크라는 과정을 통해 클라이언트-서버 간에 암호화 된 연결을 수립한다.</p>
<ul>
  <li><strong>인증</strong>
    <ul>
      <li>클라이언트가 시작하는 모든 신규 세션에 대해 서버는 각각 다른 <code class="language-plaintext highlighter-rouge">SSL</code> 인증서를 교환하고 검증한다.</li>
    </ul>
  </li>
  <li><strong>암호화</strong>
    <ul>
      <li>서버는 클라이언트와 공개 키를 공유하고 클라이언트는 이 키를 사용해 프리마스터 키를 생성해 암호화한다. 이를 키교환이라고 한다.</li>
    </ul>
  </li>
  <li><strong>복호화</strong>
    <ul>
      <li>서버는 개인 키를 사용해 프리마스터 키를 복호화 하고, 세션기간동안 사용되는 암호화된 보안연결을 수립한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="base64">Base64</h1>
<p><strong>Binary Data 를 Text로 바꾸는 인코딩</strong> 의 하나로써 <code class="language-plaintext highlighter-rouge">Binary Data</code> 를 Character set에 영향을 받지 않는 공통 <code class="language-plaintext highlighter-rouge">ASCII</code> 영역의 문자로만 이루어진 문자열로 바꾸는 인코딩이다.
<br />
<code class="language-plaintext highlighter-rouge">Base64</code>는 직역하면 64진법인데, 64진법은 2의 제곱수에 기반한 진법 중 화면에 표시되는 <code class="language-plaintext highlighter-rouge">ASCII</code> 문자들로 표시할 수 있는 가장큰 진법이다.</p>
<ul>
  <li><strong>인코딩</strong> : 정보의 형태나 형식을 표준화, 보안, 처리속도향상 등을위해 다른 형태나 형식으로 변환하는 처리</li>
</ul>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">Base64</code>로 인코딩하면 데이터양이 약 33% 늘어나고 다시 디코딩하는 추가연산도 필요하다. 근데 왜쓸까?
<br />
HTTP로 <code class="language-plaintext highlighter-rouge">Binary Data</code>(이미지, 오디오 등)를 전송하면 문제가 발생하는데, 대표적으로</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ASCII</code>는 <code class="language-plaintext highlighter-rouge">7bits</code> 인코딩 인데 나머지 <code class="language-plaintext highlighter-rouge">1bit</code> 를 처리하는 방식이 시스템 별로 상이하다.</li>
  <li>일부 제어문자 (e.g. Line ending)의 경우 시스템 별로 다른 코드값을 갖는다.
<br /></li>
</ul>

<p>즉,<code class="language-plaintext highlighter-rouge">Binary Data</code>의 손실이 일어나기 때문에, <strong>ASCII는 시스템간 데이터를 전달하기에 안전하지가 않다.</strong> 
<br />
그래서 <code class="language-plaintext highlighter-rouge">ASCII</code> 중 제어문자와 일부 특수문자를 제외한 64개의 안전한 출력 문자만 사용하는 <code class="language-plaintext highlighter-rouge">Base64</code>를 사용한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="bulk-처리">Bulk 처리</h1>
<p>대량의 데이터를 한번의 트랜잭션으로 삽입하는 방법이다.
<br />
<br />
insert 로 예를들면
<br />
<code class="language-plaintext highlighter-rouge">MyBatis</code> 기준 insert 구문 수행 시 values 리스트를 다중으로 사용한다.
<br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="n">A</span> <span class="k">values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">)</span> <span class="p">...</span>


<span class="k">insert</span> <span class="k">into</span> <span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">)</span> <span class="k">values</span>
<span class="o">&lt;</span><span class="n">foreach</span> <span class="n">collection</span><span class="o">=</span><span class="nv">"list"</span> <span class="n">item</span><span class="o">=</span><span class="nv">"item"</span> <span class="n">separator</span><span class="o">=</span><span class="nv">","</span><span class="o">&gt;</span>
	<span class="o">#</span><span class="p">{</span><span class="n">item</span><span class="p">}</span>
<span class="o">&lt;/</span><span class="n">foreach</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
DB와의 트랜잭션은 커넥션을 열고 닫는 등의 생각보다 복잡하고 리소스가 큰데 10000건의 데이터를 
<br />
저장하는 경우를 생각해 보면 데이터를 저장하는데 10000번의 트랜잭션이 일어나게 된다.
<br />
<br />
하지만 <code class="language-plaintext highlighter-rouge">bulk insert</code> 의 경우 단 한번의 트랜잭션으로 처리를 할 수 있기 때문에
<br />
데이터 수가 많을수록 비약적으로 성능이 향상된다.
<br />
<br />
실제로도 예전에 거의 안쓰이는 스케쥴러 처리한 <code class="language-plaintext highlighter-rouge">insert</code> 용도의 <code class="language-plaintext highlighter-rouge">API</code> 가 있는데 어느순간
<br />
급격히 사용량이 많아져서 데이터 처리에 딜레이가 발생하는 상황이 생긴적이 있는데
<br />
이때 <code class="language-plaintext highlighter-rouge">bulk</code> 처리 하나로 비약적인 성능향상과 이슈를 해결한 적이 있었다.</p>

<p><br /></p>

<p><strong>단점</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">bulk insert</code> 로 10000건의 데이터를 insert 하던 중 마지막 <code class="language-plaintext highlighter-rouge">low</code> 에서 에러가 발생한다면?
<br />
이럴경우 모두 롤백된다.
<br />
<br />
10000번의 트랜잭션을 1번의 트랜잭션으로 해결해서 비약적인 성능향상을 가져올 수 있지만 하나라도 
<br />
실패하는 순간 트랜잭션은 롤백되고 그 트랜잭션 안에 10000건이 있기 때문에 이렇게 되면 매우 비효율적이다.
<br />
그래서 너무 대량의 데이터를 <code class="language-plaintext highlighter-rouge">bulk</code> 처리 하는건 좋지않고,
<br />
실패할 경우를 대비해 <code class="language-plaintext highlighter-rouge">retry</code> 하는 코드도 별도로 짜주는게 좋다.
<br />
제일 좋은건 정합성이 뛰어난 데이터여서 실패할 가능성이 거의 없을때 사용하는게 좋겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="세션이-왜필요할까">세션이 왜필요할까?</h1>
<p><code class="language-plaintext highlighter-rouge">HTTP</code>프로토콜은 비연결 지향이기 때문에 세션과 쿠키를 사용하는데
<br />
세션은 서버에서 관리하고 프론트에선 그 키를 받아서 내가 누구인지 알려준다.
<br />
이런식으로 인증에 대한 세션과 쿠키의 협업이 일어난다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="apache-tomcat">Apache Tomcat</h1>
<p>가장 범용적인 <code class="language-plaintext highlighter-rouge">WAS</code> 중 하나이며, Apache 재단 에서 개발한 <code class="language-plaintext highlighter-rouge">HTTP Web Application Server</code>이다.
<br />
오픈소스이기 때문에 무료이고 구축이 쉽다는 이유로 전세계에서 매우 많이 사용되고 있다.
<br />
기본적으로 <code class="language-plaintext highlighter-rouge">Apache</code> 와 <code class="language-plaintext highlighter-rouge">Tomcat</code> 의 기능은 나뉘어져 있지만, <code class="language-plaintext highlighter-rouge">Tomcat</code> 안에 컨테이너를 통해 
<br />
일부 <code class="language-plaintext highlighter-rouge">Apache</code> 기능을 발휘하기 때문에 보통 <code class="language-plaintext highlighter-rouge">Apache Tomcat</code> 으로 부른다.</p>
<ul>
  <li><strong>Apache</strong>
    <ul>
      <li>웹서버이며, 80포트로 클라이언트 요청(GET, POST 등)이 왔을때만 응답한다.</li>
      <li>정적인 데이터만 처리한다 (HTML, CSS, 이미지 등)
        <ul>
          <li><strong>웹서버</strong> : <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜 요청을 처리하는 서버</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Tomcat</strong>
    <ul>
      <li>동적인 웹을 만들기 위한 <code class="language-plaintext highlighter-rouge">Web Container</code>, <code class="language-plaintext highlighter-rouge">Servlet Container</code> 로도 불림</li>
      <li><code class="language-plaintext highlighter-rouge">Servlet</code> 을 실행키고 <code class="language-plaintext highlighter-rouge">JSP</code> 코드가 포함되어 있는 웹 페이지를 만들어준다.</li>
      <li>DB, 로직처리 등을 요구하는 동적타입을 제공하는 소프트웨어</li>
      <li>프로그램 실행환경과 DB 접속 기능 등을 제공한다.</li>
      <li>여러개의 트랜잭션을 관리한다.</li>
      <li>비즈니스 로직을 수행한다.</li>
    </ul>
  </li>
  <li><strong>Sevrlet</strong>
    <ul>
      <li>동적인 처리를 하는 역할을 담당하는 자바 기반 기술</li>
      <li><code class="language-plaintext highlighter-rouge">WAS</code>에서 동작하는 Java 클래스이며, <code class="language-plaintext highlighter-rouge">HttpServlet</code> 을 상속받는다.</li>
      <li><code class="language-plaintext highlighter-rouge">Request / Response</code> 흐름을 간단한 메서드 호출로 다룰 수 있게 해준다.</li>
    </ul>
  </li>
  <li><strong>Sevrlet Container</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Sevrlet</code> 을 담고 관리하는 컨테이너</li>
      <li>새로운 요청이 들어올 때 마다 스레드를 생성</li>
      <li>작업이 끝난 서블릿 스레드를 제거</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>정리하면</strong>
<br />
<br />
<strong>Apache Tomcat != Apache</strong></p>
<ul>
  <li><strong>Apache 만 사용하면?</strong>
    <ul>
      <li>구조가 단순하여 트래픽 과부하에 장점이 있다.</li>
      <li>정적인 웹페이지만 처리가 가능하다.</li>
    </ul>
  </li>
  <li><strong>Tomcat 만 사용하면?</strong>
    <ul>
      <li>동적인 웹페이지 처리가 가능하지만 <code class="language-plaintext highlighter-rouge">Apache</code> 에서 필요한 기능을 가져오지 못한다.</li>
      <li><code class="language-plaintext highlighter-rouge">Apache</code> 에 비해 속도가 느려 트래픽 과부하에 단점이 있다.</li>
    </ul>
  </li>
  <li><strong>둘을 같이쓰면?</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Apache</code> 는 정적인 데이터만 처리하고, JSP 처리는 Web Container(Tomcat의 일부)로 보낸다. 
  <br />
  결국 분산처리가 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servlet-filter">Servlet Filter</h1>
<p>J2EE 표준 스펙을 구현한 기술이다. <code class="language-plaintext highlighter-rouge">Tomcat</code>과 같은 <code class="language-plaintext highlighter-rouge">Web Container</code>에 의해 관리된다.
<br />
<code class="language-plaintext highlighter-rouge">Servlet</code>으로 전달되는 클라이언트의 <code class="language-plaintext highlighter-rouge">request</code> 혹은 <code class="language-plaintext highlighter-rouge">Servlet</code>에서 클라이언트로 전달되는 <code class="language-plaintext highlighter-rouge">response</code>를
<br />
중간에 가로채서 <code class="language-plaintext highlighter-rouge">request / response</code> 객체 자체를 조작할 수 있다.
<br />
<br />
사용자인증, 로깅, 인코딩 같은 기능들은 모든 <code class="language-plaintext highlighter-rouge">Servlet</code>이나 JSP가 공통적으로 필요로 하기 때문에 공통적인
<br />
기능들을 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 호출되기 전에 전처리 혹은 후처리 하고 싶을 때 <code class="language-plaintext highlighter-rouge">Servlet Filter</code>로 구현한다.
<br />
클라이언트 요청을 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 받기전에 먼저 가로채서 서버컴포넌트의 공통적인 기능을 수행시킬 수 있다.
<br />
<br />
예를들어 모든 페이지에서 로그인 유무를 확인해야 할 경우 각 <code class="language-plaintext highlighter-rouge">Controller</code> 마다 로그인 유무를 체크하는 로직을
<br />
작성하면 추후 로그인 관련 로직이 변경될 경우 모든 로직을 바꿔야 하기 때문에 매우 비효율 적일 것이다.
<br />
그렇다면 이 <strong>공통관심사</strong> 를 분리해서 필터에 위임하면 유지보수가 훨씬 용이해 질 것이다. 
<br />
<code class="language-plaintext highlighter-rouge">Servlet Filter</code> 는 <code class="language-plaintext highlighter-rouge">Servlet</code>과 비슷한 <code class="language-plaintext highlighter-rouge">LifeCycle</code>을 가진다. (생성 - 초기화 - 필터 - 종료)</p>
<ul>
  <li>필터로 구현하면 좋은 기능들
    <ul>
      <li>인증(사용자 인증) 필터</li>
      <li>로깅 및 감시 필터</li>
      <li>이미지 변환 및 데이터 압축 필터</li>
      <li>암호화 필터</li>
      <li>XML 컨텐츠를 변형하는 XSLT 필터</li>
      <li>URL 및 기타 정보들을 캐싱하는 필터</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<h2 id="관심사의-분리">관심사의 분리?</h2>
<p><code class="language-plaintext highlighter-rouge">Filter</code>를 공부하다가 <code class="language-plaintext highlighter-rouge">관심사의 분리</code> 라는 키워드를 보게 되었다.
<br />
<code class="language-plaintext highlighter-rouge">Filter</code>는 무슨 행동을 하기전에 먼저 실행하거나, 실행한 후 추가적인 행동을 할 때 사용하는데
<br />
스프링에는 <strong>공통처리</strong> 를 위해 활용할 수 있는 <code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">AOP</code> 가 더 있다.
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code>는 <code class="language-plaintext highlighter-rouge">Servlet</code>단위에서 실행되지만 <code class="language-plaintext highlighter-rouge">AOP</code>는 메소드 앞에 Proxy패턴의 형태로 실행된다.
<br />
실행순서는 <code class="language-plaintext highlighter-rouge">Filter</code>가 가장 밖에 있고 그안에 <code class="language-plaintext highlighter-rouge">Interceptor</code>, 그안에 <code class="language-plaintext highlighter-rouge">AOP</code>가 있는 형태이다.
<br />
따라서 요청이 들어오면 <code class="language-plaintext highlighter-rouge">Filter</code> → <code class="language-plaintext highlighter-rouge">Interceptor</code> → <code class="language-plaintext highlighter-rouge">AOP</code> → <code class="language-plaintext highlighter-rouge">Interceptor</code> → <code class="language-plaintext highlighter-rouge">Filter</code> 순으로 거치게 된다.</p>

<p><br /></p>

<h3 id="interceptor">Interceptor</h3>
<p>스프링에서 제공하는 기술이다. 
 <br />
 <code class="language-plaintext highlighter-rouge">DistpatcherServlet</code>이 <code class="language-plaintext highlighter-rouge">Controller</code>를 호출하기 전과 후에 응답을 참조하거나 가공한다.
<br />
<code class="language-plaintext highlighter-rouge">Filter</code>는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작하지만
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>는 스프링의 <code class="language-plaintext highlighter-rouge">DistpatcherServlet</code>이 <code class="language-plaintext highlighter-rouge">Controller</code>를 호출하기 전, 후로 끼어들기 때문에 
<br />
스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.</p>
<ul>
  <li>스프링의 모든 빈 객체에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Interceptor</code>는 여러개를 사용할 수 있고 다음과 같은 작업을 수행한다.
    <ul>
      <li>로그인 체크</li>
      <li>권한 체크</li>
      <li>프로그램 실행시간 계산작업</li>
      <li>API 호출에 대한 로깅</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="aop">AOP</h3>
<p><strong>OOP</strong>를 보완하기 위해 나온 개념 
<br />
객체지향 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.
<br />
주로 <strong>비즈니스단</strong>의 메서드에서 로깅, 트랜잭션, 에러처리 등을 조금 더 세밀하게 조정하고 싶을 때 사용한다.
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code> 와 다르게 메서드 전후의 지점에 자유롭게 설정이 가능하고
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code>는 주소로 대상을 구분해서 걸러내지만 <code class="language-plaintext highlighter-rouge">AOP</code>는 주소, 파라미터, 어노테이션 등 다양하게 대상을 지정할 수 있다.</p>
<ul>
  <li><strong>메서드 단위 공통로직</strong> 에 적합 예를들면, 각 메서드가 얼마나 걸리는지 시간측정하는 로그를 뿌리는 작업</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servletcontextlistener">ServletContextListener</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="tcp--udp">TCP / UDP</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="배치시스템-vs-스트리밍-시스템">배치시스템 vs 스트리밍 시스템</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="osi-7-계층">OSI 7 계층</h1>
<p>계층이 올라간다는건 무슨 의미일까?
<br />
<br />
TCP 기반의 HTTP가 UDP통신을 도입하고 있는데 과연 데이터 정합성의 문제는?</p>

<ul>
  <li>데이터 정합성의 검증을 한 계층 더 올려서 거기서 한다는데?</li>
  <li>그러니까 TCP를 사용하는 계층에선 정합성의 문제에서 자유로우니 UDP 통신을 이용한다?</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Apache Tomcat" /><category term="Servlet Filter" /><category term="Web" /><category term="Session" /><category term="OSI 7계층" /><category term="TCP / UDP" /><category term="Bulk 처리" /><category term="SSR" /><category term="CSR" /><category term="HTTPS" /><category term="Base64" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">refactoring</title><link href="http://localhost:4000/til/refactoring/" rel="alternate" type="text/html" title="refactoring" /><published>2023-01-13T00:00:00+09:00</published><updated>2023-01-13T00:00:00+09:00</updated><id>http://localhost:4000/til/refactoring</id><content type="html" xml:base="http://localhost:4000/til/refactoring/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="리팩토링">리팩토링?</h1>

<p>소프트웨어 관점으로 결과의 변경 없이 코드의 구조를 재조정함 을 의미한다.
<br />
즉, 기능은 보존하면서 설계 및 구조를 개선하는 것이다.</p>
<ul>
  <li>소프트웨어 설계가 좋아진다.</li>
  <li>소프트웨어를 이해하기 쉬워진다.</li>
  <li>버그를 쉽게 찾을 수 있다.</li>
  <li>프로그래밍 속도를 높일 수 있다.</li>
</ul>

<p><br />
<br /></p>

<p><strong>진짜 중복</strong></p>
<ul>
  <li>한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야한다.</li>
</ul>

<p><strong>우발적 중복 (거짓된 중복)</strong></p>
<ul>
  <li>중복으로 보이는 두 코드의 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="3의-법칙">3의 법칙</h1>
<ol>
  <li>처음에는 그냥 한다.</li>
  <li>비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.</li>
  <li>비슷한 일을 세 번째 하게 되면 리팩토링한다.</li>
</ol>

<p><br />
<br />
<br /></p>

<p><strong>기능을 새로 추가하기 직전</strong></p>
<ul>
  <li>리팩터링 하기 가장 좋은 시점은 기존 기능에 새로운 기능을 추가하기 직전이다.</li>
  <li>기능을 추가하기 쉽게만드는 것이 리팩터링의 핵심</li>
  <li>구조를 살짝 바꾸면 다른 작업하기 쉬워질 만한 부분을 찾는다.</li>
  <li>기능을 추가하면서 중복코드가 생길만한 부분을 함수화 시킨다.</li>
</ul>

<p><br /></p>

<p><strong>코드를 이해하기 어려울때</strong></p>
<ul>
  <li>코드 수정시 코드를 이해하기 어렵다면 이해를 위한 리팩터링을 진행한다.</li>
  <li>코드만 보더라도 이해를 쉽게 할 수 있도록 변수와 함수의 이름을 변경한다.</li>
  <li>코드를 이해하기 쉽게 만드는것은 협업하기도 좋고 코드를 오래 보존 할 수 있게된다.</li>
</ul>

<p><br /></p>

<p><strong>불필요한 코드를 발견했을때</strong></p>
<ul>
  <li>코드가 비효율적으로 수행되는 것을 발견했을대 리팩터링을 진행한다.</li>
  <li>로직 혹은 코드가 쓸데없이 복잡하거나 불필요한 코드를 발견했다면 보이스카웃 규칙을 떠올리자.</li>
  <li>원래 하려던 작업시간을 뺏길 수 있으니 간단한 일이라면 바로 처리하고, 시간이 좀 걸릴 것 같으면 <code class="language-plaintext highlighter-rouge">TODO</code>를 남겨두자.</li>
</ul>

<p><br /></p>

<p><strong>계획된 리팩토링</strong></p>
<ul>
  <li>수시로 진행하는 리팩터링 외에도 따로 시간을 내서 리팩터링을 진행 할 수 있다.</li>
  <li>미리 새기능을 추가 할 수 있도록 코드를 개선해둔다.</li>
  <li>코드가 이미 깔끔하다면 리팩터링을 하기에도 더 쉽다.</li>
</ul>

<p><br /></p>

<p><strong>오래걸리는  리팩토링</strong></p>
<ul>
  <li>각 잡고 전체 개발자들이 달려들어서 리팩토링을 하는 짓은 좋지않다.</li>
  <li>리팩토링 해야될 코드와 관련된 작업을 하게 될 때 마다 원하는 방향으로 조금씩 개선하는 방향을 추구하자</li>
</ul>

<p><br /></p>

<p><strong>코드리뷰에 리팩토링 활용하기</strong></p>
<ul>
  <li>PR 피드백을 활용하여 리팩토링 해나가는 것도 좋은 방법이다.</li>
</ul>

<p><br /></p>

<p><strong>리팩토링 하지 말아야 할 때</strong></p>
<ul>
  <li>호출해서 쓰는 코드라면 굳이 건들지 말자</li>
  <li>리팩터링보다 새로 코드를 작성하는 쉬운 코드의 경우 그냥 둔다.</li>
  <li>어떤 코드가 리팩터링보다 새로 만드는게 쉬운가에 대한 판단은 많은 경험이 뒷받침 되어야한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Refactoring" /><summary type="html"><![CDATA[]]></summary></entry></feed>