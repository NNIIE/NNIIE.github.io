<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-19T03:15:48+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">Design Pattern</title><link href="http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41/" rel="alternate" type="text/html" title="Design Pattern" /><published>2023-02-16T00:00:00+09:00</published><updated>2023-02-16T00:00:00+09:00</updated><id>http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41</id><content type="html" xml:base="http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="디자인패턴">디자인패턴</h1>
<p>일종의 설계 템플릿으로, 구체적인 구현방법을 제시하는것이 아니라 어떤 문제에 대해
<br />
어떤 구조와 접근법이 적절한지에 대한 <strong>가이드라인</strong>이다.
<br />
소프트웨어가 점점 복잡해지면서 다양한 문제가 발생하게 되었고, 이런 문제를 해결하기 위해
<br />
많은 개발자들이 각자의 방식으로 접근하다보니 비슷한 문제를 다른방식으로 해결하는 경우가 많았다.
<br />
결국 유지보수 등의 어려움을 겪게되고, 이러한 문제를 해결하기 위해 많은 개발자들의 전문지식을 모아
<br />
이미 검증된 방식을 <strong>템플릿 형태</strong>로 모아 <strong>가이드라인</strong>을 제시하게 되었다. 
<br />
이로써, 소프트웨어의 유연성, 확장성, 생산성, 픔질 향상에 큰 도움이 된다.</p>

<p><br />
<br />
<br />
<br /></p>

<h2 id="어댑터-패턴">어댑터 패턴</h2>
<p><strong>Adapter Pattern</strong>
<br />
호환되지 않는 여러 객체를 하나의 <strong>인터페이스</strong> 로 묶어서 사용할 수 있는 디자인 패턴이다.
<br />
이를통해, 재사용성, 유지보수성 을 향상시킬 수 있다.</p>

<p><br /></p>

<p><strong><em>인터페이스가 호환되지 않는 클래스들을 함께 사용하기 위해 사용한다.</em></strong></p>
<ul>
  <li>기존 코드나 라이브러리를 재사용하면서 새로운 시스템을 구축할 때</li>
  <li>호환성없는 두 클래스를 연결해 사용해야 할때</li>
  <li>인터페이스나 메소드가 다른 두 클래스 사이에서 호환성 문제를 해결해야 할 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>기존코드의 수정없이 호환되지 않는 객체를 연결할 수 있다.</li>
  <li>객체간의 결합도를 줄일 수 있다.</li>
  <li>호환성이 없는 여러 객체를 하나의 어댑터로 묶어서 사용할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>객체가 추가될 때 마다 어댑터 클래스가 늘어난다.</li>
  <li>어댑터가 객체를 감싸는 구조를 가지기 때문에 어댑터로 연결된 객체는 성능상 손실이 있을 수 있다.</li>
  <li>코드가 복잡해진다.</li>
</ul>

<p><br /></p>

<h3 id="구현">구현</h3>

<hr />

<p><strong>일반적인 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Generic animal sound"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Wolf 클래스는 Animal 클래스와 호환되지 않는 인터페이스를 가지고 있다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wolf</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">howl</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Howl"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
WolfAdapter 클래스는 Animal 클래스를 상속받고, makeSound() 메서드를 오버라이드 해서 
Wolf 클래스의 howl() 메서드를 호출하도록 구현한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WolfAdapter</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Wolf</span> <span class="n">wolf</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">WolfAdapter</span><span class="o">(</span><span class="nc">Wolf</span> <span class="n">wolf</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wolf</span> <span class="o">=</span> <span class="n">wolf</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">wolf</span><span class="o">.</span><span class="na">howl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 어댑터패턴으로 호환되지 않는 인터페이스를 연결하면 기존 코드를 수정하지 않아도 다른 객체와 같이 동작할 수 있게 된다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdapterExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// "Generic animal sound" 출력</span>
        
        <span class="nc">Wolf</span> <span class="n">wolf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Wolf</span><span class="o">();</span>
        <span class="nc">WolfAdapter</span> <span class="n">adapter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WolfAdapter</span><span class="o">(</span><span class="n">wolf</span><span class="o">);</span>
        <span class="n">adapter</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// "Howl" 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>JDBC API에 사용된 어댑터 패턴</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
Class.forName() 메서드로 Driver 클래스를 로드한다. 이 클래스는 MySQL 제조사가 제공하는 드라이버이다.
그런다음 DriverManager.getConnection() 메서드를 사용하여 데이터베이스와 연결한다. 
이 메서드는 실제로 Driver 인터페이스를 구현한 객체를 생성하여 Connection 인터페이스와 연결한다.
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// JDBC 드라이버 로드</span>
    <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">);</span>
    
    <span class="c1">// 데이터베이스 연결</span>
    <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost/test"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">user</span> <span class="o">=</span> <span class="s">"user"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>
    <span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/*
JDBC 는 데이터베이스와 연결하기 위해 인터페이스를 제공한다. 데이테베이스 제조사마다 제공하는
드라이버의 인터페이스가 다르기 떄문에 DriverManager클래스에 어댑터 패턴을 사용한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DriverManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">(</span><span class="nc">String</span> <span class="n">url</span><span class="o">,</span> <span class="nc">String</span> <span class="n">user</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 데이터베이스 제조사가 제공하는 드라이버를 찾아서 Driver 인터페이스를 구현한 객체를 생성</span>
        <span class="nc">Driver</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">findDriver</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
        <span class="c1">// Driver 인터페이스를 구현</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="프록시-패턴">프록시 패턴</h2>
<p><strong>Proxy Pattern</strong>
<br />
Proxy 를 사용하여 객체에 대한 접근을 제어하고 간접적으로 제어하는 디자인 패턴이다.
<br />
객체에 대한 직접적인 접근을 대신해 <strong>Proxy 객체</strong> 를 사용해 객체에 접근을 하고 <strong>Proxy 객체</strong> 는
<br />
실제 객체를 대신해 객체의 <strong>대리자 역할</strong> 을 수행하며 객체와 동일한 인터페이스를 제공한다
<br />
Proxy 객체는 실제 객체의 인터페이스를 구현하며, 실제 객체의 메서드를 호출하기전 추가작업을 할 수 있다.</p>

<p><br /></p>

<p><strong><em>객체에 대한 접근을 제어하고 보안, 성능 최적화 등의 추가 기능을 제공하기 위해 사용한다.</em></strong></p>
<ul>
  <li>원격 객체에 대한 접근을 제어하고 네트워크 부하를 줄이기 위해</li>
  <li>복잡한 객체에 대한 접근을 제어하고 메모리 사용량을 줄이기 위해</li>
  <li>객체에 대한 보안적인 제한 및 부가적인 기능을 제공하기 위해</li>
</ul>

<p><br /></p>

<h3 id="trade-off-1">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>객체 생성과 초기화를 지연시킬 수 있어, 성능을 개선할 수 있다.
    <ul>
      <li>원본객체의 생성 또는 초기화에 많은 비용이 들어갈 경우 유용하다.</li>
      <li>실제객체가 원격서버에 있는경우, 프록시객체로 서버접근에 대한 리소스를 줄일 수 있다.</li>
      <li>프록시객체는 원본객체의 인스턴스를 생성하지 않고, 요청이 들어올 경우 생성하고 요청을 처리한다.</li>
    </ul>
  </li>
  <li>실제객체에 대한 접근을 제어할 수 있어, 보안성을 높일 수 있다.
    <ul>
      <li>원본객체가 보안성이 중요할 경우 유용하다.</li>
    </ul>
  </li>
  <li>객체의 메서드의 실행 전후로 추가적인 작업을 수행할 수 있어 유연성이 증가한다.
    <ul>
      <li>이를 통해 로깅, 캐싱, 트랜잭션 등 다양한 처리가 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>프록시 객체는 실제객체에 접근하기 위해 추가적인 리소스가 들어가므로 성능이 저하될 수 있다.</li>
  <li>프록시 객체라는 추가적은 클래스가 필요하고, 이는 복잡성이 증가하고 유지보수를 어렵게 할 수 있다.</li>
  <li>중간에 다른 객체가 끼어있기 때문에 디버깅이 어려워질 수 있어 추가적인 로깅이나 디버깅 작업이 필요하다.</li>
  <li>프록시객체가 실제객체를 대신하기 때문에 실제객체가 생성되지 않아 에상하지 못한 문제가 발생할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="구현-1">구현</h3>

<hr />

<p><strong>정적 프록시 방식</strong>
<br />
프록시 객체를 컴파일 시점에 미리 생성하는 방식</p>
<ul>
  <li>컴파일 시점에 생성되므로 런타임에 추가적인 비용이 발생하지 않는다.</li>
  <li>인터페이스를 구현하는 클래스만 프록시 객체를 생성할 수 있다.</li>
  <li>프록시객체를 수정하려면 컴파일을 다시 해야한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Animal is eating"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
프록시 객체가 구현할 AnimalInterface 인터페이스를 구현한다.
AnimalProxy 클래스는 AnimalInterface 인터페이스를 구현한다.
생성자를 통해 실제 객체를 전달받고, eat() 메서드에서 실제 객체의 eat() 메서드를 호출하기 전에 
수행할 작업과 호출한 후에 수행할 작업을 정의한다.
마지막으로 클라이언트에서 프록시 객체를 생성하고 사용한다.
이를 통해 클라이언트는 실제 객체를 알 필요가 없고, 프록시 객체를 이용해 추가적인 작업을 수행할 수 있다.
*/</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalProxy</span> <span class="kd">implements</span> <span class="nc">AnimalInterface</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalProxy</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before eating"</span><span class="o">);</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After eating"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 클라이언트</span>
<span class="nc">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span>
<span class="nc">AnimalInterface</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnimalProxy</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
<span class="n">proxy</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><strong>동적 프록시 방식</strong>
<br />
프록시 객체를 런타임에 동적으로 생성하는 방식
<br />
일반적으로 유연성이 높고 프록시 객체를 동적으로 수정할 수 있어 더 많이 사용된다.</p>
<ul>
  <li>인터페이스를 구현하지 않은 클래스도 프록시 객체를 생성할 수 있다.</li>
  <li>프록시 객체를 동적으로 수정할 수 있다.</li>
  <li>더 다양한 기능을 수행할 수 있어 AOP 같은 패러다임에 사용하기 적합하다.</li>
  <li>런타임에 프록시객체를 생성하므로, 정적프록시 방식에 비해 성능이 떨어질 수 있다.</li>
  <li>컴파일 시점에 프록시객체를 알수 없어서 디버깅이 어려울 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog is eating."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
AnimalInvocationHandler 클래스는 InvocationHandler 인터페이스를 구현하여 invoke() 메서드를 재정의 한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalInvocationHandler</span> <span class="kd">implements</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalInvocationHandler</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 이 메서드는 실제 객체의 메서드를 호출하기 전후의 실행시간을 출력한다.</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">animal</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Execution time: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ns"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
Dog 객체를 생성한 후 Proxy.newProxyInstance 메서드를 사용해 Animal 인터페이스를 구현하는 동적 프록시 객체를 생성한다.
이때, AnimalInvocationHandler 클래스를 InvocationHandler로 사용한다. 
마지막으로, 프록시 객체의 eat() 메서드를 호출하여 AOP가 적용된 결과를 출력한다.
*/</span>
<span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
<span class="nc">Animal</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Animal</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
    <span class="nc">Animal</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span>
    <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Animal</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span>
    <span class="k">new</span> <span class="nf">AnimalInvocationHandler</span><span class="o">(</span><span class="n">dog</span><span class="o">)</span>
<span class="o">);</span>
<span class="n">proxy</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="데코레이터-패턴">데코레이터 패턴</h2>
<p><strong>Decorator Pattern</strong>
<br />
객체의 기능을 동적으로 추가 / 변경 할 수 있도록 해주는 디자인 패턴이다.
<br />
객체를 래핑하고, 래핑된 객체에 새로운 기능을 추가해 새로운 객체를 생성하는 방식으로 동작한다.
<br />
이렇게 생성된 객체는 래핑된 객체의 기능을 그대로 사용하면서 새로운 기능을 추가한 객체가 된다.
<br />
이를통해, 확장성, 유연성이 높아지고 객체 간의 결합도가 낮아지게 된다.</p>

<p><br /></p>

<p><strong><em>객체를 수정하지 않고 기능을 동적으로 확장하기 위해 사용한다.</em></strong></p>
<ul>
  <li>객체에 대해 동적으로 새로운 기능을 추가하거나 기존 기능을 변경할 필요가 있을 때</li>
  <li>상속으로 인한 클래스의 확장이 어려운 경우에 확장이 필요한 기능을 데코레이터 클래스로 추가할 때</li>
  <li>객체의 수정 없이 기능을 추가하고 싶을 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off-2">trade-off</h3>

<hr />
<p><strong>장점</strong></p>
<ul>
  <li>객체의 기능을 동적으로 추가 / 변경 할 수 있어서 기존 코드를 변경하지 않고 기능을 추가할 수 있다.
    <ul>
      <li>데코레이터 패턴은 <strong>OCP원칙</strong> 을 준수한다.</li>
    </ul>
  </li>
  <li>객체간의 결합도가 낮다.</li>
  <li>객체를 책임별로 분리하기 용이하고 여러개의 데코레이터를 조합해 다양한 기능을 구현할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>새로운 데코레이터 클래스를 만들어야 하기 때문에 클래스가 늘어난다.</li>
  <li>런타임에 객체를 생성하기 때문에 아주 약간의 오버헤드가 발생한다.</li>
  <li>초기 설계에 리소스가 든다.</li>
</ul>

<p><br /></p>

<h3 id="구현-2">구현</h3>

<hr />

<p><strong>인터페이스를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal을 데코레이팅하는 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalDecorator</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">decorate</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// AnimalDecorator를 구현한 구현 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogWithHat</span> <span class="kd">implements</span> <span class="nc">AnimalDecorator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">DogWithHat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decorate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모자를 쓴 강아지"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 기존의 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog1</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>

        <span class="c1">// 모자를 쓴 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="n">dog2</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>추상클래스를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 구현클래스</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal을 데코레이팅하는 데코레이터 추상 클래스</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AnimalDecorator</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalDecorator</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalDecorator를 구현한 Hat 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hat</span> <span class="kd">extends</span> <span class="nc">AnimalDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Hat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모자를 쓴 강아지"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 기존의 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog1</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>

        <span class="c1">// 모자를 쓴 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="n">dog2</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>람다를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"멍멍"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Hat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">decorate</span><span class="o">;</span>  <span class="c1">// 함수형 인터페이스 사용</span>

    <span class="kd">public</span> <span class="nf">Hat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
        <span class="n">decorate</span> <span class="o">=</span> <span class="o">(</span><span class="n">sound</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">sound</span> <span class="o">+</span> <span class="s">", 모자쓴 강아지"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">decorate</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span> <span class="c1">// "멍멍"</span>

        <span class="nc">Animal</span> <span class="n">dogWithHat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dogWithHat</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span> <span class="c1">// "멍멍, 모자쓴 강아지"</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="싱글톤-패턴">싱글톤 패턴</h2>
<p><strong>Singleton Pattern</strong>
<br /></p>

<p><br /></p>

<p><strong><em>애플리케이션에서 단 하나의 인스턴스만을 생성하고 이에 대한 전역적인 접근을 제공하기 위해 사용한다.</em></strong></p>
<ul>
  <li>자원의 공유가 필요한 경우에 여러 객체를 생성하는 것이 비효율적인 경우</li>
  <li>상태를 유지해야 하는 로깅이나 캐싱 등의 객체가 필요한 경우</li>
  <li>불필요한 객체 생성을 방지하고 메모리 사용량을 줄이기 위해 객체를 관리할 필요가 있는 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-3">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<h3 id="구현-3">구현</h3>

<hr />

<p><strong>방식1</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<hr />

<p><strong>방식2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="템플릿-메서드-패턴">템플릿 메서드 패턴</h2>
<p><strong>Template Method Pattern</strong>
<br /></p>

<p><br /></p>

<p><strong><em>상위클래스에서 공통부분을 정의하고 하위클래스에서 그 일부를 구체적으로 구현하기 위해 사용한다.</em></strong></p>
<ul>
  <li>일련의 공통작업이 있지만, 그 중 일부는 하위클래스에서 구현해야 하는 경우
    <ul>
      <li>다양한 구현 방법을 지원하면서 일관성을 유지해야 하는 경우</li>
    </ul>
  </li>
  <li>복잡한 알고리즘을 캡슐화하여 코드의 가독성을 높이고 유지보수를 용이하게 하는 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-4">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<h3 id="구현-4">구현</h3>

<hr />

<p><strong>방식1</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<hr />

<p><strong>방식2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="팩토리-메서드-패턴">팩토리 메서드 패턴</h2>
<p><strong>Factory Method Pattern</strong>
<br /></p>

<p><br /></p>

<p><strong><em>객체 생성을 서브클래스에서 처리하도록 하여 객체 생성 과정을 유연하게 관리하기 위해 사용한다.</em></strong></p>
<ul>
  <li>객체 생성에 필요한 정보가 런타임 시에 결정되는 경우</li>
  <li>객체 생성 방법을 변경해야 할 때 전체 코드를 수정하지 않고 유지보수성을 높이고 싶을 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off-5">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<h3 id="구현-5">구현</h3>

<hr />

<p><strong>방식1</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<hr />

<p><strong>방식2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="전략-패턴">전략 패턴</h2>
<p><strong>Strategy Pattern</strong>
<br /></p>

<p><br /></p>

<p><strong><em>알고리즘을 캡슐화하여 동적으로 교환할 수 있도록 만들어 유연한 애플리케이션을 구현하기 위해 사용한다.</em></strong></p>
<ul>
  <li>런타임 시에 알고리즘을 선택할 필요가 있는 경우</li>
  <li>비슷한 알고리즘을 여러 개 가지고 있고, 이를 쉽게 변경하고 유지보수하고 싶은 경우</li>
  <li>알고리즘의 구현 내용을 클라이언트와 분리하여 의존성을 낮추고 싶은 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-6">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<h3 id="구현-6">구현</h3>

<hr />

<p><strong>방식1</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<hr />

<p><strong>방식2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="템플릿-콜백-패턴">템플릿 콜백 패턴</h2>
<p><strong>Template Callback Pattern</strong>
<br /></p>

<p><br /></p>

<p><strong><em>중복 코드를 줄이고 알고리즘을 캡슐화하여 재사용성과 유지보수성을 높이기 위해 사용한다.</em></strong></p>
<ul>
  <li>알고리즘의 골격을 유지하면서 상세한 구현 부분을 변경할 수 있는 경우
    <ul>
      <li>비슷한 알고리즘에 대해 중복 코드를 줄이면서 구현을 변경하고 싶을 때</li>
    </ul>
  </li>
  <li>다양한 클라이언트 요구사항을 만족시키면서 일관성을 유지해야 하는 경우
    <ul>
      <li>여러 클라이언트 요구사항을 수용하면서 알고리즘을 유지보수 가능한 방식으로 구현하고 싶을 때</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="trade-off-7">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li></li>
  <li></li>
  <li></li>
</ul>

<p><br /></p>

<h3 id="구현-7">구현</h3>

<hr />

<p><strong>방식1</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<hr />

<p><strong>방식2</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="어댑터 패턴" /><category term="프록시 패턴" /><category term="데코레이터 패턴" /><category term="싱글톤 패턴" /><category term="템플릿 메서드 패턴" /><category term="팩터리 메서드 패턴" /><category term="전략 패턴" /><category term="템플릿 콜백 패턴" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">OOP</title><link href="http://localhost:4000/til/OOP/" rel="alternate" type="text/html" title="OOP" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/til/OOP</id><content type="html" xml:base="http://localhost:4000/til/OOP/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="oop">OOP</h1>
<p>어플리케이션을 구성하는 요소들을 객체로 보고, 
<br />
객체들을 유기적으로 연결하여 상호작용하는 방식으로 프로그래밍 하는걸 말한다. 
<br />
데이터와 이를 처리하는 루틴을 하나의 <strong>독립된 객체</strong> 로 보고 기능적으로 관련된 
<br />
데이터와 메서드를 묶는 것을 중심으로 한다.
<br />
재사용성, 유지보수 에 용이하고 대형 프로젝트에 적합하다.
<br />
하지만 속도가 상대적으로 느리고, 설계 시 많은 리소스가 들어간다.</p>

<p><br /></p>

<ul>
  <li><strong>객체</strong>
    <ul>
      <li>속성과 동작을 가진다.</li>
      <li>속성은 객체의 상태를 나타내고, 동작은 객체의 행동을 나타낸다.</li>
      <li>자동차 객체를 예로 들면
        <ul>
          <li>속성 : 색상, 모델, 브랜드 등</li>
          <li>동작 : 가속, 감속, 정지 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>추상화</strong>
    <ul>
      <li>목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>캡슐화</strong>
    <ul>
      <li>정보은닉 - 접근제어자</li>
      <li>코드의 의존성을 줄이고, 결합도를 낮추는 것</li>
      <li>필요한 부분만 외부에 노출시키고 나머지는 숨긴다.</li>
      <li>외부에서 불필요한 의존을 할 일이 없어지고 의존성이 줄어드는 만큼 유지보수도 편해진다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속</strong>
    <ul>
      <li>코드의 재사용성에 이점이 있지만 코드의 재사용성만을 위해 사용은 지양한다.</li>
      <li>흔히 재사용성 뿐 아니라 계층구조 같은 구조를 만들 때 사용하자</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>다형성</strong>
    <ul>
      <li>객체지향의 꽃이라고도 불린다.</li>
      <li>형태가 같지만 다른 기능을 하는 것을 말한다.</li>
      <li>하나의 타입에 여러 객체를 대입할 수 있는 성질이다.
        <ul>
          <li>업캐스팅
            <ul>
              <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 한다.</li>
            </ul>
          </li>
          <li>동적바인딩
            <ul>
              <li>메시지를 수신했을 때 실행도리 메서드가 런타임에 결정된다.</li>
            </ul>
          </li>
          <li>오버로딩</li>
          <li>오버라이딩</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop-왜쓰는데">OOP 왜쓰는데?</h2>
<ul>
  <li><strong>재사용성</strong>
<br />
<br />
클래스와 상속을 사용해 이미 작성된 코드를 쉽게 재사용 할 수 있고,
<br />
이로인해 코드의 일관성을 유지할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>코드의 구조화와 유지보수</strong>
<br />
<br />
객체를 사용해 기능적으로 관련된 데이터와 메서드를 묶어서 관리할 수 있다.
<br />
이로인해 코드의 일관성을 유지할 수 있고,
<br />
새로운 기능이 추가될 때 기존 코드를 변경하지 않아도 되므로 유지보수성을 높일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>캡슐화</strong>
<br />
<br />
객체간의 상호작용을 캡슐화 하여 데이터의 안정성을 유지할 수 있다.
<br />
객체는 자신만의 속성과 동작을 가지고 있으며, 다른 객체와 상호작용 할때 인터페이스를 통해
<br />
메시지를 주고받으므로 데이터가 보호되고, 객체간의 의존성을 줄일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속을 통한 코드 재사용</strong>
<br />
<br />
상속이란 이미 작성된 코드를 확장하거나 변경하여 새로운 클래스를 생성하는 방식이다.
<br />
기존 클래스를 기반으로 함으로 재사용성, 유지보수성을 높일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>다형성</strong>
<br />
<br />
다형성이란 객체가 다양한 형태로 동작할 수 있는 방식이다.
<br />
객체가 동일한 메시지를 받을때, 각각 다르게 동작할 수 있고 이로인해 코드를 유연하게 작성할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>현실세계와의 유사성</strong>
<br />
<br />
현실세계를 반영하므로 코드를 보다 직관적으로 작성할 수 있다.
<br />
예를들어, 자동차 객체를 만들때 자동차의 특징과 동작을 모델링하여 코드를 작성할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>협업</strong>
<br />
<br />
객체는 개별적인 역할과 책임을 가지므로 여러 개발자가 동시에 작업할 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop-단점">OOP 단점</h2>

<ul>
  <li><strong>복잡성</strong>
<br />
<br />
객체지향적인 설계는 추상화를 통해 복잡성을 감추지만, 구현을 위해 많은 코드가 필요하며
<br />
이로인해 코드의 복잡성이 증가할 수 있다.
<br />
또한 어플리케이션이 커질수록 객체 간의 상호작용과 의존성이 많아지고 그럴수록 복잡성은 증가한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>성능</strong>
<br />
<br />
객체를 생성하고 관리하기 위한 추가적인 오버헤드가 있으므로 성능 저하가 발생 할 수 있다.
<br />
또한 캡슐화 때문에 데이터에 접근하기 위한 추가비용이 들어가고 이는 데이터에 직접 접근하는 
<br />
절차지향 프로그래밍 보다 느릴 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>설계</strong>
<br />
<br />
명확한 구조와 규칙을 필요로 하고 객체간의 관계를 적절히 설계해야 하는 등 설계에 많은 리소스가 들어간다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속 남용</strong>
<br />
<br />
상속을 남용하면 중복코드가 생기고 클래스간의 관계가 복잡해질 수 있고 
<br />
하위 클래스가 상위클래스에 의존하게 되어 하위클래스 수정이 상위클래스까지 영향을 미칠 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop의-특징">OOP의 특징</h2>

<p><br /></p>

<h3 id="oop와-캡슐화">OOP와 캡슐화</h3>
<p><br />
객체를 추상화 하고, 객체의 내부 상태와 동작을 외부로부터 보호하는것을 의미한다.
<br />
객체의 내부 구현을 외부에 숨기고, 객체와 객체간의 상호작용을 인터페이스를 통해서 해서
<br />
객체의 상태를 외부에서 변경할 수 없도록 하고, 변경에 대한 책임을 객체 스스로가 갖도록 한다.
<br />
즉, 객체의 구현 세부사항을 숨기고 객체간의 결합도를 낮추는 효과를 가져온다.
<br />
객체의 구현 세부 사항을 숨기는 것을 객체지향설계 에선 <strong>정보은닉</strong> 이라고 부른다.
<br />
상속과 다형성의 개념과도 관련이 있는데,
<br />
부모클래스의 캡슐화된 멤버 변수와 메서드를 재사용할 수 있도록 하고
<br />
캡슐화된 인터페이스를 이용해 서로 다른 객체를 동일한 방식으로 다룰 수 있도록 한다.
<br />
캡슐화는 <strong>OOP</strong> 에서 객체의 추상화, 모듈화, 재사용성 등의 장점을 실현하는데 중요한 역할을 한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-상속">OOP와 상속</h3>
<p><br />
상속이란 부모클래스가 자식클래스에게 자신의 속성과 행위들을 물려주는 것을 의미한다.
<br />
이를 통해 자식클래스는 부모클래스의 기능을 그대로 물려받고, 새로운 속성과 행위를 추가할 수 있다.
<br />
부모 클래스에서 구현한 코드를 자식클래스에서 사용할 수 있으므로 코드의 재사용성이 높아지며
<br />
부모 클래스의 코드를 수정하면 자식클래스에서도 이를 반영하므로 유지보수가 용이해 진다.
<br />
자식클래스는 <strong>오버라이딩</strong> 를 통해 부모클래스의 메서드를 재정의 하여 사용할 수 있고 확장성이 좋아진다.
<br />
<br />
하지만 상속을 남용할 경우, 클래스 간의 복잡한 계층구조가 형성되고 복잡해 지며 유지보수가 어려워 진다.
<br />
또한, 결합도가 높아지기 때문에 부모클래스의 변경이 자식클래스에게도 영향을 미치게 된다.</p>

<p><br />
<strong>상속을 사용할 때</strong>
<br /></p>
<ul>
  <li>부모클래스의 기능을 그대로 사용하면서 새로운 기능을 추가하려는 경우</li>
  <li>부모와 자식클래스 간의 상속관계를 통해 다형성을 구현하려는 경우</li>
  <li>기존 클래스를 수정하지 않고 확장하려는 경우</li>
  <li>공통적인 기능이 있는 클래스들을 만들 때</li>
</ul>

<p><br />
<strong>상속을 사용하지 않을 때</strong>
<br /></p>
<ul>
  <li>계층구조가 복잡할 때</li>
  <li>결합도가 높아질 때</li>
  <li>상속구조가 고정되어 있을때
    <ul>
      <li>이 경우 인터페이스를 이용해 클래스간의 관계를 정의하는 편이 더 나을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>합성(Composition)?</strong>
<br />
<br />
합성은 객체를 조합해 새로운 객체를 만드는 방법이다. 합성을 이용하면 코드의 재사용성을 높이면서
<br />
클래스간의 결합도를 낮출 수 있다. 다른 클래스의 인스턴스를 생성하여 이를 이용하는 방법인데
<br />
상위클래스와 하위클래스 간의 강한 결합을 피할 수 있다.
<br />
상속은 부모와 자식간의 강한 계층구조를 가지지만 합성은 클래스 간의 관계를 느슨하게 유지한다.
<br />
클래스간의 관계를 조정하여 필요한 기능만을 조합하여 사용하기 때문에 클래스간의 결합도가 낮아진다.
<br />
예를들어 자동차 클래스에서 엔진, 타이어, 핸들 클래스를 각각 상속받는게 아니고, 자동차 클래스에서
<br />
엔진, 타이어, 핸들 클래스의 인스턴스를 생성하여 이를 이용하는 방법이다.
<br />
이를통해 자동차, 엔진, 타이어, 핸들 클래스 간의 결합도를 낮출 수 있다.
<br />
<br />
<strong>상속보단 합성?</strong></p>
<ul>
  <li>객체간의 결합도가 낮은 경우 : 객체가 변경되도 다른객체에 영향을 주지 않는다.</li>
  <li>변경이 상위 객체에 영향을 주지 않는 경우 : 객체의 변경에 유연성을 가진다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Engine started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>

    <span class="nc">Car</span> <span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Engine</span> <span class="n">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
        <span class="nc">Car</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
        <span class="n">car</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h4 id="서브클래싱">서브클래싱</h4>
<p><br />
상속을 통해 부모 클래스의 특성을 상속받아 새로운 클래스를 만드는 것을 말한다.
<br />
자식클래스는 부모클래스로부터 상속받은 속성과 메서드를 사용할 수 있고, 
<br />
상속받은 기능을 추가하거나 변경할 수 있다.
<br />
즉, 부모클래스의 기능을 재사용하고, 그 기능을 수정하거나 확장할 수 있다.</p>

<ul>
  <li><strong>장점</strong>
    <ul>
      <li>부모클래스에 구현된 코드로 재사용성을 높임</li>
      <li>서브클래싱으로 같은 인터페이스를 갖는 클래스를 여러개 만들어 다형성을 지원</li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>부모 자식 클래스 간의 강한 결합으로 인한 유지보수의 어려움</li>
      <li>부모클래스의 모든 기능을 상속받기때문에 불필요한 기능 또는 데이터까지 상속받아 객체가 거대해 짐</li>
      <li>서브클래스가 많아 질 수록 클래스간의 계층이 복잡해져서 의존성이 높아지고 가독성과 수정이 어려워짐</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h4 id="서브타이핑">서브타이핑</h4>
<p><br />
상속을 통해 부모클래스와 자식클래스 간의 포함 관계를 정의하는 것을 말한다.
<br />
서브타이핑을 이용하면 자식클래스는 부모클래스의 모든 속성과 메서드를 상속받아 사용할 수 있다.
<br />
또한 자식클래스는 상속받은 특성을 그대로 사용할 수도, 재정의하거나 새로운 메서드를 추가할 수 있다.
<br />
서브타이핑을 통해 부모와 자식클래스 간의 포함 관계를 정의하고, 부모클래스 타입의 변수에 자식클래스
<br />
객체를 할당하여 다형성을 구현하는 다형성의 핵심 개념중 하나이다.
<br />
하지만 부모 자식간의 밀접한 결합이 발생하고, 서브타입 다형성을 사용하면 객체가 어떤 메서드를 호출할지
<br />
런타임에 타입체크를 수행해야 하므로 불필요한 오버헤드가 발생할 수 있다.</p>

<p><br />
<br /></p>

<h4 id="둘의-차이-및-정리">둘의 차이 및 정리</h4>
<p><br />
둘다 객체지향 프로그래밍에서 다형성을 구현하기 위해 사용되는 개념이다.
<br />
<br />
<strong>서브클래싱</strong> 은 부모 클래스에서 상속받은 메서드와 속성을 그대로 사용하면서, 자식클래스에서는
<br />
새로운 기능을 추가하거나 변경하는걸 의미한다. 이는 코드의 재사용성과 확장성을 높이는 역할을 한다.
<br />
<br />
<strong>서브타이핑</strong> 은 부모클래스의 <strong>하위타입</strong> 인 자식클래스를 생성하고, 이를통해 객체의 다형성을 구현하는 것이다.
<br />
즉, <strong>부모클래스의 인스턴스를 자식클래스의 인스턴스로 대체</strong> 할 수 있도록 구현하는 것이다.
<br />
<br />
둘의 가장 큰 차이점은 상속에 대한 의미이다.
<br />
<br />
<strong>서브클래싱</strong> 은 부모 클래스로부터 상속받은 기능을 그대로 사용하면서 기능을 변경하거나 확장하는 것이고,
<br />
클래스의 계층구조를 만들어 코드의 재사용성과 확장성을 높이는데 주로 사용된다.
<br />
<br />
<strong>서브타이핑</strong> 은 부모 자식 클래스 간의 포함관계를 만들어 객체의 다형성을 구현하는것이 목표이다.
<br />
인터페이스와 추상클래스를 사용하여 다형성을 구현하는데 주로 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
서브클래싱
Dog 클래스는 Animal 클래스를 상속받아 eat() 메서드를 사용하면서,
새로운 기능인 bark() 메서드를 추가해서 사용한다.
*/</span>
<span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The animal eats."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog barks."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">bark</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/*
서브타이핑
Animal 인터페이스를 구현한 Dog 클래스에서 eat() 메서드를 구현하고, bark() 메서드를 추가한다.
그리고 Animal 인터페이스를 구현한 Dog 클래스를 생성해 feedAnimal() 메서드에 전달한다.
feedAnimal() 메서드는 Animal 인터페이스 타입의 매개변수를 받기 때문에,
Dog 클래스의 객체를 Animal 인터페이스로 대체할 수 있게 된다.
*/</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog eats."</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog barks."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">feedAnimal</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">feedAnimal</span><span class="o">(</span><span class="n">dog</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-추상화">OOP와 추상화</h3>
<p><br />
<strong>추상화</strong> 는 객체를 설계하는 과정에서 필요한 정보만 선택하고 나머지는 숨겨서 단순하게 만드는걸 말한다.
<br />
<strong>캡슐화</strong> 의 정의와 비슷하지만 <strong>캡슐화</strong> 는 객체의 상태와 행동을 외부로부터 보호하고 객체 간 결합도를 낮추는데
<br />
목적이 있다면, <strong>추상화</strong> 는 객체를 단순화 하여 코드의 가독성과 유지보수성을 높이는데에 목적이 있다.
<br />
<strong>캡슐화</strong> 에선 접근제어자를 사용하지만, <strong>추상화</strong> 에선 인터페이스와 추상클래스를 사용한다.</p>

<ul>
  <li><strong>interface</strong>
    <ul>
      <li>추상메서드와 상수만을 가질 수 있다.</li>
      <li>인터페이스를 구현하는 클래스에선 모든 메서드를 구현해야 한다.</li>
      <li>다중 상속 지원</li>
      <li>
        <p>인터페이스 타입으로 변수 선언 후, 변수에 다양한 구현 객체를 대입할 수 있다.</p>
      </li>
      <li><strong>장점</strong>
        <ul>
          <li>다중상속을 지원해 다양한 클래스 간의 유연한 상호작용 가능</li>
          <li>구현객체간의 관계를 약화시켜 코드의 결합도를 낮출 수 있음</li>
        </ul>
      </li>
      <li><strong>단점</strong>
        <ul>
          <li>인터페이스를 구현하는 클래스에서 모든 메서드를 구현해야 하므로, 코드의 양이 증가</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여러개의 클래스에서 같은 인터페이스를 구현하면, 해당 인터페이스를 모든 코드에서 동일하 게 다룰 수 있다. 즉, 다형성</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="kd">implements</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car start"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car stopp"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Motorcycle</span> <span class="kd">implements</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Motorcycle start"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Motorcycle stopp"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 인터페이스 타입으로 변수를 선언하고, 이 변수에 다양한 구현객체를 대입할 수 있다. 이를 통해 코드의 유연성을 높일 수 있다.</span>
<span class="nc">Vehicle</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span>
<span class="n">car</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">car</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>

<span class="nc">Vehicle</span> <span class="n">motorcycle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Motorcycle</span><span class="o">();</span>
<span class="n">motorcycle</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">motorcycle</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li><strong>abstract class</strong>
    <ul>
      <li>추상메서드와 일반 메서드도 가질 수 있다.</li>
      <li>추상클래스를 구현하는 클래스에선 추상 메서드를 구현해야 한다.</li>
      <li>단일 상속만 지원</li>
      <li>인스턴스 생성 불가</li>
      <li>
        <p>추상클래스 타입으로 변수 선언 후, 변수에 다양한 구현 객체를 대입할 수 있다.</p>
      </li>
      <li><strong>장점</strong>
        <ul>
          <li>공통된 코드를 추상클래스에 구현하여 재사용성을 높일 수 있음</li>
          <li>일반메서드를 포함할 수 있으므로, 공통된 기능을 쉽게 구현할 수 있음</li>
        </ul>
      </li>
      <li><strong>단점</strong>
        <ul>
          <li>단일상속만을 지원해서, 기능확장에 한계가 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="kd">extends</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 자동차 악셀</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 자동차 브레이크</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 추상클래스 타입으로 변수를 선언하고, 이 변수에 다양한 구현객체를 대입할 수 있다.이를 통해 코드의 유연성을 높일 수 있다.</span>
<span class="nc">Vehicle</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span>
<span class="nc">Vehicle</span> <span class="n">motorcycle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Motorcycle</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-다형성">OOP와 다형성</h3>
<p><br />
<strong>다형성</strong> 이란 객체가 동일한 메시지를 받았을 경우, 각각의 객체가 다르게 반응하도록 하는걸 말한다.
<br />
즉, 객체들이 동일한 메서드를 호출할 때, 이 메서드가 각 클래스에 따라 다르게 동작하는 것이다.
<br />
이러면 하나의 메서드가 다양한 형태로 동작하므로 재사용성과 유지보수성이 증가한다.
<br />
여러개의 클래스가 하나의 인터페이스를 구현할 수 있고, 인터페이스에 선언된 메서드는 각 클래스에서
<br />
오버라이딩 되어 동작하므로, 이 인터페이스의 메서드를 호출하는 코드는 각 클래스에 따라 동적으로 변하게 된다.
<br />
<br />
하지만, <strong>다형성</strong> 은 객체의 실제 타입을 런타임에 결정하기 때문에, 컴파일러가 정적으로 최적화 할 수 없어
<br />
성능저하를 가져올 수 있고 런타임 시에 오류가 발생할 수 있다.
<br />
또한 남발되면 객체 생성이 많아지고 코드의 가독성이 떨어지고 디버깅이 힘들어 지게 된다.</p>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop와-getter--setter">OOP와 Getter / Setter</h2>
<p><strong>Getter / Setter</strong> 는 <strong>캡슐화</strong> 의 원칙을 따르는 메서드 이다.
<br />
클래스의 인스턴스 변수에 직접 접근하는 걸 막고 클래스 내부에서 제어를 통해 인스턴스 변수에 접근하도록 한다.
<br />
하지만 과도하게 사용되면 변수에 직접 접근하지 않아도 간접적으로 접근하므로 캡슐화의 장점을 없애게 된다.
<br />
<br />
인스턴스 변수에 직접 접근하는것과 <strong>Getter / Setter</strong> 를 통해 접근하는것과 뭐가 다르냐고 생각할 수 있지만
<br />
인스턴스 변수가 <strong>public</strong> 으로 열려있으면 어디에서든지 접근할 수 있어서 캡슐화에 원칙에 완전히 위배되지만
<br />
<br />
<strong>Getter / Setter</strong> 를 통해 간접적으로 접근을 할 경우 적절한 제어를 통해 캡슐화를 유지할 수 있다.
<br />
여기서 적절한 제어란, <strong>Setter</strong> 에서 유효성 검사를 통해, 잘못된 값이 들어오는 걸 방지하는걸 말한다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="OOP" /><category term="서브클래싱 / 서브타이핑" /><category term="OOP와 상속" /><category term="OOP와 캡슐화" /><category term="OOP와 추상화" /><category term="OOP와 다형성" /><category term="Getter / Setter" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">SOLID</title><link href="http://localhost:4000/til/SOLID/" rel="alternate" type="text/html" title="SOLID" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/til/SOLID</id><content type="html" xml:base="http://localhost:4000/til/SOLID/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="solid">SOLID</h1>
<p>객체지향 프로그래밍에서 소프트웨어 디자인 품질을 향상시키기 위한 다섯 가지 원칙이다.
<br />
이 원칙을 따르면 아래와 같은 장점이 있다.</p>

<ul>
  <li>유지보수성 향상</li>
  <li>재사용성 항샹</li>
  <li>확장성 향상</li>
  <li>변경에 대한 유연성 향상</li>
  <li>코드의 가독성 향상</li>
  <li>결합도 감소</li>
  <li>테스트 용이성 향상</li>
  <li>오류발생 가능성 감소</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="srp---단일-책임-원칙">SRP - 단일 책임 원칙</h2>
<p>하나의 클래스는 하나의 책임을 가져야 한다는 원칙이다.
<br />
이것은 클래스가 변경되어야 하는 이유는 단 하나여야 함을 의미한다.
<br />
클래스의 응집력은 높이고 결합도는 낮춰서 유지보수, 재사용성, 확장성에 용이하게 하는 원칙으로, 
<br />
클래스 하나가 여러 책임을 가지게 되면 그 클래스를 변경해야 하는 이유도 여러가지가 생기므로, 
<br />
코드를 변경할때 다른 책임과 관련된 코드까지 함께 변경해야 한다. 
<br />
<br />
<strong>SRP</strong> 원칙을 지키기 위해서는 클래스가 자신의 책임을 명확하게 정의하고, 
<br />
다른 책임을 수행하는 클래스와의 의존성을 최소화 해야한다.
<br />
<br />
<strong>단점으로는</strong> 클래스와 인터페이스 수가 늘어나게 되고 클래스간의 상호작용을 복잡하게 만들 수 있다.
<br />
<br />
자바에서 <strong>SRP</strong> 를 구현하는 방식에는 <strong>클래스를 단일책임으로 분리</strong>, 
<br />
<strong>인터페이스를 이용해 책임을 분리</strong>, <strong>디자인패턴</strong>, <strong>AOP</strong> 등이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>클래스를 단일 책임으로 분리하는 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Order 클래스는 너무 많은 책임을 가지고 있다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Customer</span> <span class="n">customer</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// 클래스의 책임을 분리함으로써, 클래스간 의존성이 낮아지게 된다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderItem</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Item</span> <span class="n">item</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCalculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderItem</span><span class="o">&gt;</span> <span class="n">orderItems</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>인터페이스로 책임을 분리하는 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 상품 목록을 관리하는 ItemManager 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 이메일을 전송하는 EmailSender 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ItemManager 인터페이스를 구현하는 ItemManagerImpl 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemManagerImpl</span> <span class="kd">implements</span> <span class="nc">ItemManager</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// EmailSender 인터페이스를 구현하는 EmailSenderImpl 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSenderImpl</span> <span class="kd">implements</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="ocp---개방--폐쇄-원칙">OCP - 개방 / 폐쇄 원칙</h2>
<p>소프트웨어 구성요소 (클래스, 모듈, 함수 등) 는 확장에는 열려있어야 하지만, 변경에는 닫혀 있어야 한다. 
<br />
즉, 기존의 코드를 변경하지 않아도 새로운 기능을 추가할 수 있도록 하는 것이다.
<br />
<strong>OCP</strong> 는 다형성, 추상화, 인터페이스 등을 통해 내부 구현을 외부로 노출시키지 않고도 기능을 확장할 수 있는데
<br />
이는 코드의 유지보수, 확장성, 재사용성 등을 향상시킬 수 있다.
<br />
<br />
<strong>단점으로는</strong> 초기 설계와 인터페이스 설계등의 리소스가 많이 들어가게 되며 OCP를 적용하기 위해 
<br />
인터페이스와 추상화를 사용해 내부의 세부 구현사항을 숨기게 되면 코드의 복잡성이 증가하게 된다.
<br />
<br />
자바에서 <strong>OCP</strong> 를 구현하는 방식에는 
<br />
<strong>추상클래스 / 인터페이스</strong>, <strong>전략패턴</strong>, <strong>팩토리 메서드 패턴</strong>, <strong>데코레이터 패턴</strong> 등이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>추상클래스를 이용한 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 새로운 동물인 고양이를 이렇게 기존 코드를 변경하지 않고 확장할 수 있다. Cat 클래스는 Animal 타입으로 선언될 수 있고,</span>
<span class="c1">// Animal 타입으로 다루어 질때 makeSound() 메서드가 호출된다.</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>인터페이스를 이용한 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 기존의 코드를 변경하지 않고 Cat 클래스를 확장</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="lsp---리스코프-치환-원칙">LSP - 리스코프 치환 원칙</h2>
<p>하위타입은 상위타입으로 대체 가능해야 한다는 원칙이다. 
<br />
상속관계에서 부모클래스에 선언된 속성과 메서드는 하위클래스에서 동일하게 동작해야 한다.
<br />
즉, <strong>하위클래스가 상위클래스의 기능을 정확하게 대체할 수 있어야 한다.</strong>
<br />
<strong>LSP</strong> 는 유연한 확장, 재사용성 등에 장점이 있다.
<br />
<br />
<strong>단점으로는</strong> 설계에 리소스가 들어가게 되며 <strong>LSP</strong> 는 인터페이스와 상속관계에서만 적용할 수 있다.
<br />
<br />
자바에서 <strong>LSP</strong> 를 구현하는 방식에는 <strong>인터페이스</strong>, <strong>상속</strong> 이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>LSP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span> 
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BigDog</span> <span class="kd">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Big bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging at speed "</span> <span class="o">+</span> <span class="n">speed</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
BigDog 클래스의 wagTail() 메서드는 Dog 클래스의 wagTail() 메서드와
시그니처가 다르기 때문에 에러가 발생한다.
즉, BigDog 객체가 Dog 객체를 완벽하게 대체하지 못한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">bigDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDog</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">();</span>  <span class="c1">// 컴파일 에러 발생</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>LSP 를 준수한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BigDog</span> <span class="kd">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Big bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">wagTail</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging at speed "</span> <span class="o">+</span> <span class="n">speed</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Dog 클래스와 BidDog 클래스 모두 같은 wagTail() 메서드를 가지게 된다.</span>
<span class="c1">// Dog 객체를 대신하여 BigDog 객체를 사용할 때 문제가 일어나지 않는다.</span>
<span class="c1">// 즉, 부모클래스를 자식클래스로 대체해도 동일한 기능을 수행해서 LSP를 준수한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BigDog</span> <span class="n">bigDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDog</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="isp---인터페이스-분리-원칙">ISP - 인터페이스 분리 원칙</h2>
<p>인터페이스 분리 원칙을 의미한다.
<br />
즉, 인터페이스가 클라이언트에서 필요한 메서드만 가지도록 권장한다.
<br />
이렇게 함으로써 클라이언트 입장에선 필요하지 않은 메서드를 호출하거나
<br />
구현할 필요가 없게되고, 이것은 의존성을 줄이고 유지보수, 재사용성을 증가시킨다.
<br />
<br />
<strong>단점으로는</strong> <strong>인터페이스</strong> 와 <strong>클래스</strong> 가 많아지는 문제가 있다.</p>

<p><br /></p>

<ul>
  <li><strong>ISP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">fly</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bird</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="cm">/*
Bird 클래스는 run() 메서드를 구현하지 않고, Dog 클래스는 fly() 메서드를 구현하지 않는다.
이것은 필요하지 않은 메서드를 구현체에서 구현하기 때문에 ISP 원칙을 위반한다.

Animal 인터페이스를 run() 메서드와 fly() 메서드를 각각 가지는 2개의 인터페이스로 분리하면
ISP 원칙을 준수할 수 있다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">bird</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Bird</span><span class="o">();</span>
        <span class="n">bird</span><span class="o">.</span><span class="na">fly</span><span class="o">();</span>
        
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">fish</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="dip---의존관계-역전-원칙">DIP - 의존관계 역전 원칙</h2>
<p>상위모듈이 하위모듈에게 의존하면 안되며 둘다 추상화에 의존해야 한다는 원칙이다.
<br />
즉, 클래스는 다른 클래스에 의존하지말고 추상화를 통해 상호작용 해야 한다는 의미이다.
<br />
이것은 결합도를 낮추기 위한 방식으로 객체간의 의존성을 느슨하게 만드는 효과가 있다.
<br />
<strong>DIP</strong> 를 준수하면 하위 모듈이 변경되어도 상위 모듈에 영향이 없으므로 유연성과 확장성이 향상된다.
<br />
<br />
<strong>단점으로는</strong> 추상화를 위한 <strong>인터페이스</strong> 와 <strong>추상클래스</strong> 가 많아지고 복잡성이 증가한다.</p>

<p><br /></p>

<ul>
  <li><strong>DIP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UserRepository</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// UserRepository 에 직접 의존하고 있으므로 UserRepository 클래스의 변경이 UserService 에게 영향을 준다.</span>
<span class="kd">class</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>DIP 를 준수한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
UserService 클래스는 UserRepository 인터페이스에만 의존하도록 하고 생성자를 통해 주입받는다.
이제 UserRepository 클래스의 구현체인 DatabaseUserRepository 클래스가 UserRepository 인터페이스를 구현하도록 해서 DatabaseUserRepository 클래스가 변경되더라도 UserService 클래스에 영향을 미치지 않는다.
*/</span>
<span class="kd">class</span> <span class="nc">DatabaseUserRepository</span> <span class="kd">implements</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="책임이란">책임이란?</h2>
<p>객체가 수행하는 역할 또는 기능을 말한다. <strong>책임은 객체의 상태와 행위를 결정한다.</strong>
<br />
<strong>SOLID원칙</strong> 에서 책임은 객체나 모듈은 단 한가지의 책임을 가져야 하고 
<br />
이 객체나 모듈이 변경될 이유는 단 하나여야만 한다.
<br />
즉, 변경이 일어날 때 해당 객체만을 수정하면 단일책임원칙을 따르는 것이고 해당 객체 뿐만이 아니라
<br />
다른객체 까지 수정이 일어나면 단일책임원칙을 준수하지 못한것이다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="SRP" /><category term="OCP" /><category term="LSP" /><category term="ISP" /><category term="DIP" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">8 Week</title><link href="http://localhost:4000/til/8%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="8 Week" /><published>2023-02-02T00:00:00+09:00</published><updated>2023-02-02T00:00:00+09:00</updated><id>http://localhost:4000/til/8%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/8%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="data-binding">Data Binding</h1>
<p>분리된 <strong>View</strong> 와 <strong>Model</strong> 을 하나로 묶어 두개의 데이터 소스를 연결하고 동기화 하는 기술이다.
<br />
<strong>Data Binding</strong> 은 대표적으로 단방향 데이터 바인딩과 양방향 데이터 바인딩으로 나뉜다.
<br />
<br />
백엔드 개발자에게 익숙한 <strong>MVC 패턴</strong> 은 <strong>View</strong> 대신 <strong>json</strong> 을 사용한다고 볼 수 있다.
<br />
프론트에선 요즘은 <strong>MVVM 패턴</strong> 을 자주 사용하는데 여기서 <strong>Data Binding</strong> 을 활용한다.</p>

<p><br /></p>

<ul>
  <li><strong>단방향 데이터 바인딩</strong>
    <ul>
      <li><strong>event</strong> 를 통해 데이터 흐름이 단방향으로 이루어 진다. (부모 -&gt; 자식)</li>
      <li><strong>View</strong> 가 바로 업데이트 되지 않는다.</li>
      <li><strong>양방향 데이터 바인딩</strong> 보다 리소스가 적게 든다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>양방향 데이터 바인딩</strong>
    <ul>
      <li>데이터 변경에 따라 프레임워크를 통해 양방향으로 이루어 진다. (부모 &lt;-&gt; 자식)</li>
      <li><strong>View</strong> 가 즉시 업데이트 된다.</li>
      <li><strong>단방향 데이터 바인딩</strong> 보다 리소스가 많이 든다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
웹 애플리케이션의 복잡도가 갈수록 향상되면서 브라우저 메모리가 
<br />
자바스크립트 객체와 화면에 있는 데이터를 맞추는데 큰 어려움이 생기고 있다.
<br />
이러한 상황을 쉽게 해결 해주기 위해 <strong>Data Binding</strong> 을 사용한다.
<br />
대표적인 프론트엔드 프레임워크인 <strong>Angular, React, Vue</strong> 모두 
<br />
<strong>Data Binding</strong> 을 지원하는데 상황에 따라 적절하게 쓰면 되겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="oop">OOP</h1>
<p>어플리케이션을 구성하는 요소들을 객체로 보고, 객체들을 유기적으로 연결하여 프로그래밍 하는걸 말한다.
<br />
데이터와 이를 처리하는 루틴을 하나의 <strong>독립된 객체</strong> 로 본다.
<br />
재사용성, 유지보수 에 용이하고 대형 프로젝트에 적합하다.
<br />
하지만 속도가 상대적으로 느리고, 설계 시 많은 리소스가 들어간다.</p>
<ul>
  <li><strong>추상화</strong>
    <ul>
      <li>목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념</li>
    </ul>
  </li>
  <li><strong>캡슐화</strong>
    <ul>
      <li>정보은닉 - 접근제어자</li>
      <li>코드의 의존성을 줄이고, 결합도를 낮추는 것</li>
      <li>필요한 부분만 외부에 노출시키고 나머지는 숨긴다.</li>
      <li>외부에서 불필요한 의존을 할 일이 없어지고 의존성이 줄어드는 만큼 유지보수도 편해진다.</li>
    </ul>
  </li>
  <li><strong>상속</strong>
    <ul>
      <li>코드의 재사용성에 이점이 있지만 코드의 재사용성만을 위해 사용은 지양한다.</li>
      <li>흔히 재사용성 뿐 아니라 계층구조 같은 구조를 만들 때 사용하자</li>
    </ul>
  </li>
  <li><strong>다형성</strong>
    <ul>
      <li>객체지향의 꽃이라고도 불린다.</li>
      <li>형태가 같지만 다른 기능을 하는 것을 말한다.</li>
      <li>하나의 타입에 여러 객체를 대입할 수 있는 성질이다.
        <ul>
          <li>업캐스팅
            <ul>
              <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 한다.</li>
            </ul>
          </li>
          <li>동적바인딩
            <ul>
              <li>메시지를 수신했을 때 실행도리 메서드가 런타임에 결정된다.</li>
            </ul>
          </li>
          <li>오버로딩</li>
          <li>오버라이딩</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="oop-왜쓰는데">OOP 왜쓰는데?</h2>

<p><br /></p>

<h2 id="oop와-상속">OOP와 상속</h2>

<p><br /></p>

<h2 id="oop와-추상화">OOP와 추상화</h2>
<p>책에서는 모델링이라고 설명한다.
<br />
대상에 집중하지말고 문제에 집중을 하면 올바른 추상화에 가까이 갈 수 있다.
<br />
대상은 문제를 풀기 충분한 정도의 속성만 가지고 있으면 되고, 이 문제를 푸는데 불필요한 
<br />
속성은 제거하는 편이 낫다.</p>

<p><br /></p>

<h2 id="oop와-캡술화">OOP와 캡술화</h2>

<p><br /></p>

<h2 id="oop와-getter--setter">OOP와 Getter / Setter</h2>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Data Binding" /><category term="OOP" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">7 Week</title><link href="http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="7 Week" /><published>2023-01-26T00:00:00+09:00</published><updated>2023-01-26T00:00:00+09:00</updated><id>http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="jdbc">JDBC</h1>
<h2 id="jdbc의-정의">JDBC의 정의</h2>
<p>데이터베이스 접근기술</p>

<p><br /></p>

<h2 id="jdbc-driver">JDBC Driver</h2>
<p>서로 다른 디비들에 대한 연결방법이 모두 다르기 때문에 거기에 대응하기 위해서 사용한다.
<br />
결국 디비가 서로 다르고 다른 연결방식 이어도 모두 같은방식으로 다루고 싶고
<br />
또한 프로그래밍 단에서는 하나의 방식으로 사용하고 싶기 때문에 사용한다.</p>

<p><br /></p>

<h2 id="jdbc-api">JDBC API</h2>
<p>드라이버가 매꿔준 걸 이용해서 같은방식으로 디비에 대한 접근을 제공하는 <strong>인터페이스</strong>
<br />
API는 <code class="language-plaintext highlighter-rouge">Application Programming Interface</code>의 약자이고
<br />
<code class="language-plaintext highlighter-rouge">JDBC API</code>란 여기에 접근하기 위해 추상적으로 공개한 루트이다.
<br />
이것도 결국 프로그래밍 단에서 다른걸 신경쓰지 않고 하나의 방법으로 사용하고 싶기 때문</p>

<p><br /></p>

<h2 id="connection-pool">Connection Pool</h2>
<p>데이터베이스에 대한 커넥션을 미리 생성해두고 재사용 하기 위한 방법
<br />
어플리케이션 시작 시점에 필요한 만큼의 커넥션을 미리 확보해서 풀에 보관한다.
<br />
<br />
<br />
<strong>왜쓰는데?</strong>
<br /></p>

<p>DB Driver는 데이터베이스와 <strong>TCP/IP</strong> 커넥션을 연결하는데, 이 과정에서 <code class="language-plaintext highlighter-rouge">3 way handshake</code> 같은
<br /> 
네트워크 동작이 발생하게 된다.
<br />
<code class="language-plaintext highlighter-rouge">3 way handshake</code> 는 <strong>Network Pass</strong> 를 확보하는데 3번의 통신을 해야 서로가 신뢰를
<br />
가지고 <strong>Pass</strong> 를 확정하기 때문에 이 과정에서 시간이라는 리소스가 많이 들어가게 된다.
<br />
비용적인 측면에서 <strong>느린거로</strong>는 네트워크가 압도적이기 때문에 <code class="language-plaintext highlighter-rouge">Connection Pool</code> 을 사용한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvc">MVC</h1>
<p>어플리케이션을 <strong>Model-View-Controller</strong> 의 세가지 컴포넌트로
<br />
각각 담당하는 역할을 구분한 디자인패턴</p>
<ol>
  <li>사용자가 입력을 담당하는 <strong>View</strong> 를 통해 요청을 보낸다.</li>
  <li>해당 요청을 <strong>Controller</strong> 가 받고 <strong>Model</strong> 을 통해 데이터를 가져온다.</li>
  <li>해당 데이터를 바탕으로 출력을 담당하는 <strong>View</strong> 를 통해 사용자에게 전달한다.
<br />
MVC패턴은 모델1과 모델2가 있다.</li>
</ol>

<ul>
  <li>모델 1
    <ul>
      <li>JSP에서 출력과 로직을 전부 담당</li>
      <li>사용자 요청을 JSP가 <code class="language-plaintext highlighter-rouge">JavaBean Service Class</code> 를 사용해 전부 처리</li>
      <li>빠르고 쉽게 개발할 수 있지만 유지보수맟 확장에 어려움</li>
    </ul>
  </li>
  <li>모델 2
    <ul>
      <li>JSP에서 출력만 담당</li>
      <li>사용자 요청을 서블릿이 받음</li>
      <li>설계가 어렵지만 분업이 가능하며 유지보수 및 확장에 용이</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Model</strong></p>
<ul>
  <li>어플리케이션의 정보, 데이터 등을 담당하고 정보들의 가공을 책임지는 컴포넌트</li>
  <li>비즈니스 로직 처리</li>
  <li>편집하기 원하는 모든 데이터를 가지고 있어야 한다.</li>
  <li>변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.</li>
  <li><strong>View / Controller</strong> 에 대해 의존하지 말아야 한다.</li>
</ul>

<p><br /></p>

<p><strong>View</strong></p>
<ul>
  <li>데이터의 입력과 보여지는 출력을 담당</li>
  <li><strong>Model</strong> 의 정보를 가지고 있지 말아야 한다.</li>
  <li>변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.</li>
  <li><strong>Model / Controller</strong> 에 의존하지 말아야 한다.</li>
</ul>

<p><br /></p>

<p><strong>Controller</strong></p>
<ul>
  <li><strong>Model / View</strong> 의 중간다리 역할을 한다.</li>
  <li>요청에 대해 해당 요청을 담당하는 <strong>Model</strong> 을 호출한다.</li>
  <li><strong>Model</strong> 의 작업결과를 리턴받아 <strong>View</strong> 에게 전달한다.
    <ul>
      <li><strong>Model / View</strong> 에 대해 알고있어야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Web에 적용할 시</strong></p>
<ol>
  <li>유저가 웹사이트에 접속</li>
  <li><strong>Controller</strong> 는 접속요청에 대해 <strong>Model</strong> 호출</li>
  <li><strong>Model</strong> 은 디비나 파일같은 데이터를 비즈니스 로직을 통해 처리 후 리턴</li>
  <li><strong>Controller</strong> 는 리턴받은 결과를 <strong>View</strong> 에 전달</li>
  <li>리턴받은 결과는 <strong>View</strong> 를 통해 유저에게 보여짐</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
사용자 <strong>UI / 비즈니스 로직 / 중간다리</strong> 이렇게 3가지로 구분하여 어플리케이션을
<br />
설계하면 각각 자신의 역할에만 집중할 수 있다.
<br />
이로인해 유지보수, 확장성, 유연성이 증가하고 중복을 줄일 수 있다.</p>

<p><br /></p>

<p><strong>단점</strong>
<br />
<br />
설계에 리소스가 들어간다. 예를들어</p>
<ul>
  <li><strong>Model / View</strong> 가 다른 컴포넌트 들에게 독립적이게 설계하는 것</li>
  <li><strong>Model</strong> 의 설계를 잘해야 변경에 유연할 수 있는것
<br /></li>
</ul>

<p>제대로 설계를 하지 않으면 <strong>View</strong> 와 <strong>Model</strong> 의 분리가 어려운데
<br />
<strong>Controller</strong> 를 통해 하나의 View에 연결될 수 있는 <strong>Model</strong> 도 여러 개가 될 수 있어
<br />
<strong>View</strong> 와 <strong>Model</strong> 이 서로 의존성을 띄게 될 수 있다.
<br />
즉, <strong>Controller</strong> 하나에 다수의 <strong>Model / View</strong> 가 복잡하게 얽히는 상황이 일어날 수 있다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvp">MVP</h1>
<p><strong>Model-View</strong> 는 <strong>MVC</strong> 패턴과 동일하고 <strong>Controller</strong> 대신 <strong>Presenter</strong> 가 존재하는 패턴
<br />
<strong>MVC</strong> 패턴 과 다른 핵심적인 설계는 <strong>View</strong> 와 <strong>Model</strong> 을 완전히 분리하고 서로간의 상호작용을
<br />
<strong>Presenter</strong> 에게 위임하여 서로의 의존성을 최소화 하는데 있다.</p>
<ul>
  <li><strong>Presenter</strong>
    <ul>
      <li><strong>View</strong> 와 <strong>Model</strong> 의 <strong>인스턴스</strong> 를 가지고 있다.</li>
      <li><strong>Presenter</strong> 와 <strong>View</strong> 는 1:1 관계이다.</li>
      <li><strong>View</strong> 에 직접 연결되는게 아니라 인터페이스를 통해 상호작용 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>동작</strong></p>
<ol>
  <li>사용자 요청은 <strong>View</strong> 를 통해 들어옴</li>
  <li><strong>View</strong> 는 데이터를 <strong>Presenter</strong> 에 요청</li>
  <li><strong>Presenter</strong> 는 <strong>Model</strong> 에게 데이터 요청</li>
  <li><strong>Model</strong> 은 <strong>Presenter</strong> 에게 요청받은 데이터 응답</li>
  <li><strong>Presenter</strong> 는 <strong>View</strong> 에게 데이터를 응답</li>
  <li><strong>View</strong> 는 <strong>Presenter</strong> 가 응답한 데이터를 사용해 화면을 나타냄</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<strong>Presenter</strong> 를 통해서만 데이터를 전달 받기 때문에 <strong>View-Model</strong> 간의 의존성이 없다.
<br />
<strong>View-Model</strong> 을 분리시켜 <strong>View</strong> 와 비즈니스 로직이 완전히 분리되어 MVC 패턴에서 
<br />
하기 힘든 테스트가 쉬워졌다.
<br />
<strong>View-Model</strong> 간의 의존성은 해결되었지만 반대로 <strong>Presenter</strong> 를 통해서만 Data를 전달받기 때문에
<br />
<strong>View-Presenter</strong> 간의 의존성이 높아지고 <strong>Controller</strong> 대신 <strong>Presenter</strong> 가 복잡해 진다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvvm">MVVM</h1>
<p>Command 패턴과 Data Binding 이라는 두 가지 패턴을 사용하여 구현되었다.
<br />
Command 패턴과 Data Binding을 이용하여 <strong>View</strong> 와 <strong>View Model</strong> 사이의 의존성을 없앰
<br />
<strong>Model-View</strong> 는 <strong>MVC</strong> 패턴과 동일하고 <strong>Controller</strong> 대신 <strong>View Model</strong> 이 존재한다.</p>
<ul>
  <li><strong>View Model</strong>
    <ul>
      <li><strong>View</strong> 를 표현하기 위해 만든 <strong>View</strong> 를 위한 <strong>Model</strong> 이다.</li>
      <li><strong>View</strong> 에서 필요로 하는 데이터 처리와 비즈니스 로직을 수행한다.</li>
      <li><strong>View Model</strong> 과 <strong>View</strong> 의 관계는 <strong>1:N</strong> 관계이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li><strong>Data Binding?</strong>
    <ul>
      <li><strong>Model</strong> 과 <strong>UI</strong> 요소간의 싱크를 맞추는 것</li>
      <li>이 패턴을 통해 <strong>View</strong> 와 로직이 분리되어 있어도 한쪽이 바뀌면 다른쪽도 
  <br />
  업데이트가 이루어져 데이터의 일관성을 유지할 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>동작</strong></p>
<ol>
  <li>사용자 요청은 <strong>View</strong> 를 통해 들어옴</li>
  <li><strong>View</strong> 는 Command 패턴으로 <strong>View Model</strong> 에게 요청 전달</li>
  <li><strong>View Model</strong> 은 <strong>Model</strong> 에게 데이터 요청</li>
  <li><strong>Model</strong> 은 <strong>View Model</strong> 에게 요청받은 데이터 응답</li>
  <li><strong>View Model</strong> 은 응답받은 데이터를 가공하여 저장</li>
  <li><strong>View</strong> 는 <strong>View Model</strong> 과 <strong>Data Binding</strong> 하여 화면을 나타냄</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<strong>View-Model</strong> 간의 의존성이 없다. 
<br />
Command 패턴과 Data Binding을 사용하여 <strong>View-View Model</strong> 간의 의존성 또한 없앤 디자인패턴 
<br />
각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있는 장점이 있다.
<br />
하지만 <strong>View Model</strong> 의 설계가 쉽지 않고 Data Binding 이 필수로 요구되는 단점이 있다.
<br />
또한 어플리케이션이 복잡해 질수록 <strong>View Model</strong> 이 거대해진다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="정리">정리</h1>
<p>이 패턴들의 공통적인 특징이자 장점은 처리결과를 화면에 보여주는 로직과 실제 데이터가
<br />
처리되는 로직을 분리 하는 것이다. 정답은 없고 상황에 맞게 적절히 응용하여 사용하는것이 중요하다.
<br />
구조의 단위가 화면인지 컴포넌트인지에 따라 선택하는 것도 좋은 방법이다.</p>

<p><br /></p>

<p><strong>MVC</strong></p>
<ul>
  <li><strong>Model</strong> 과 <strong>View</strong> 로직이 상호간에 의존적이다.</li>
  <li><strong>Controller</strong> 에 의해 특정 <strong>Model</strong> 에 따라 데이터가 처리되면 사전에 정의된 <strong>View</strong> 를 반환해 준다.</li>
</ul>

<p><br /></p>

<p><strong>MVP</strong></p>
<ul>
  <li>사용자 입력을 <strong>View</strong> 에서 직접 받고 <strong>Presenter</strong> 와 상호작용 하는 차이가 있다.</li>
  <li><strong>View</strong> 는 <strong>Presenter</strong> 와만 통신하므로 <strong>Model</strong> 에 대해 알 필요가 없다.
    <ul>
      <li>결과적으로 <strong>Model-View</strong> 간의 의존성이 사라진다.</li>
    </ul>
  </li>
  <li><strong>View</strong> 와 <strong>Presenter</strong> 간의 강한 <strong>1:1</strong> 의존관계가 있다는 단점이 존재한다.</li>
</ul>

<p><br /></p>

<p><strong>MVVM</strong></p>
<ul>
  <li><strong>View</strong> 를 표현하기 위해 만들어진 <strong>View</strong> 만을 위한 <strong>Model</strong> 인 <strong>View Model</strong> 을 사용한다.</li>
  <li><strong>View</strong> 로 전달된 입력에 의해 <strong>Command 패턴</strong>에 따라 <strong>View Model</strong> 에 명령을 내리고, 
<br />
데이터가 변화하면 그것에 따라 <strong>Data Binding</strong> 된다.
    <ul>
      <li><strong>View</strong> 와 <strong>View Model</strong> 간의 의존성은 사라진다.</li>
    </ul>
  </li>
  <li><strong>Binding</strong> 기술 등이 프레임워크 특화이기 때문에 다른 프레임워크 로의 재사용은 어렵다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="MVC" /><category term="MVP" /><category term="MVVM" /><category term="JDBC" /><category term="Connection Pool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">6 Week</title><link href="http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="6 Week" /><published>2023-01-19T00:00:00+09:00</published><updated>2023-01-19T00:00:00+09:00</updated><id>http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="web">Web</h1>
<p>아래 내용들을 무엇이다 라고 정의해보려고 했는데 명쾌하게 떠오르지 않았다.
<br />
이참에 한번 짚고 넘어가자.
<br />
<br />
<br />
<strong>World Wide Web</strong>
<br />
<br />
인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간</p>

<ul>
  <li>텍스트, 그림, 소리, 영상 등의 멀티미디어 정보를 하이퍼텍스트 방식으로 연결
    <ul>
      <li>하이퍼텍스트 : 문서 내부에 또다른 문서가 연결되는 참조를 넣음</li>
    </ul>
  </li>
</ul>

<p>웹페이지들은 각각 연결되어 있는데 이로 인해 거미줄처럼 얽혀있는 정보의 모음이라고도 불림</p>

<p><br /></p>

<p><strong>웹페이지</strong>
<br />
<br />
정보제공을 목적으로한 <code class="language-plaintext highlighter-rouge">정적</code>인 사이트
<br />
수동적으로 정보를 관람함</p>

<p><br /></p>

<p><strong>웹어플리케이션</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">동적</code>기능을 가진 웹으로 상호작용을 통해 유저가 
<br />
능동적으로 어플리케이션 상의 서비스를 이용하는것을 목적으로 함</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="browser-rendering">Browser Rendering</h1>

<p><br /></p>

<h2 id="ssr">SSR</h2>
<p><strong>서버사이드 렌더링 - Server Side Rendering</strong>
<br />
서버로부터 완전하게 만들어진 <code class="language-plaintext highlighter-rouge">HTML</code>  파일을 받아오는 방식
<br />
렌더링이 서버에서 일어난다.
<br /></p>
<ul>
  <li><strong>동작</strong>
    <ol>
      <li>클라이언트가 요청을 보냄</li>
      <li>서버는 <code class="language-plaintext highlighter-rouge">HTML</code> 에 데이터, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">JS</code> 를 렌더링하여 컴파일 후 보낸다.</li>
      <li>클라이언트는 즉시 <code class="language-plaintext highlighter-rouge">HTML</code> 을 먼저 렌더링 하고 그 후 <code class="language-plaintext highlighter-rouge">JS</code> 코드를 받아 실행한다.
<br />
<br /></li>
    </ol>
  </li>
  <li><strong>장점</strong>
    <ul>
      <li>빠른 초기 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">HTML</code> 안에 모든 데이터가 포함되어 있어 검색엔진에 노출이 잘됨 (크롤링)
<br />
<br /></li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>요청시마다 새로고침 (깜빡임)</li>
      <li>서버부하 (작은 변경이라도 서버에서 모든걸 다시 받아옴)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="csr">CSR</h2>
<p><strong>클라이언트 사이드 렌더링 - Client Side Rendering</strong>
<br />
사용자에 요청에 따라 필요한 부분만 응답받아 렌더링 하는 방식
<br />
렌더링이 클라이언트 쪽에서 일어난다.
<br /></p>
<ul>
  <li><strong>동작</strong>
    <ol>
      <li>클라이언트에서 초기화면을 로드하기 위해 서버에 요청을 보냄</li>
      <li>서버는 화면에 표시하는데 필요한 완전한 리소스 응답
<br />
<br /></li>
    </ol>
  </li>
  <li><strong>장점</strong>
    <ul>
      <li>빠른속도 (초기화면 렌더링X)</li>
      <li>서버부하 감소 (클라이언트에서 변경부분만 요청)</li>
      <li>유저경험 증가 (깜빡임)
<br />
<br /></li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>초기화면 로딩 느림 (<code class="language-plaintext highlighter-rouge">JS</code>포함 모든 파일을 받아야 함)</li>
      <li>검색엔진에 노출이 잘 안됨 (<code class="language-plaintext highlighter-rouge">HTML</code> 자체는 깡통이므로)</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="http의-전송방식">HTTP의 전송방식</h1>
<p><code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">POST</code> 등의 전송방식이 있지만 모두 텍스트 형식이다.
<br />
HTTP 전송방식에 왜 텍스트를 사용했을까?</p>
<ul>
  <li>다양한 환경에 맞는 (범용적, 유연함) 규약이 필요했다.</li>
  <li>왜나햐면 <code class="language-plaintext highlighter-rouge">Web</code>은 말그대로 전세계 모든 사람이 이용하는, 엄창나게 많은 곳에서 쓰인다.</li>
  <li>일단 텍스트는 눈으로 보고 어느정도 의미를 유추할 수 있고</li>
  <li>클라이언트에 상황에 구애받지 않는 텍스트가 가장 보편적이었다.</li>
  <li>따라서 바이트코드나 비트같이 가볍지만 제약이 따르는 것들 대신 보편적인 텍스트를 쓰는것이다.</li>
</ul>

<p><br /></p>

<p><strong>그렇다면 HTTPS는?</strong>
<br />
<br />
하이퍼 텍스트 전송 프로토콜 즉, <code class="language-plaintext highlighter-rouge">HTTP</code>는 <code class="language-plaintext highlighter-rouge">HTML</code>을 전송하기 위한 통신 규약이다.
<br />
하지만 암호화 되지 않은 방법으로 데이터를 전송하기 때문에 보안에 취약하다.
<br />
그래서 이를 보완한 것이 <code class="language-plaintext highlighter-rouge">SSL</code> 또는 <code class="language-plaintext highlighter-rouge">TLS</code> 사용해 암호화된 <code class="language-plaintext highlighter-rouge">HTTPS</code> 이다.
<br />
<code class="language-plaintext highlighter-rouge">SSL, TLS</code> 는 응용계층<code class="language-plaintext highlighter-rouge">(HTTP)</code> 과 전송계층<code class="language-plaintext highlighter-rouge">(TCP)</code> 사이에 위치해 있다.</p>

<ul>
  <li><strong>SSL</strong> : 서버와 브라우저 사이에 전송되는 데이터를 암호화 함</li>
  <li><strong>TSL</strong> : <code class="language-plaintext highlighter-rouge">SSL</code>의 향상된 버전, 통신하는 대상간의 데이터의 무결성을 제공하는걸 목표로 함
<br />
<br /></li>
</ul>

<p><strong>인증서 동작</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">SSL/TSL</code> 세션은 핸드셰이크라는 과정을 통해 클라이언트-서버 간에 암호화 된 연결을 수립한다.</p>
<ul>
  <li><strong>인증</strong>
    <ul>
      <li>클라이언트가 시작하는 모든 신규 세션에 대해 서버는 각각 다른 <code class="language-plaintext highlighter-rouge">SSL</code> 인증서를 교환하고 검증한다.</li>
    </ul>
  </li>
  <li><strong>암호화</strong>
    <ul>
      <li>서버는 클라이언트와 공개 키를 공유하고 클라이언트는 이 키를 사용해 프리마스터 키를 생성해 암호화한다. 이를 키교환이라고 한다.</li>
    </ul>
  </li>
  <li><strong>복호화</strong>
    <ul>
      <li>서버는 개인 키를 사용해 프리마스터 키를 복호화 하고, 세션기간동안 사용되는 암호화된 보안연결을 수립한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="base64">Base64</h1>
<p><strong>Binary Data 를 Text로 바꾸는 인코딩</strong> 의 하나로써 <code class="language-plaintext highlighter-rouge">Binary Data</code> 를 Character set에 영향을 받지 않는 공통 <code class="language-plaintext highlighter-rouge">ASCII</code> 영역의 문자로만 이루어진 문자열로 바꾸는 인코딩이다.
<br />
<code class="language-plaintext highlighter-rouge">Base64</code>는 직역하면 64진법인데, 64진법은 2의 제곱수에 기반한 진법 중 화면에 표시되는 <code class="language-plaintext highlighter-rouge">ASCII</code> 문자들로 표시할 수 있는 가장큰 진법이다.</p>
<ul>
  <li><strong>인코딩</strong> : 정보의 형태나 형식을 표준화, 보안, 처리속도향상 등을위해 다른 형태나 형식으로 변환하는 처리</li>
</ul>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">Base64</code>로 인코딩하면 데이터양이 약 33% 늘어나고 다시 디코딩하는 추가연산도 필요하다. 근데 왜쓸까?
<br />
HTTP로 <code class="language-plaintext highlighter-rouge">Binary Data</code>(이미지, 오디오 등)를 전송하면 문제가 발생하는데, 대표적으로</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ASCII</code>는 <code class="language-plaintext highlighter-rouge">7bits</code> 인코딩 인데 나머지 <code class="language-plaintext highlighter-rouge">1bit</code> 를 처리하는 방식이 시스템 별로 상이하다.</li>
  <li>일부 제어문자 (e.g. Line ending)의 경우 시스템 별로 다른 코드값을 갖는다.
<br /></li>
</ul>

<p>즉,<code class="language-plaintext highlighter-rouge">Binary Data</code>의 손실이 일어나기 때문에, <strong>ASCII는 시스템간 데이터를 전달하기에 안전하지가 않다.</strong> 
<br />
그래서 <code class="language-plaintext highlighter-rouge">ASCII</code> 중 제어문자와 일부 특수문자를 제외한 64개의 안전한 출력 문자만 사용하는 <code class="language-plaintext highlighter-rouge">Base64</code>를 사용한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="bulk-처리">Bulk 처리</h1>
<p>대량의 데이터를 한번의 트랜잭션으로 삽입하는 방법이다.
<br />
<br />
insert 로 예를들면
<br />
<code class="language-plaintext highlighter-rouge">MyBatis</code> 기준 insert 구문 수행 시 values 리스트를 다중으로 사용한다.
<br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="n">A</span> <span class="k">values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">)</span> <span class="p">...</span>


<span class="k">insert</span> <span class="k">into</span> <span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">)</span> <span class="k">values</span>
<span class="o">&lt;</span><span class="n">foreach</span> <span class="n">collection</span><span class="o">=</span><span class="nv">"list"</span> <span class="n">item</span><span class="o">=</span><span class="nv">"item"</span> <span class="n">separator</span><span class="o">=</span><span class="nv">","</span><span class="o">&gt;</span>
	<span class="o">#</span><span class="p">{</span><span class="n">item</span><span class="p">}</span>
<span class="o">&lt;/</span><span class="n">foreach</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
DB와의 트랜잭션은 커넥션을 열고 닫는 등의 생각보다 복잡하고 리소스가 큰데 10000건의 데이터를 
<br />
저장하는 경우를 생각해 보면 데이터를 저장하는데 10000번의 트랜잭션이 일어나게 된다.
<br />
<br />
하지만 <code class="language-plaintext highlighter-rouge">bulk insert</code> 의 경우 단 한번의 트랜잭션으로 처리를 할 수 있기 때문에
<br />
데이터 수가 많을수록 비약적으로 성능이 향상된다.
<br />
<br />
실제로도 예전에 거의 안쓰이는 스케쥴러 처리한 <code class="language-plaintext highlighter-rouge">insert</code> 용도의 <code class="language-plaintext highlighter-rouge">API</code> 가 있는데 어느순간
<br />
급격히 사용량이 많아져서 데이터 처리에 딜레이가 발생하는 상황이 생긴적이 있는데
<br />
이때 <code class="language-plaintext highlighter-rouge">bulk</code> 처리 하나로 비약적인 성능향상과 이슈를 해결한 적이 있었다.</p>

<p><br /></p>

<p><strong>단점</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">bulk insert</code> 로 10000건의 데이터를 insert 하던 중 마지막 <code class="language-plaintext highlighter-rouge">low</code> 에서 에러가 발생한다면?
<br />
이럴경우 모두 롤백된다.
<br />
<br />
10000번의 트랜잭션을 1번의 트랜잭션으로 해결해서 비약적인 성능향상을 가져올 수 있지만 하나라도 
<br />
실패하는 순간 트랜잭션은 롤백되고 그 트랜잭션 안에 10000건이 있기 때문에 이렇게 되면 매우 비효율적이다.
<br />
그래서 너무 대량의 데이터를 <code class="language-plaintext highlighter-rouge">bulk</code> 처리 하는건 좋지않고,
<br />
실패할 경우를 대비해 <code class="language-plaintext highlighter-rouge">retry</code> 하는 코드도 별도로 짜주는게 좋다.
<br />
제일 좋은건 정합성이 뛰어난 데이터여서 실패할 가능성이 거의 없을때 사용하는게 좋겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="세션이-왜필요할까">세션이 왜필요할까?</h1>
<p><code class="language-plaintext highlighter-rouge">HTTP</code>프로토콜은 비연결 지향이기 때문에 세션과 쿠키를 사용하는데
<br />
세션은 서버에서 관리하고 프론트에선 그 키를 받아서 내가 누구인지 알려준다.
<br />
이런식으로 인증에 대한 세션과 쿠키의 협업이 일어난다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="apache-tomcat">Apache Tomcat</h1>
<p>가장 범용적인 <code class="language-plaintext highlighter-rouge">WAS</code> 중 하나이며, Apache 재단 에서 개발한 <code class="language-plaintext highlighter-rouge">HTTP Web Application Server</code>이다.
<br />
오픈소스이기 때문에 무료이고 구축이 쉽다는 이유로 전세계에서 매우 많이 사용되고 있다.
<br />
기본적으로 <code class="language-plaintext highlighter-rouge">Apache</code> 와 <code class="language-plaintext highlighter-rouge">Tomcat</code> 의 기능은 나뉘어져 있지만, <code class="language-plaintext highlighter-rouge">Tomcat</code> 안에 컨테이너를 통해 
<br />
일부 <code class="language-plaintext highlighter-rouge">Apache</code> 기능을 발휘하기 때문에 보통 <code class="language-plaintext highlighter-rouge">Apache Tomcat</code> 으로 부른다.</p>
<ul>
  <li><strong>Apache</strong>
    <ul>
      <li>웹서버이며, 80포트로 클라이언트 요청(GET, POST 등)이 왔을때만 응답한다.</li>
      <li>정적인 데이터만 처리한다 (HTML, CSS, 이미지 등)
        <ul>
          <li><strong>웹서버</strong> : <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜 요청을 처리하는 서버</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Tomcat</strong>
    <ul>
      <li>동적인 웹을 만들기 위한 <code class="language-plaintext highlighter-rouge">Web Container</code>, <code class="language-plaintext highlighter-rouge">Servlet Container</code> 로도 불림</li>
      <li><code class="language-plaintext highlighter-rouge">Servlet</code> 을 실행키고 <code class="language-plaintext highlighter-rouge">JSP</code> 코드가 포함되어 있는 웹 페이지를 만들어준다.</li>
      <li>DB, 로직처리 등을 요구하는 동적타입을 제공하는 소프트웨어</li>
      <li>프로그램 실행환경과 DB 접속 기능 등을 제공한다.</li>
      <li>여러개의 트랜잭션을 관리한다.</li>
      <li>비즈니스 로직을 수행한다.</li>
    </ul>
  </li>
  <li><strong>Sevrlet</strong>
    <ul>
      <li>동적인 처리를 하는 역할을 담당하는 자바 기반 기술</li>
      <li><code class="language-plaintext highlighter-rouge">WAS</code>에서 동작하는 Java 클래스이며, <code class="language-plaintext highlighter-rouge">HttpServlet</code> 을 상속받는다.</li>
      <li><code class="language-plaintext highlighter-rouge">Request / Response</code> 흐름을 간단한 메서드 호출로 다룰 수 있게 해준다.</li>
    </ul>
  </li>
  <li><strong>Sevrlet Container</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Sevrlet</code> 을 담고 관리하는 컨테이너</li>
      <li>새로운 요청이 들어올 때 마다 스레드를 생성</li>
      <li>작업이 끝난 서블릿 스레드를 제거</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>정리하면</strong>
<br />
<br />
<strong>Apache Tomcat != Apache</strong></p>
<ul>
  <li><strong>Apache 만 사용하면?</strong>
    <ul>
      <li>구조가 단순하여 트래픽 과부하에 장점이 있다.</li>
      <li>정적인 웹페이지만 처리가 가능하다.</li>
    </ul>
  </li>
  <li><strong>Tomcat 만 사용하면?</strong>
    <ul>
      <li>동적인 웹페이지 처리가 가능하지만 <code class="language-plaintext highlighter-rouge">Apache</code> 에서 필요한 기능을 가져오지 못한다.</li>
      <li><code class="language-plaintext highlighter-rouge">Apache</code> 에 비해 속도가 느려 트래픽 과부하에 단점이 있다.</li>
    </ul>
  </li>
  <li><strong>둘을 같이쓰면?</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Apache</code> 는 정적인 데이터만 처리하고, JSP 처리는 Web Container(Tomcat의 일부)로 보낸다. 
  <br />
  결국 분산처리가 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servlet-filter">Servlet Filter</h1>
<p>J2EE 표준 스펙을 구현한 기술이다. <code class="language-plaintext highlighter-rouge">Tomcat</code>과 같은 <code class="language-plaintext highlighter-rouge">Web Container</code>에 의해 관리된다.
<br />
<code class="language-plaintext highlighter-rouge">Servlet</code>으로 전달되는 클라이언트의 <code class="language-plaintext highlighter-rouge">request</code> 혹은 <code class="language-plaintext highlighter-rouge">Servlet</code>에서 클라이언트로 전달되는 <code class="language-plaintext highlighter-rouge">response</code>를
<br />
중간에 가로채서 <code class="language-plaintext highlighter-rouge">request / response</code> 객체 자체를 조작할 수 있다.
<br />
<br />
사용자인증, 로깅, 인코딩 같은 기능들은 모든 <code class="language-plaintext highlighter-rouge">Servlet</code>이나 JSP가 공통적으로 필요로 하기 때문에 공통적인
<br />
기능들을 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 호출되기 전에 전처리 혹은 후처리 하고 싶을 때 <code class="language-plaintext highlighter-rouge">Servlet Filter</code>로 구현한다.
<br />
클라이언트 요청을 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 받기전에 먼저 가로채서 서버컴포넌트의 공통적인 기능을 수행시킬 수 있다.
<br />
<br />
예를들어 모든 페이지에서 로그인 유무를 확인해야 할 경우 각 <code class="language-plaintext highlighter-rouge">Controller</code> 마다 로그인 유무를 체크하는 로직을
<br />
작성하면 추후 로그인 관련 로직이 변경될 경우 모든 로직을 바꿔야 하기 때문에 매우 비효율 적일 것이다.
<br />
그렇다면 이 <strong>공통관심사</strong> 를 분리해서 필터에 위임하면 유지보수가 훨씬 용이해 질 것이다. 
<br />
<code class="language-plaintext highlighter-rouge">Servlet Filter</code> 는 <code class="language-plaintext highlighter-rouge">Servlet</code>과 비슷한 <code class="language-plaintext highlighter-rouge">LifeCycle</code>을 가진다. (생성 - 초기화 - 필터 - 종료)</p>
<ul>
  <li>필터로 구현하면 좋은 기능들
    <ul>
      <li>인증(사용자 인증) 필터</li>
      <li>로깅 및 감시 필터</li>
      <li>이미지 변환 및 데이터 압축 필터</li>
      <li>암호화 필터</li>
      <li>XML 컨텐츠를 변형하는 XSLT 필터</li>
      <li>URL 및 기타 정보들을 캐싱하는 필터</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<h2 id="관심사의-분리">관심사의 분리?</h2>
<p><code class="language-plaintext highlighter-rouge">Filter</code>를 공부하다가 <code class="language-plaintext highlighter-rouge">관심사의 분리</code> 라는 키워드를 보게 되었다.
<br />
<code class="language-plaintext highlighter-rouge">Filter</code>는 무슨 행동을 하기전에 먼저 실행하거나, 실행한 후 추가적인 행동을 할 때 사용하는데
<br />
스프링에는 <strong>공통처리</strong> 를 위해 활용할 수 있는 <code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">AOP</code> 가 더 있다.
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code>는 <code class="language-plaintext highlighter-rouge">Servlet</code>단위에서 실행되지만 <code class="language-plaintext highlighter-rouge">AOP</code>는 메소드 앞에 Proxy패턴의 형태로 실행된다.
<br />
실행순서는 <code class="language-plaintext highlighter-rouge">Filter</code>가 가장 밖에 있고 그안에 <code class="language-plaintext highlighter-rouge">Interceptor</code>, 그안에 <code class="language-plaintext highlighter-rouge">AOP</code>가 있는 형태이다.
<br />
따라서 요청이 들어오면 <code class="language-plaintext highlighter-rouge">Filter</code> → <code class="language-plaintext highlighter-rouge">Interceptor</code> → <code class="language-plaintext highlighter-rouge">AOP</code> → <code class="language-plaintext highlighter-rouge">Interceptor</code> → <code class="language-plaintext highlighter-rouge">Filter</code> 순으로 거치게 된다.</p>

<p><br /></p>

<h3 id="interceptor">Interceptor</h3>
<p>스프링에서 제공하는 기술이다. 
 <br />
 <code class="language-plaintext highlighter-rouge">DistpatcherServlet</code>이 <code class="language-plaintext highlighter-rouge">Controller</code>를 호출하기 전과 후에 응답을 참조하거나 가공한다.
<br />
<code class="language-plaintext highlighter-rouge">Filter</code>는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작하지만
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>는 스프링의 <code class="language-plaintext highlighter-rouge">DistpatcherServlet</code>이 <code class="language-plaintext highlighter-rouge">Controller</code>를 호출하기 전, 후로 끼어들기 때문에 
<br />
스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.</p>
<ul>
  <li>스프링의 모든 빈 객체에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Interceptor</code>는 여러개를 사용할 수 있고 다음과 같은 작업을 수행한다.
    <ul>
      <li>로그인 체크</li>
      <li>권한 체크</li>
      <li>프로그램 실행시간 계산작업</li>
      <li>API 호출에 대한 로깅</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="aop">AOP</h3>
<p><strong>OOP</strong>를 보완하기 위해 나온 개념 
<br />
객체지향 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.
<br />
주로 <strong>비즈니스단</strong>의 메서드에서 로깅, 트랜잭션, 에러처리 등을 조금 더 세밀하게 조정하고 싶을 때 사용한다.
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code> 와 다르게 메서드 전후의 지점에 자유롭게 설정이 가능하고
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code>는 주소로 대상을 구분해서 걸러내지만 <code class="language-plaintext highlighter-rouge">AOP</code>는 주소, 파라미터, 어노테이션 등 다양하게 대상을 지정할 수 있다.</p>
<ul>
  <li><strong>메서드 단위 공통로직</strong> 에 적합 예를들면, 각 메서드가 얼마나 걸리는지 시간측정하는 로그를 뿌리는 작업</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servletcontextlistener">ServletContextListener</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="tcp--udp">TCP / UDP</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="배치시스템-vs-스트리밍-시스템">배치시스템 vs 스트리밍 시스템</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="osi-7-계층">OSI 7 계층</h1>
<p>계층이 올라간다는건 무슨 의미일까?
<br />
<br />
TCP 기반의 HTTP가 UDP통신을 도입하고 있는데 과연 데이터 정합성의 문제는?</p>

<ul>
  <li>데이터 정합성의 검증을 한 계층 더 올려서 거기서 한다는데?</li>
  <li>그러니까 TCP를 사용하는 계층에선 정합성의 문제에서 자유로우니 UDP 통신을 이용한다?</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Apache Tomcat" /><category term="Servlet Filter" /><category term="Web" /><category term="Session" /><category term="OSI 7계층" /><category term="TCP / UDP" /><category term="Bulk 처리" /><category term="SSR" /><category term="CSR" /><category term="HTTPS" /><category term="Base64" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">refactoring</title><link href="http://localhost:4000/til/refactoring/" rel="alternate" type="text/html" title="refactoring" /><published>2023-01-13T00:00:00+09:00</published><updated>2023-01-13T00:00:00+09:00</updated><id>http://localhost:4000/til/refactoring</id><content type="html" xml:base="http://localhost:4000/til/refactoring/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="리팩토링">리팩토링?</h1>

<p>소프트웨어 관점으로 결과의 변경 없이 코드의 구조를 재조정함 을 의미한다.
<br />
즉, 기능은 보존하면서 설계 및 구조를 개선하는 것이다.</p>
<ul>
  <li>소프트웨어 설계가 좋아진다.</li>
  <li>소프트웨어를 이해하기 쉬워진다.</li>
  <li>버그를 쉽게 찾을 수 있다.</li>
  <li>프로그래밍 속도를 높일 수 있다.</li>
</ul>

<p><br />
<br /></p>

<p><strong>진짜 중복</strong></p>
<ul>
  <li>한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야한다.</li>
</ul>

<p><strong>우발적 중복 (거짓된 중복)</strong></p>
<ul>
  <li>중복으로 보이는 두 코드의 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="3의-법칙">3의 법칙</h1>
<ol>
  <li>처음에는 그냥 한다.</li>
  <li>비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.</li>
  <li>비슷한 일을 세 번째 하게 되면 리팩토링한다.</li>
</ol>

<p><br />
<br />
<br /></p>

<p><strong>기능을 새로 추가하기 직전</strong></p>
<ul>
  <li>리팩터링 하기 가장 좋은 시점은 기존 기능에 새로운 기능을 추가하기 직전이다.</li>
  <li>기능을 추가하기 쉽게만드는 것이 리팩터링의 핵심</li>
  <li>구조를 살짝 바꾸면 다른 작업하기 쉬워질 만한 부분을 찾는다.</li>
  <li>기능을 추가하면서 중복코드가 생길만한 부분을 함수화 시킨다.</li>
</ul>

<p><br /></p>

<p><strong>코드를 이해하기 어려울때</strong></p>
<ul>
  <li>코드 수정시 코드를 이해하기 어렵다면 이해를 위한 리팩터링을 진행한다.</li>
  <li>코드만 보더라도 이해를 쉽게 할 수 있도록 변수와 함수의 이름을 변경한다.</li>
  <li>코드를 이해하기 쉽게 만드는것은 협업하기도 좋고 코드를 오래 보존 할 수 있게된다.</li>
</ul>

<p><br /></p>

<p><strong>불필요한 코드를 발견했을때</strong></p>
<ul>
  <li>코드가 비효율적으로 수행되는 것을 발견했을대 리팩터링을 진행한다.</li>
  <li>로직 혹은 코드가 쓸데없이 복잡하거나 불필요한 코드를 발견했다면 보이스카웃 규칙을 떠올리자.</li>
  <li>원래 하려던 작업시간을 뺏길 수 있으니 간단한 일이라면 바로 처리하고, 시간이 좀 걸릴 것 같으면 <code class="language-plaintext highlighter-rouge">TODO</code>를 남겨두자.</li>
</ul>

<p><br /></p>

<p><strong>계획된 리팩토링</strong></p>
<ul>
  <li>수시로 진행하는 리팩터링 외에도 따로 시간을 내서 리팩터링을 진행 할 수 있다.</li>
  <li>미리 새기능을 추가 할 수 있도록 코드를 개선해둔다.</li>
  <li>코드가 이미 깔끔하다면 리팩터링을 하기에도 더 쉽다.</li>
</ul>

<p><br /></p>

<p><strong>오래걸리는  리팩토링</strong></p>
<ul>
  <li>각 잡고 전체 개발자들이 달려들어서 리팩토링을 하는 짓은 좋지않다.</li>
  <li>리팩토링 해야될 코드와 관련된 작업을 하게 될 때 마다 원하는 방향으로 조금씩 개선하는 방향을 추구하자</li>
</ul>

<p><br /></p>

<p><strong>코드리뷰에 리팩토링 활용하기</strong></p>
<ul>
  <li>PR 피드백을 활용하여 리팩토링 해나가는 것도 좋은 방법이다.</li>
</ul>

<p><br /></p>

<p><strong>리팩토링 하지 말아야 할 때</strong></p>
<ul>
  <li>호출해서 쓰는 코드라면 굳이 건들지 말자</li>
  <li>리팩터링보다 새로 코드를 작성하는 쉬운 코드의 경우 그냥 둔다.</li>
  <li>어떤 코드가 리팩터링보다 새로 만드는게 쉬운가에 대한 판단은 많은 경험이 뒷받침 되어야한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Refactoring" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">5 Week</title><link href="http://localhost:4000/til/5%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="5 Week" /><published>2023-01-12T00:00:00+09:00</published><updated>2023-01-12T00:00:00+09:00</updated><id>http://localhost:4000/til/5%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/5%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="solid">SOLID</h1>
<p>객체지향의 5가지 설계원칙</p>

<p><br /></p>

<p><strong><em>단일 책임 원칙 (SRP) - 한 클래스는 하나의 책임만 가져야 한다.</em></strong>
<br />
<br />
모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다.
<br />
한 클래스가 수행할 수 있는 책임 (기능)이 여러가지라면, 클래스 내부 함수끼리의 강한 결합이
<br />
발생할 가능성이 높아지고 이는 유지보수에 비효율적이다.
<br />
한 클래스를 변경하기 위해 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고있는 것이다.</p>

<p><br />
<br /></p>

<p><strong><em>개방-폐쇄 원칙 (OCP) - 확장에는 열려있고 변경에는 닫혀 있어야 한다.</em></strong>
<br />
<br />
수많은 모듈 중 하나를 수정할 때, 해당 모듈을 이용하는 다른 모듈들을 고쳐야 한다면 비효율적이다.
<br />
즉, 기능을 추가하거나 변경해도 이미 제대로 동작하고 있던 코드를 변경하지 않아도 기존의 코드에
<br />
새로운 코드를 추가함으로써 기능의 추가나 변경이 가능한걸 의미한다.
<br />
추상화는 개방-폐쇄 원칙의 핵심요소이다.
<br />
자주 변화하는 부분을 추상화 함으로써 유연함을 높인다.
<br />
모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 추상화의 파생클래스를 만드는것으로 확장이 가능하다.
<br />
객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성을 위한 핵심원칙이다.</p>

<p><br />
<br /></p>

<p><strong><em>리스코프 치환원칙 (LSP) - 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야 한다.</em></strong>
<br />
<br />
하위타입객체는 상위타입객체에서 가능한 행위를 수행할 수 있어야 한다.
<br />
즉, 상위타입객체를 하위타입객체로 치환해도 정상적으로 동작해야 한다. == IS-A
<br />
객체지향 초기에는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만 시간이 지나면서 인터페이스와 구현체에도 적용되는 광범위한 원칙으로 바뀌었다.</p>

<p><br />
<br /></p>

<p><strong><em>인터페이스 분리원칙 (ISP) - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</em></strong>
<br />
<br />
클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.
<br />
큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
<br />
이는 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않게 한다.</p>

<p><br />
<br /></p>

<p><strong><em>의존관계 역전원칙 (DIP) - 추상화에 의존해야하고, 구체화에 의존하면 안된다.</em></strong>
<br />
<br />
의존 관계를 맺을 때, 
<br />
변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 한다
<br />
즉, 구체화된 클래스 보단 추상클래스나 인터페이스에 의존해야 한다.
<br />
<br />
상위계층이 하위계층의 구현으로부터 독립적이어야 한다.</p>
<ul>
  <li>상위모듈은 하위모듈에 의존해선 안되고, 상위모듈과 하위모듈 모두 추상화에 의존해야한다.</li>
  <li>추상화는 세부사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스레드">스레드</h1>
<p>운영체제에 메모리를 할당받아 실행중인 프로그램을 프로세스라고 한다.
<br />
스레드란 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다.
<br />
모든 프로세스는 한 개 이상의 스레드가 존재하며 1개는 단일스레드 2개 이상은 멀티스레드 라고 한다.
<br />
<br />
독립적인 프로세스들은 자원 및 데이터를 공유하지않아 리소스가 많이들어가지만 
<br />
멀티스레드의 경우는 자원 및 데이터 공유를 공유하기 때문에 리소스가 적게들어간다.
<br />
물론 데이터를 공유하기 때문에 동기화가 중요하다 -&gt; <code class="language-plaintext highlighter-rouge">thread-safe</code></p>

<p>모든 자바 어플리케이션은 메인스레드가 <code class="language-plaintext highlighter-rouge">main()</code> 메서드를 실행하면서 시작한다.
<br />
이러한 Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 
<br />
만들어 병렬로 코드를 실행할 수 있다. 단일 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만 
<br />
멀티 스레드는 <strong>메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.</strong></p>

<p><br /></p>

<p><strong>생성</strong></p>
<ul>
  <li>Runnable 인터페이스 구현</li>
  <li>Thread 클래스 상속</li>
  <li>람다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OfThreadClass</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">OfRunnableInterface</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">OfLambda</span> <span class="o">{</span>
	<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
		<span class="nc">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadName</span><span class="o">);</span>
	<span class="o">});</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"Thread #1"</span><span class="o">);</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>자바에서는 다중상속이 안되기 때문에, <code class="language-plaintext highlighter-rouge">Thread</code> 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없다. 
<br />
하지만 <code class="language-plaintext highlighter-rouge">Runnable</code> 인터페이스를 구현하는 경우에는 다른 인터페이스를 구현할 수도 있고 다른클래스도 상속 받을수 있다는 장점이 있다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="자바는-느리다">자바는 느리다?</h1>
<p>자바는 <code class="language-plaintext highlighter-rouge">Python</code> , <code class="language-plaintext highlighter-rouge">JavaScript</code> 같은 인터프리터 , 스크립트 언어 보다는 빠르다.
<br />
하지만 <code class="language-plaintext highlighter-rouge">C/C++</code> , <code class="language-plaintext highlighter-rouge">Pascal</code> , <code class="language-plaintext highlighter-rouge">Fortran</code> 같은 네이티브 바이너리 코드를 만드는 언어에 비해선 느리다.
<br />
그 이유는 여러가지가 있지만 크게 2가지를 들 수 있다.</p>
<ul>
  <li>객체지향 언어의 특성</li>
  <li>JVM이라는 가상머신 사용</li>
</ul>

<p>자바는 개발자의 편의성을 위해 성능을 희생하고 있는데 시간이 지나면서
<br />
자바의 소프트웨어와 하드웨어가 발전해서 초기이슈였던 성능이슈는 잠잠해 졌지만
<br />
여전히 부족한 하드웨어 스펙을 쓰는 소규모 장비에선 C언어를 주로 사용한다.</p>

<p><br /></p>

<p><strong><em>객체지향의 특성</em></strong>
<br />
<br />
자바는 클래스 단위로 모든 코드를 작성한다. C언어와 같은 함수단위가 아니기때문에
<br />
다른 클래스에 있는 메서드나 정보를 사용하기 위해선 해당 클래스 전체를 인스턴스로 만들어야 한다.
<br />
그만큼 메모리와 코드를 찾아 로드하는 시간에 많은 리소스가 들게되고 이것을 피하려고 <code class="language-plaintext highlighter-rouge">static</code> 사용이나
<br />
클래스 단위를 잘게 쪼개서 작성할 경우 객체를 다루는 효율성이 떨어지게 된다.
<br />
그렇기 때문에 자바는 C언어와 달리 모든 코드를 미리 메모리에 올려두지 않고 필요할 때 마다 가져다 쓰는
<br />
<strong>동적 할당 방식</strong>을 사용하기 때문에 C언어보다 상대적으로 느릴 수 밖에 없다.</p>

<p><br /></p>

<p><strong><em>JVM</em></strong>
<br />
<br />
C언어는 컴파일 시 코드를 모드 기계어로 번역해 메모리에 올려두고 실행한다. 하지만 자바에서는
<br />
바이트코드로 먼저 컴파일 한 뒤, 동적할당 된 코드를 JVM의 JIT과 같은 방식으로 실행한다.
<br />
이렇게 함으로써 운영체제에 종속적이지 않게 된다는 이점이 있지만 그만큼 성능을 희생하게 된다.
<br />
또한 C언어에서는 동적할당한 메모리를 개발자가 직접 바로 해제하지만, 자바는 GC가 메모리를 해제하기 때문에
<br />
이 GC또한 프로그램이기 때문에 메모리와 연산작업을 동반하게 된다.</p>

<p><br /></p>

<p><strong><em>인터프리터 / 스크립트 언어</em></strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">Python</code>과 같은 인터프리터 방식의 언어는 <strong>코드를 한줄씩</strong> 읽어 기계어로 번역한다.
<br />
그리고 같은 기능을 하는 코드가 다시 나와도 또 다시 해석하여 결과를 출력한다. 
<br />
이 때문에 일반적으로 컴파일 방식의 언어보다 수행 속도가 느리다.
<br />
하지만 수정사항이 발생했을 때, 컴파일러가 소스코드를 읽어 실행 파일을 만드는 자바는 소스코드를
<br /> 
다시 컴파일 해야하지만 인터프리터 언어는 소스코드를 수정해서 실행시키면 끝나기 때문에 수정이
<br />
아주 간단하다는 장점이 있다. 즉, 개발편의성이 좋다는 의미이다.
<br />
<code class="language-plaintext highlighter-rouge">Python</code>은 이 약점을 극복하기 위해 라이브러리들의 내부는 C / C++ 으로 되어있다.
<br />
<br />
그리고 이 장점을 최대한 살린것이 스크립트 언어이다.</p>

<p><br /></p>

<h2 id="io--nio">IO / NIO</h2>
<p>자바는 직접 메모리를 관리하고 운영체제의 <strong>시스템 콜</strong> 을 직접 사용하기 힘들다.
<br />
자바가 특별히 성능이 좋지 않은 부분이 <code class="language-plaintext highlighter-rouge">IO</code> 이고 이걸 개선한 것이 <code class="language-plaintext highlighter-rouge">NIO</code> 패키지 이다.</p>

<p><br /></p>

<ul>
  <li><strong><em>IO</em></strong>
    <ul>
      <li>
        <p><strong><em>Blocking API</em></strong>
  <br />
  API 를 호출한 스레드가 API의 작업이 끝날 때까지 다른동작을 하지 않는 API 를 말한다. <code class="language-plaintext highlighter-rouge">(idle 상태)</code>
  <br />
  자바의 기본 IO는 이 <code class="language-plaintext highlighter-rouge">Blocking API</code>로 사용되어 왔기 때문에 <code class="language-plaintext highlighter-rouge">File IO</code> 뿐만 아니라
  <br />
  <code class="language-plaintext highlighter-rouge">Network IO</code> 또한 오래 걸리기 때문에 더욱 자바에게 느리다는 인상을 심어준 녀석이다.</p>
      </li>
      <li>
        <p><strong><em>Stream 기반</em></strong>
  <br />
  스트림 기반의 IO는 스트림으로부터 한번에 여러 바이트를 읽는다. 데이터는 캐싱되어 있지 않고
  <br />
  스트림 속 데이터에서 앞뒤로 이동할 수 없다. 만약 스트림으로 읽은 데이터 내부에서 앞뒤로
  <br />
  이동해야 한다면 버퍼를 만들어 캐싱을 해야한다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>NIO</em></strong>
    <ul>
      <li>
        <p><strong><em>Non Blocking API</em></strong>
  <br />
  API 호출 시 요청한 작업의 완료여부와 상관없이 즉각적으로 현재 상태에 대한 답이 온다.
  <br />
  그렇기 때문에 API 호출 후 스레드 제어권이 있기 때문에 다른작업을 진행할 수 있다.</p>
      </li>
      <li>
        <p><strong><em>Buffer 기반</em></strong>
  <br />
  이미 처리된 버퍼로부터 데이터를 읽는다. 필요하다면 버퍼 내부에서 앞뒤로 이동할 수 있다.
  <br />
  즉, 데이터를 처리하는 동안 좀 더 유연함을 제공해 주지만 데이터를 완벽하게 처리하려면
  <br />
  필요한 데이터가 모두 버퍼 안에 있어야 한다. 또한 버퍼에서 더많은 데이터를 읽을때 버퍼속에서
  <br />
  아직 전처리되지 않은 데이터를 사용하지 않도록 확실히 해야한다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<code class="language-plaintext highlighter-rouge">NIO</code>는 불특정 다수의 클라이언트 연결 또는 멀티 파일들을 넌블로킹이나 비동기로 처리할 수 있다.
<br />
과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용한다는 점이 큰 장점이다.
<br />
운영체제의 버퍼(다이렉트 버퍼)를 이용한 입출력이 가능하기 때문에 입출력 성능 향상
<br />
<code class="language-plaintext highlighter-rouge">NIO</code>는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우에 사용하는것이 좋다.
<br />
스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업의 수가 늘어나기 때문에 제한된 스레드로 처리하는 것이 불편할 수 있다.
<br />
<br />
<br />
대용량의 데이터 처리의 경우 <code class="language-plaintext highlighter-rouge">IO</code>가 좋다.
<br />
연결 클라이언트 수가 적고 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있는 경우 
<br />
<code class="language-plaintext highlighter-rouge">IO</code>로 서버를 구현하는 것이 좋다. <code class="language-plaintext highlighter-rouge">NIO</code>는 버퍼 할당 크기도 문제되고, 모든 입출력 작업에 버퍼를
<br />
무조건 사용해야 하므로 받은 즉시 처리하는 <code class="language-plaintext highlighter-rouge">IO</code>보다 복잡하다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="io">I/O</h1>
<p>데이터의 입력(Input) / 출력(Output)이다. <code class="language-plaintext highlighter-rouge">I/O</code> 는 어플리케이션 성능에 가장 큰 영향을 미치는데
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 에서 발생하는 시간은 CPU를 사용하는 시간과 대기 시간이 있고 어플리케이션이 연산을 할 때까지
<br />
CPU가 다음 작업 실행을 block 한다. <code class="language-plaintext highlighter-rouge">I/O</code> 로 인한 blocking은 CPU를 긴 시간동안 idle 상태에 두는데
<br />
이것은 다른작업을 할 수 있음에도 할수가 없어 매우 비효율 적이다.</p>
<ul>
  <li>파일 <code class="language-plaintext highlighter-rouge">I/O</code> 뿐만 아니라 어떤 디바이스를 통해 입력과 출력이 이뤄지는 작업을 모두 말한다.
    <ul>
      <li>다른 서버로부터 데이터를 전송받는것도 <code class="language-plaintext highlighter-rouge">I/O</code> 에 포함한다.</li>
      <li>콘솔에 출력하는 것도 스트림을 통해 출력하는 것이기 때문에 <code class="language-plaintext highlighter-rouge">I/O</code> 이다.</li>
    </ul>
  </li>
</ul>

<p><br />
<code class="language-plaintext highlighter-rouge">I/O</code> 는 어플리케이션에서 직접 수행 될 수 없고 무조건 커널에 한번 이상 시스템콜을 보내야 한다.
<br />
시스템 콜을 보내면 그순간 커널로 제어권이 넘어가고 (context-switch), 유저 프로세스 / 스레드는 제어권이
<br />
다시 돌아오기 전까진 block상태가 되고 그동안 다른 작업을 하지 못하게 된다.</p>

<p><br /></p>

<h2 id="blocking-io">blocking I/O</h2>
<p><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 진행되는 동안 프로세스가 자신의 작업을 중단하고 <code class="language-plaintext highlighter-rouge">I/O</code>가 끝날때까지 block 되는 방식이다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 가 호출되면 완료되기 전까지 제어권을 커널이 가져가서 유저 프로세스 / 스레드는 block 상태가 된다.</p>

<ul>
  <li>장점
    <ul>
      <li>호출마다 스레드를 생성하니 요청이 적은 서비스에서 효율이 좋다. (병렬작업의 장점)</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>요청마다 스레드를 생성하는 부분의 리소스가 크다.</li>
      <li><code class="language-plaintext highlighter-rouge">context-switching</code> 이 빈번하게 일어난다.</li>
      <li>각각의 스레드는 <code class="language-plaintext highlighter-rouge">I/O</code> 작업이 완료되기 전까진 block 상태가 된다.</li>
    </ul>
  </li>
</ul>

<p><br />
전통적인 방식에서는 스레드를 늘려 멀티스레드를 지원하는 방식으로 진화해 나갔다.
<br />
하지만 스레드 갯수에는 한계가 있고 리소스 측면에서도 좋지 않기 때문에 각 <code class="language-plaintext highlighter-rouge">I/O</code>에 대해서 장시간 
<br />
사용하지 않고 실행되어 있는 스레드를 방치하는 것은 효율성 측면에서 최상의 방법은 아니다.</p>

<p><br /></p>

<h2 id="non-blocking">non blocking</h2>
<p><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 완료될 때 까지 커널이 제어권을 가지지 않고 <code class="language-plaintext highlighter-rouge">I/O</code> 호출에 대해 즉시 응답을 리턴하는 방식이다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 호출되면 작업 여부와는 무관하게 즉시 결과를 리턴하고, 커널이 시스템콜을 받자마자 CPU 제어권을 다시 어플리케이션에게
넘겨주게 된다. 그리고 어플리케이션은 다른 작업을 수행하다 중간중간 시스템콜을 보내 <code class="language-plaintext highlighter-rouge">I/O</code>가 완료되었는지 커널에게 물어보고 완료되면 <code class="language-plaintext highlighter-rouge">I/O</code> 작업을 완료한다.</p>

<ul>
  <li>장점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 완료되기 전까진 block 상태가 되지 않는다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>반복적으로 시스템콜이 일어나게 된다.</li>
    </ul>
  </li>
</ul>

<p><br />
싱글스레드 방식으로 block되는 시간을 최소화 할 수 있어 <code class="language-plaintext highlighter-rouge">I/O</code> 작업(read/write) 이 많은 경우 유리하지만
<br />
CPU의 할일이 많은 경우에는 적합하지 않다.</p>

<p><br />
<br /></p>

<h2 id="io-이벤트-통지-모델">I/O 이벤트 통지 모델</h2>
<p><code class="language-plaintext highlighter-rouge">non blocking</code> 의 문제인 반복적 시스템콜 호출을 해결하기 위해 <code class="language-plaintext highlighter-rouge">I/O</code> <strong>이벤트 통지 모델</strong>이 도입되었다.
<br />
반복적으로 시스템콜을 호출하지 않고 입력 버퍼에서 완료되었다는 알림(이벤트 통지 모델)을 주게 된다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 결과 반환 방식에 따라 <strong>Sync(동기)</strong> / <strong>Async(비동기)</strong> 모델로 분류한다.</p>
<ul>
  <li><strong>이벤트</strong> : <strong>수신버퍼</strong> or <strong>출력버퍼</strong>에 데이터를 처리하는 동작을 의미한다.</li>
  <li><strong>수신버퍼</strong> : 입력버퍼에 데이터가 수신되었다는 걸 알림 출력</li>
  <li><strong>출력버퍼</strong> : 출력버퍼가 비었으니 데이터 전송이 가능한 상황을 알림</li>
</ul>

<p><br /></p>

<h3 id="sync-동기">Sync (동기)</h3>
<p><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 진행되는 동안 유저 프로세스는 결과를 기다렸다가 이벤트(결과)를 직접 처리하는 방식이다.
<br />
<code class="language-plaintext highlighter-rouge">blocking</code> 방식처럼 완료될 때 까지 기다릴 수도 있고, <code class="language-plaintext highlighter-rouge">non blocking</code> 방식처럼 커널에 계속 요청할 수 도 있다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 가 완료될 때 까지 계속 기다리던가, 다른작업을 하면서 기다리던가 결국에는 기다려야 하지만
<br />
<strong><em>다른점</em></strong>은 <code class="language-plaintext highlighter-rouge">notify</code>를 <strong>유저 프로세스가 주체적</strong>으로 진행하고 커널은 유저 프로세스의 요청에 수동적으로 응답한다.</p>

<p><br /></p>

<h3 id="async-비동기">Async (비동기)</h3>
<p><code class="language-plaintext highlighter-rouge">I/O</code>가 진행되는 동안 유저 프로세스는 자신의 일을 하다가 이벤트 핸들러에 의해 알림이 오면 처리하는 방식이다.
<br />
결국 <code class="language-plaintext highlighter-rouge">notify</code>를 <strong>커널이 주체적</strong>으로 진행하며, 유저 프로세스는 수동적인 입장에서 통지가 오면 그때 <code class="language-plaintext highlighter-rouge">I/O</code> 처리를 
<br />
한다. (이벤트 핸들러, callback)에 의해 운영체제에서 처리 결과 통지받는다.</p>

<p><br /></p>

<h3 id="뭐쓰는데">뭐쓰는데?</h3>
<p><strong>Sync</strong> : 어떤 작업을 수행한 결과로 다음 작업을 수행해야 하는 즉, 순차적 작업일 때 (인출 후 송금)
<br />
<strong>Async</strong> : <code class="language-plaintext highlighter-rouge">I/O</code> 작업이 많을 때</p>

<p><br /></p>

<h2 id="차이">차이?</h2>
<ul>
  <li><strong><em>블로킹/논블로킹</em></strong> : 각 작업의 수행 형태와 우선순위에 따라 각 작업의 수행가능 시기를 어떻게 제어할 것인가.</li>
  <li><strong><em>동기/비동기</em></strong> : 각 작업이 주고받는 데이터의 상태와 흐름을 어떻게 제어할 것인가. 데이터의 일관성 유지
<br />
<br />
즉, <strong>특정 작업의 행위가 일어나는 시점 관리</strong> 라는 관심사가 다르다.
<br />
또한 <code class="language-plaintext highlighter-rouge">notify</code>의 제어권을 가짐으로써 시스템콜 호출에 대한 차이도 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="동시성이슈">동시성이슈</h1>
<p>동시성이슈란?
<br />
<br /></p>
<ul>
  <li>노드js는 프로세스에 참가하는 스레드가 하나 인데 동시성문제에 어떻게 이점을 가져갈까?
    <ul>
      <li>노드는 컨텍스트 스위칭에 들어가는 리소스가없다?</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="동시성-임계구역">동시성 임계구역</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="web-동작">Web 동작</h1>
<ul>
  <li><strong>Request</strong>
    <ul>
      <li>사용자가 입력한 <code class="language-plaintext highlighter-rouge">URL</code> 주소 중 도메인 네임 부분을 <code class="language-plaintext highlighter-rouge">DNS</code> 서버에서 검색 후 IP 주소로 변환</li>
      <li>IP 주소로 <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 사용해 <code class="language-plaintext highlighter-rouge">HTTP</code> 요청 메시지를 생성 후 <code class="language-plaintext highlighter-rouge">TCP</code> 프로토콜을 사용해 사용자가 입력한 <code class="language-plaintext highlighter-rouge">URL</code> 정보와 함께 전송</li>
    </ul>
  </li>
  <li><strong>Response</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code> 메시지를 받고 요청 URL에 대한 데이터 검색</li>
      <li>검색된 데이터를 <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 사용해 <code class="language-plaintext highlighter-rouge">HTTP</code> 응답 메시지를 <code class="language-plaintext highlighter-rouge">TCP</code> 프로토콜을 사용해 전송</li>
      <li>랜더링 과정을 거쳐 클라이언트 화면에 표시</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Web Server</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 기반으로 하여 웹 브라우저의 요청을 서비스 하는 기능을 담당</li>
      <li><strong>정적</strong> 인 컨텐츠를 제공할 때는 <code class="language-plaintext highlighter-rouge">WAS</code>를 거치지 않고 바로 제공</li>
      <li><strong>동적</strong> 인 컨텐츠 요청이 들어오면 요청을 <code class="language-plaintext highlighter-rouge">WAS</code> 로 보내고 처리한 결과는 <code class="language-plaintext highlighter-rouge">WAS</code> 가 전달</li>
      <li><code class="language-plaintext highlighter-rouge">Apache Server</code>, <code class="language-plaintext highlighter-rouge">Nginx</code>, <code class="language-plaintext highlighter-rouge">IIS</code> 등</li>
    </ul>
  </li>
  <li><strong>WAS (Web Application Server)</strong>
    <ul>
      <li>DB 조회나 다양한 로직 처리를 요구하는 <strong>동적</strong> 인 컨텐츠를 <code class="language-plaintext highlighter-rouge">HTTP</code> 통신을 통해 제공하는 기능을 담당</li>
      <li>웹 컨테이너, 혹은 서블릿 컨테이너 라고도 불리우며 <code class="language-plaintext highlighter-rouge">JSP</code>, <code class="language-plaintext highlighter-rouge">Servlet</code> 구동 환경을 제공하는 서버</li>
      <li>분산 트랜잭션, 보안, 메시징, 스레드 처리 등의 기능을 처리하는 분산 환경에서 사용</li>
      <li><code class="language-plaintext highlighter-rouge">Tomcat</code>, <code class="language-plaintext highlighter-rouge">JBoss</code>, <code class="language-plaintext highlighter-rouge">Jeus</code>, <code class="language-plaintext highlighter-rouge">Web Sphere</code> 등</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>2개를 따로 쓰는 이유?</strong>
    <ul>
      <li>기능을 분리하여 서버 부하를 방지</li>
      <li>오류 화면 노출 가능 (<code class="language-plaintext highlighter-rouge">WAS</code> 장애 시 오류 화면 노출 불가능 할 수 있음)</li>
      <li>여러 대의 <code class="language-plaintext highlighter-rouge">WAS</code>를 연결해 로드 밸런싱 용도로 사용</li>
      <li>물리적으로 분리하여 보안을 강화
        <ul>
          <li><code class="language-plaintext highlighter-rouge">SSL</code> 대한 암복호화 처리에 <code class="language-plaintext highlighter-rouge">Web Server</code> 를 사용</li>
        </ul>
      </li>
      <li>여러 언어의 웹 어플리케이션 서비스가 가능
        <ul>
          <li>하나의 서버에서 <code class="language-plaintext highlighter-rouge">PHP Application</code>, <code class="language-plaintext highlighter-rouge">Java Application</code> 를 함께 사용하는 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="쿠키--세션">쿠키 / 세션</h1>
<p>HTTP 프로토콜 환경은 <code class="language-plaintext highlighter-rouge">connectionless, stateless</code> 하기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 하기 때문에 이 특성을 보완하기 위해서 쿠키와 세션을 사용한다.
<br />
예를들어 쇼핑몰에서 옷을 구매하기위해 로그인했지만 페이지를 이동해야할때마다 계속 로그인을 해야한다.
<br />
쿠키와 세션은 비슷한 역할을 하며 동작원리도 비슷하지만 정보가 저장되는 위치가 다르다.</p>

<ul>
  <li><strong>connectionless</strong>
    <ul>
      <li>클라이언트가 요청한 후 응답을 받으면 연결을 끊어버림</li>
      <li>클라이언트가 request를 보내면 서버는 response를 보내고 접속을 끊는다.</li>
    </ul>
  </li>
  <li><strong>stateless</strong>
    <ul>
      <li>통신이 끝나면 상태를 유지하지 않는 특성</li>
      <li>연결이 끝나는 순간 클라와 서버의 통신이 끝나며 상태정보를 유지하지 않는다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>cookie</strong>
<br /></p>
<ul>
  <li>클라이언트 로컬에 저장되어 있는 키와 값으로 구성된 데이터 파일</li>
  <li>인증의 유효시간을 명시할 수 있고, 유효시간이 정해지면 브라우저가 종료되도 인증이 유지됨</li>
  <li>쿠키는 클라이언트의 상태정보를 로컬에 저장했다가 참조함</li>
  <li>따로 요청하지 않아도 Request Header를 넣어서 자동으로 서버에 전송</li>
  <li>
    <p>요청속도는 세션보다 빠르다.</p>
  </li>
  <li><strong>어디에써?</strong>
    <ul>
      <li>로그인 시 “아이디와 비밀번호를 저장하시겠습니까?”</li>
      <li>장바구니 기능</li>
      <li>자동로그인, 팝업 등에서 “오늘 더이상 이창을 보지 않음”</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>session</strong></p>
<ul>
  <li>쿠키를 기반으로 하지만 서버에서 관리함</li>
  <li>클라이언트를 구분하기 위해 세션 ID를 부여해 브라우저를 종료할 때 까지 인증상태를 유지</li>
  <li>접속시간에 제한을 둬서 정보가 유지되지 않게 할 수 있음</li>
  <li>서버에 정보를 둬서 보안에 더 좋지만 메모리를 많이 차지하게 됨</li>
</ul>

<p><br /></p>

<p><strong>cache</strong>
<br />
<br />
캐시는 웹페이지를 빠르게 렌더링 할 수 있게 도와주기 위해 웹페이지의 요소(css, 이미지, 비디오 등등) 를 저장하기 위한 임시저장소이다.
<br />
쿠키/세션은 정보를 저장하기위해 사용하고 사용자의 인증을 도와준다.</p>

<p><br /></p>

<p><strong>JWT</strong>
<br />
<br />
JWT는 Json Web Token의 약자이고 인증에 필요한 정보들을 암호화 시킨 토큰을 말한다.
<br />
토큰 자체를 쿠키에 담아서 보내줄 수 있고 HTTP 헤더에 담아서 보내줄 수 도 있다.
<br />
하지만 일단 발급을 하면 토큰이 만료되기 전까지 토큰의 유효성을 막을 수 없다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servlet">Servlet</h1>
<p>동적인 웹페이지를 만들 때 사용되는 자바기반 기술이다.
<br />
<code class="language-plaintext highlighter-rouge">Request / Response</code> 흐름을 간단한 메서드 호출로 다룰 수 있게 해준다.
<br />
서블릿을 통해 개발자는 비즈니스 로직에 더 집중할 수 있다.</p>

<ul>
  <li>Request에 동적으로 작동하는 웹 어플리케이션 컴포넌트</li>
  <li>HTML을 사용해 response 한다.
    <ul>
      <li>HTML 변경 시 재 컴파일해야 한다.</li>
    </ul>
  </li>
  <li>자바의 스레드를 이용해 동작한다.</li>
  <li>MVC패턴에서 Controller 로 이용된다.</li>
  <li>HTTP 프로토콜을 지원하는 HttpServlet 클래스를 상속받는다.</li>
</ul>

<p><br /></p>

<p><strong>서블릿 동작 과정</strong></p>
<ol>
  <li>Servlet Request, Servlet Response 객체를 생성</li>
  <li>설정 파일을 참고하여 매핑할 Servlet을 확인</li>
  <li>해당 서블릿 인스턴스 존재의 유무를 확인하여 없으면 생성</li>
  <li>Servlet Container에 스레드를 생성하고 service를 실행</li>
  <li>응답을 처리하면 Servlet Request, Servlet Response 객체를 소멸</li>
</ol>

<p><br />
<br /></p>

<h2 id="servlet-container">Servlet Container</h2>
<p>서블릿을 담고 관리해주는 컨테이너
<br />
Request에가 오면 HttpServletRequest, HttpServletResponse 객체를 생성해 
<br />
GET / POST 여부에 따라 동적 페이지를 생성해 Response를 보낸다.</p>

<ul>
  <li>
    <p><strong>HttpServletRequest</strong>
<br />
헤더정보, 파라미터, 쿠키, URL 등의 정보를 읽는 메서드와 body의 stream을 읽는 메서드 보유</p>
  </li>
  <li>
    <p><strong>HttpServletResponse</strong>
<br />
WAS는 HttpServleResponse 객체를 생성해 서블릿에게 전달하고 이 객체로 contentType, 응답코드, 응답메시지 등을 전송한다.</p>
  </li>
</ul>

<p><br /></p>

<p><strong>주요기능</strong></p>
<ul>
  <li>
    <p><strong>생명주기 관리</strong>
<br />
서블릿클래스를 인스턴스화 하고 요청에 따라 적절한 서블릿메서드를 찾아 동작한다.
<br />
그리고 라이프사이클이 끝나면 가비지컬렉션을 통해 메모리에서 지운다.</p>
  </li>
  <li>
    <p><strong>통신지원</strong>
<br />
클라이언트와 Request / Response 할 수 있게 웹서버와 소켓을 만들어 통신을 해준다.</p>
  </li>
  <li>
    <p><strong>멀티스레드 관리</strong>
<br />
해당 서블릿의 요청이 들어오면 스레드를 생성해 작업을 수행한다.</p>
  </li>
  <li>
    <p><strong>선언적인 보안관리</strong>
<br />
보안관련 기능을 제공하기 때문에 자바 클래스에 보안관련 메서드를 구현하지 않아도 된다.</p>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="SOLID" /><category term="스레드" /><category term="인터프리터 언어" /><category term="Blocking / Non Blocking" /><category term="동시성" /><category term="Servlet" /><category term="Cookie / Session" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">4 Week</title><link href="http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="4 Week" /><published>2023-01-05T00:00:00+09:00</published><updated>2023-01-05T00:00:00+09:00</updated><id>http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="cqrs-pattern">CQRS Pattern</h1>
<p>Command and Query Responsibility Segregation (명령과 조회의 책임 분리)
<br />
즉, 명령(command)및 쿼리의 책임을 분리하는 패턴이다. 책임분리를 위해서는 코드의 모듈이 분리되어야 한다.
<br />
read 와 write를 분리하는것을 뜻하며 어플리케이션까지만 적용할 수도 있고, DB의 모델까지만 분리할 수도 있고, DB 그 자체를 분리하여 적용할 수도 있다.</p>

<ul>
  <li>명령은 데이터중심이 아니라 작업 기반이어야 한다.</li>
  <li>명령은 동기적으로 처리되지 않고 비동기처리를 위해 큐에 배치될 수 있다.</li>
  <li>쿼리는 데이터베이스를 수정하지 않는다. 쿼리는 도메인 지식을 캡슐화하지 않는 DTO를 반환한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>읽기 모델과 쓰기 모델을 필요에 따라 독립적으로 확장 가능</li>
      <li>읽기 모델은 쿼리에 최적화된 스키마를 사용 가능</li>
      <li>호출되는 도메인 엔티티에 대해 확인하는 로직 구현이 더 쉬움</li>
      <li>보통 복잡한 비지니스 로직 구현은 대부분 쓰기 모델에 속하며, 읽기 모델은 간단하게 구현된다. 그에 따라 읽기와 쓰기를 분리하면 유지관리가 더 쉽고 유연한 모델이 구현될 수 있다.</li>
      <li>DB에 논리적인 View가 아닌, Materialized View를 저장함으로써 애플리케이션에서 복잡한 조인이 사용된 쿼리문을 피할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>언제 쓰면 좋을까?</em></strong>
    <ul>
      <li>많은 사용자가 동일한 테이터에 병렬로 엑세스 하는 공동작업 도메인일 경우</li>
      <li>한팀은 쓰기모델에 포함되는 복잡한 도메인 모델에 집중하고 다른팀은 읽기모델과 사용자 인터페이스에 집중할 수 있을 환경일 경우</li>
      <li>시스템이 시간이 자나면서 진화할 것으로예상되어 여러 버전의 모델을 포함할 수 있거나 비즈니스 규칙이 정기적으로 변하는 경우</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="generic">Generic</h1>
<p>아주 유용한 문법이고 대부분 최신 언어에선 사용한다.
<br />
타입시스템을 더 견고하게 사용하기 위해 제네릭을 사용한다.
<br />
제네릭은 형변환시 발생할 수 있는 문제들을 사전에 없앨 수 있다.
<br />
즉, 타입을 파라미터화 해서 컴파일 시 구체적인 타입이 결정되도록 해준다.</p>

<ul>
  <li>파라미터 타입, 리턴 타입에 대한 정의를 클래스 내부가 아닌 외부에서 지정</li>
  <li>타입에 대해 유연성과 안정성을 확보한다.</li>
  <li>런타임 환경에 영향이 없는 컴파일 시점의 전처리 기술이다.
    <ul>
      <li>타입을 유연하게 처리하며, 런타임에 발생할 수 있는 타입에러를 컴파일전에 검출한다.</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CastingDTO</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="no">T</span> <span class="nc">Object</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setObject</span><span class="o">(</span><span class="no">T</span> <span class="nc">Object</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="n">object</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="no">T</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">object</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 형변환을 하지않고 편리하게 사용할 수 있다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkCastingDTO</span><span class="o">()</span> <span class="o">{</span>
	<span class="nc">CastingDTO</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dto1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CastingDTO</span><span class="o">&lt;&gt;();</span>
	<span class="n">dto1</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">());</span>

	<span class="nc">CastingDTO</span><span class="o">&lt;</span><span class="nc">StringBuffer</span><span class="o">&gt;</span> <span class="n">dto2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CastingDTO</span><span class="o">&lt;&gt;();</span>
	<span class="n">dto2</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">());</span>

	<span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">dto1</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span> 
	<span class="nc">StringBuffer</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">dto2</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="특징">특징</h2>
<ul>
  <li>클래스 또는 메서드에 선언 가능</li>
  <li>동시에 여러타입 선언 가능</li>
  <li>와일드카드를 이용해 타입에 대해 유연한 처리 가능</li>
  <li>제네릭 선언 및 정의시 타입의 상속관계 지정 가능</li>
</ul>

<p><br /></p>

<h2 id="컨벤션">컨벤션</h2>
<p>제네릭 타입을 선언할 때 어느정도의 컨벤션이 존재한다.</p>
<ul>
  <li>E : Element (컬렉션에서 주로 사용됨)</li>
  <li>K : Key</li>
  <li>T : Type</li>
  <li>N : Number</li>
  <li>V : Value</li>
  <li>? : Wild Card
    <ul>
      <li>모든 타입을 다 매개변수로 받을 수 있다.
        <ul>
          <li> extends T : 상한 경계</li>
          <li>? super T : 하한 경계</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="타입범위지정">타입범위지정</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// T에 비교불가능한 타입이 온다면 이 메서드는 기능을 수행할 수 없다.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span> <span class="no">T</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span> 
	<span class="kt">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="kt">double</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="k">return</span> <span class="nc">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">);</span> 
<span class="o">}</span>

<span class="c1">// Number를 상속받는 클래스만 올 수 있도록 지정할 수 있다.</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span> <span class="no">T</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span> 
	<span class="kt">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="kt">double</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="k">return</span> <span class="nc">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>&lt;? extends T&gt;</strong> 와일드 카드의 상한 제한(upper bound) : T 타입과 T를 상속 받고 있는 타입</li>
  <li><strong>&lt;? super T&gt;</strong> 와일드 카드의 하한 제한(lower bound) : T 타입과 T의 상위 타입</li>
</ul>

<p><br /></p>

<h2 id="제네릭-클래스">제네릭 클래스</h2>
<p>클래스 인스턴스화 시점에 제네릭 파라미터를 통해 타입 전달</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Sample</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span> 
	<span class="kd">private</span> <span class="no">T</span> <span class="n">anonyTypeData</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="제네릭-메서드">제네릭 메서드</h2>
<p>메서드 호출 시점에 제네릭으로 리턴 타입, 파라미터의 타입이 정해지는 메서드</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span> 
	<span class="kd">static</span> <span class="no">T</span> <span class="nf">getName</span><span class="o">(</span><span class="no">T</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> 
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span> 
	<span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>
<p>static 메서드는 제네릭을 사용할 수 없다.
<br />
인스턴스화 되기전에 메모리에 올라가야 하는데 타입이 결정되지 않았기 때문이다.</p>

<p><br /></p>

<h2 id="제네릭의-타입소거">제네릭의 타입소거</h2>
<p><strong>제네릭의 primitive 타입 사용 불가</strong>
<br />
<strong>타입소거</strong>란 원소 타입을 컴파일 타임에만 검사하고 <strong>런타임에는 해당 타입 정보를 알 수 없는 것</strong>이다. 
<br />
다른 말로는 컴파일 타임에만 타입에 대한 제약 조건을 적용하고, 런타임에는 타입에 대한 정보를 소거하는 것을 말한다.
<br />
제네릭에 primitive 타입을 사용하지 못하는 이유는 타입 소거와 관련이 있다.
<br />
제네릭 클래스는 타입 소거의 첫번째 규칙에 의해 타입 파라미터를 Object로 교체하는데 primitive 타입은 
<br />
Object의 하위 타입이 아니기 때문에 제네릭에서 사용하는 것이 불가능하기 때문이다.</p>

<ul>
  <li>자바 컴파일러의 타입소거규칙
    <ul>
      <li>모든 타입 파라미터를 그들의 바운드나 Object 타입으로 교체한다.</li>
      <li>제네릭 타입을 제거한 후 타입이 일치하지 않으면 타입 캐스팅을 추가한다</li>
      <li>확장된(extended) 제네릭 타입의 다형성을 보존하기 위해 브릿지 메서드를 생성한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="왜쓰는데">왜쓰는데?</h2>
<p>특정 타입으로 종속받지 않아서 편리하다.</p>
<ul>
  <li>재사용성 증가
    <ul>
      <li>여러타입의 파라미터를 삽입할 수 있기 때문에 코드를 간결하게하고 재사용성을 높임</li>
    </ul>
  </li>
  <li>컴파일시 타입에러 발견
    <ul>
      <li>잘못된 타입이 들어오는걸 컴파일 단계에서 방지할 수 있음</li>
      <li>컴파일단계에서 타입에러를 발견할 수 있다.
        <ul>
          <li>즉, 타입시스템을 더욱 견고하게 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>컴파일러가 타입 변환 수행
    <ul>
      <li>컴파일 단계에서 형변환을 해주기때문에 <strong>코드에서 형변환 불필요</strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="타입시스템">타입시스템?</h2>
<p>개발자가 올바른 프로그램을 작성하기 위해 도우미 역할을 하고 컴파일단계에서 타입을 체크하는 대충 뭐 그런거다. 불편하기 때문에 많은 개발자들이 정적타이핑 하는 자바를 버리고 동적타이핑 하는 파이썬, 루비 같은 스크립트 언어로 갈아타는 이유이기도 하다.
<br />
대표적인 프론트엔드, 백엔드 언어인 자바스크립트와 자바는 각각 약타입언어, 강타입언어 라고도 불린다.
<br />
<br />
<strong><em>왜 이런 차이가 발생할까?</em></strong>
<br />
더 고민을 해볼 주제이긴 하지만 일단 한가지 확실한 것은 자바는 보통 서버 언어로 쓰이는 경우가 많다. 
<br />
강타입 언어인 자바를 서버 언어로 채택하는 이유는 바로 서버이기 때문이다. 
<br />
생각해보자 런타임단계가 아닌 컴파일단계에서 강하게 체크를한다? 
<br />
이건 결국 서버에서 고치기 보다 서버에 올라가기 전에 고치려고 하기 때문이다.
<br />
서버에 올라간것을 고치는 것보다 서버에 올라가기전에 고치는것이 훨씬 비용이 적게들기 때문에 최대한 빠른단계
<br />
즉, 컴파일단계에서 실수를 잡는게 좋기 때문이다.
<br />
<br />
ex) 디비에 올라간걸 고치기 힘들잖아… 그러니까 올라가기 전에 잡아야지</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="시간공간-복잡도의-상관관계">시간/공간 복잡도의 상관관계</h1>
<p><br /></p>
<ul>
  <li>시간복잡도 : 특정크기의 연산에 걸리는 절대적인 시간 즉, 연산 횟수</li>
  <li>공간복잡도 : 특정크기의 연산에 드는 메모리 사용량</li>
</ul>

<p><br />
우리가 하는 거의 모든 작업들은 시간복잡도와 공간복잡도를 서로 교환 한다.
<br />
물론 이 둘이 모든 상황에서 정 반대에 있는건 아니다.</p>

<p><br /></p>

<h2 id="caching">Caching</h2>
<ul>
  <li>시간복잡도의 리소스를 공간복잡도의 리소스로 바꾸는거다.</li>
  <li><code class="language-plaintext highlighter-rouge">redis</code>를 사용 해서 데이터를 보다 빠르게 조회할 수 있다면 그만큼 탐색범위를 줄여 시간복잡도를
<br />
줄일 수 있지만 그만큼 캐싱에 들어가는 메모리를 사용해서 공간복잡도는 올라가게 된다.</li>
</ul>

<p><br /></p>

<h2 id="hashmap">HashMap</h2>
<ul>
  <li>해시알고리즘으로 만든 key를 메모리에 올려두고 그 key값만 찾아가면 되기때문에 데이터 크기에 상관 없이 시간복잡도가 O(1)인 대신 그만큼 key값을 저장하는 메모리 공간을 사용하기 때문에 공간복잡도는 올라간다.</li>
</ul>

<p><br /></p>

<h2 id="만약-메모리가-부족하다면">만약 메모리가 부족하다면?</h2>
<p>메모리를 적게 써야하는 상황이라면 공간복잡도를 줄여서 시간을 많이쓰는
<br />
즉, 탐색을 더해서 시간복잡도를 올려야 한다.</p>

<p><br /></p>

<h2 id="의문점">의문점</h2>
<p>보통 공간복잡도 보다 시간복잡도를 더 우위에 두고 작업을 하기 마련이다.
<br />
그렇다면 그 이유는 과거에 비해 하드웨어의 발전이 많이 이루어 졌기 때문이고
<br />
웹 어플리케이션의 등장으로 request / response의 단순함으로 인해 
<br />
메모리에 올려둔 객체들의 생명주기가 짧아져 가비지컬렉터에 의해 금방금방 지워지기 때문일까?</p>

<hr />

<p>틀린 접근은 아니다. 세상이 발전함에 따라 과거보다 현재 시간복잡도가 더 중요하게 되었다.</p>
<ul>
  <li>하드웨어의 폭발적인 발전</li>
  <li>멀티코어를 통한 동시성 개발</li>
  <li>request / response 사이클로 인한 짧은 객체의 생명주기</li>
</ul>

<p>하지만 우리가 접할 기회가 흔한건 아니지만
<br />
여전히 공간복잡도의 한계가 있는 경우가 있다.</p>

<ul>
  <li>빅데이터</li>
  <li>백데이터의 크기
    <ul>
      <li>ex) 구글이 검색을 제공하기 위한 백데이터의 크기</li>
    </ul>
  </li>
  <li>머신러닝이 학습하는 학습데이터는 거대한 메모리를 사용할까? 오랜 학습시간을 들일까?</li>
</ul>

<hr />

<p>명확하지 않은 결론을 내리자면,
<br />
우리는 현재는 시간복잡도를 더 우선해서 경감하는게 더 장점이 많은 시대에 살고있고 
<br />
현업에서 어떠한 규칙으로 삼아도 될 정도이지만 몇십만명이 될지도 모르는 회원정보를 
<br />
<code class="language-plaintext highlighter-rouge">redis</code>에 올리지 않는 것처럼 경우에 따라 적절하게 사용하는것이 중요하겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="nested-class">Nested Class</h1>
<p>중첩클래스(nested class)는 클래스 내에 정의된 클래스를 말한다. 
<br />
중첩클래스는 <code class="language-plaintext highlighter-rouge">static</code>으로 선언되지 않은 내부클래스(inner class)와
<br />
<code class="language-plaintext highlighter-rouge">static</code>으로 선언된 정적 클래스(static class)로 나뉜다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">class</span> <span class="nc">NestedClass</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="inner-class">Inner Class</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kd">class</span> <span class="nc">InnerClass</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OuterClass.a = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>를 인스턴스화 하려면 외부 클래스를 먼저 인스턴스화 해야 한다.
    <ul>
      <li>외부클래스와 <code class="language-plaintext highlighter-rouge">innerClass</code> 두 객체의 참조값은 서로 다르다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 자신을 둘러싼 외부 클래스의 인스턴스 변수 / 메서드에 접근할 수 있다.
    <ul>
      <li>외부클래스 인스턴스에 대한 외부참조를 가지기 때문이다.
        <ul>
          <li>따라서 가비지컬렉션이 수거하지못해 <code class="language-plaintext highlighter-rouge">memory leak</code>의 위험성이 존재한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>외부클래스에선 <code class="language-plaintext highlighter-rouge">inner class</code> 멤버를 사용할수 없다. (사용하려면 객체를 직접 발생시켜야함)</li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 외부클래스의 멤버와 동일한 이름을 사용할 경우 외부클래스 멤버에 접근하고 싶으면 
<br />
명시적으로 나타내야 한다. (OuterClass.this.a)</li>
  <li>외부클래스의 <code class="language-plaintext highlighter-rouge">private</code> 멤버에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 외부 클래스의 멤버이므로 접근제한자를 사용할 수 있다.</li>
  <li>정적 멤버선언(static)이 불가능하다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">final</code>키워드를 사용하면 가능하다.</li>
      <li>자바 16 이후부터는 <code class="language-plaintext highlighter-rouge">inner class</code>에서 정적멤버 생성이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="static-inner-class">Static Inner Class</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">StaticInnerClass</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>같은 <code class="language-plaintext highlighter-rouge">static inner class</code>의 객체를 2개 만들어도 두 객체의 참조값은 서로 다르다.</li>
  <li>정적클래스는 외부 클래스를 인스턴스화 할 필요가 없기 때문에 외부클래스의 변수 / 메서드에 접근할 수 없다. 
<br />
(외부클래스의 static 멤버만 접근 가능)</li>
  <li>정적클래스 내부에서 <code class="language-plaintext highlighter-rouge">static</code> 멤버를 사용할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="local-class">Local Class</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
    	<span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span> <span class="c1">// 로컬 클래스</span>
    		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
    			<span class="c1">// ...</span>
    		<span class="o">}</span>
    	<span class="o">}</span>    	
    	<span class="nc">LocalClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LocalClass</span><span class="o">();</span>
    	<span class="n">obj</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>패키지나 클래스의 멤버가 아니므로 접근제어자 사용 불가</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> 멤버 선언 불가</li>
  <li>객체 생성은 외부에서 불가능하고, 내부에서만 가능</li>
</ul>

<p><br /></p>

<h2 id="익명-클래스">익명 클래스</h2>
<p>펑션을 상속받는? 이름이 없는 로컬클래스.
<br />
선언과 동시에 초기화가 이루어 진다.
<br />
이름이 없기 때문에 익명클래스는 객체를 여러번 생성할 수 없으며 생성자를 만들수도 없다.
<br />
클래스가 딱 한번만 필요할 때 (일회용) 유용하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Ex</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
	
	<span class="nc">Inner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Inner</span><span class="o">()</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"overriding"</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">printX</span><span class="o">()</span> <span class="o">{</span>
			<span class="c1">//익명 클래스 안에서 메서드를 생성하여 사용 가능</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method 추가"</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>Outer Class의 지역변수가 <code class="language-plaintext highlighter-rouge">final</code> 로 선언되어야만 접근 가능</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> 멤버 선언 불가</li>
  <li>멤버 인터페이스 선언 불가</li>
</ul>

<p><br /></p>

<h3 id="장점">장점</h3>
<hr />
<p>어느 메서드에서 <strong>부모 클래스의 자원을 상속받아 재정의하여 사용할 자식 클래스가 한번만 사용</strong>되고 버려질 자료형이면, 굳이 상단에 클래스를 정의하기보다는, <strong>지역 변수처럼</strong> 익명 클래스로 정의하고 스택이 끝나면 삭제되도록 하는 것이 유지보수면에서나 프로그램 메모리면에서나 이점을 얻을 수 있다.
<br />
<br />
즉, 익명 클래스는 재사용할 필요가 없는 일회성 클래스를 굳이 클래스를 정의하고 생성하는 것이 비효율적이기 때문에, 익명 클래스를 통해 <strong>코드를 줄이는 일종의 기법</strong>이라고 말 할 수 있다.
<br />
<br />
다만, 익명 클래스 방식으로 선언한다면 <strong>오버라이딩 한 메서드 사용</strong>만 가능하고,
<br />
<strong>새로 정의한 메서드는 외부에서 사용이 불가능</strong> 하다.</p>

<p><br /></p>

<h2 id="활용">활용</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 참조값을 담아야 하기 때문에 인스턴스 생성시 시간,공간적으로 성능이 낮아진다.</li>
  <li><code class="language-plaintext highlighter-rouge">static inner class</code>는 외부 인스턴스에 대한 참조가 존재하기 때문에, 
<br />
<strong><em>가비지 컬렉션이 인스턴스 수거를 하지 못하여 memory leak이 생길 수 있다.</em></strong></li>
  <li><code class="language-plaintext highlighter-rouge">static inner class</code>를 사용하는 것이 좋으며 <code class="language-plaintext highlighter-rouge">static</code> 키워드를 사용하고싶지 않으면 별개의 클래스로 만드는 것이 좋다.</li>
  <li>하지만 <strong><em>Lambda</em></strong> 의 경우 얘기가 조금 달라지는데…</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="람다">람다</h1>
<p>익명 함수 (Anonymous functions) 를 지칭하는 용어이다.
<br />
익명함수란 함수의 이름이 없는 함수이고 익명함수들은 공통적으로 일급객체 이다.</p>

<ul>
  <li><strong>일급객체</strong> : 다른 객체들에 적용 가능한 연산을 모두 지원가는 객체.
<br />
함수를 값으로도 사용할 수 있고 파라미터로 전달 및 변수에 대입도 가능하다.</li>
</ul>

<p><br />
<strong>Stream</strong> 연산들은 매개변수로 함수형 인터페이스를 받도록 되어있다.
<br />
그리고 람다식은 반환값으로 함수형 인터페이스를 반환하고 있다.
<br />
즉, 람다식이란 <strong>함수를 하나의 식</strong>으로 표현한 것이다.
<br />
함수를 람다식으로 표현하면 메서드의 이름이 필요 없기 때문에, 람다식은 익명 함수의 한 종류라고 볼 수 있다.</p>

<p><br /></p>

<h2 id="특징-1">특징</h2>
<ul>
  <li>람다식 내에서 사용되는 지역변수는 <code class="language-plaintext highlighter-rouge">final</code> 키워드가 붙지않아도 상수로 간주된다.
    <ul>
      <li>람다의 병렬처리가 <code class="language-plaintext highlighter-rouge">Thread safety</code> 한 이유이다.</li>
    </ul>
  </li>
  <li>람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.</li>
</ul>

<p><br /></p>

<h2 id="장점-1">장점</h2>
<ul>
  <li>지연연산수행 : 지연연산을 수행함으로써 불필요한 연산을 최소화 할 수 있다.
    <ul>
      <li><strong>지연연산</strong>이라는 단어 뜻이 헷갈리는데, 
  <br />
  메서드를 호출하여 사용하려면 클래스를 만들고 클래스를 인스턴스화 하여 해당 메서드에 접근해야 하는데 이 과정을 수행하기 위해선 클래스가 반드시 초기화 되어야 된다는 의미이다.
  <br />
  여기서 <strong><em>람다식</em></strong> 을 사용하면 이런 과정 없이 필요한 순간에 <strong>1회용으로 익명함수</strong>를 정의하고 바로 호출하면 되므로 클래스의 초기화가 필요 없다는 의미이다.</li>
    </ul>
  </li>
  <li>코드의 간결성 : 불필요한 반복문의 삭제가 가능하며 단순하게 표현할 수 있다.</li>
  <li>함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.</li>
  <li>메서드를 변수처럼 다루는 것이 가능해진다.</li>
  <li><strong><em>병렬처리 : 멀티스레드를 활용한 병렬처리에 안전하다.</em></strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Stream</code>은 람다식을 사용해 별도의 스레드에서 병렬 처리를 관리한다.</li>
      <li>람다의 외부 참조변수가 항상 <code class="language-plaintext highlighter-rouge">final</code>이어야만 하는 이유이다.</li>
      <li>즉, <strong>동시성 문제</strong>에 자유롭다.</li>
      <li>어플리케이션의 크기가 거대해 짐에 따라 멀티스레드 환경에서 데이터의 무결성을 보장하는, 
  <br />
  자바에서 함수형 프로그래밍인 <strong>람다</strong> 를 도입한 이유중 가장 큰 이유 중 하나 라고 생각한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="단점">단점</h2>
<ul>
  <li>람다를 사용하면서 만든 익명함수는 재사용이 불가능하다.</li>
  <li>디버깅이 어렵다.</li>
  <li>남발할 시 오히려 가독성이 떨어진다.</li>
  <li>람다의 <code class="language-plaintext highlighter-rouge">Stream</code>은 전통적인 for문에 비해 성능이 떨어진다.
    <ul>
      <li>하지만 람다를 사용하는 이유는 이제는 성능상의 이점보다 <strong>데이터 무결성</strong> 이 더 중요해진 건 아닐까?</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="stream">Stream</h2>
<p>다양한 데이터를 표준화된 방법으로 다루기 위한 라이브러리 - <strong>Java8</strong>에 추가
<br />
<code class="language-plaintext highlighter-rouge">Stream</code>의 문법에 대해서는 이 글에서 다루지 않는다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Stream</code>의 특징
    <ul>
      <li>데이터를 변경하지 않는다.</li>
      <li>1회용 이다.</li>
      <li>지연 연산을 수행한다.</li>
      <li>병렬 실행이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="의문점-1">의문점</h2>

<ul>
  <li><strong><em>람다는 일종의 <code class="language-plaintext highlighter-rouge">inner class</code> 인데 가비지컬렉터의 메모리 누수에는 안전하다 알아보자.</em></strong>
<br />
<br />
자바에서 모든 메서드는 반드시 클래스 안에 소속되어 있어야 한다. 메서드를 만들기 위해서는 클래스를 만들어줘야 하고 클래스를 만들려면 생성자를 비롯한 멤버들도 구성해야 한다. 
<br />
그리고 이 메서드를 사용하려면 별도로 <code class="language-plaintext highlighter-rouge">instance</code>를 생성해서 이 <code class="language-plaintext highlighter-rouge">instance</code>를 통해 메서드를 호출해야 한다.
<br />
하지만 람다로 일회용 메서드를 활용한다면 이 과정이 필요 없다.
<br />
즉, 인스턴스화를 시키지 않기 때문에 람다는 외부클래스 인스턴스에 대한 외부참조가 없고
<br />
따라서 가비지컬렉터가 수거하지 못하는 상황이 일어나지 않아 <code class="language-plaintext highlighter-rouge">memory leak</code>에 안전한 것이다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="collection">Collection</h1>
<hr />

<p><br />
<br />
<br />
<br /></p>

<h1 id="중복에-관한-의문점">중복에 관한 의문점</h1>
<hr />
<p>객체지향의 장점인 재사용성(상속, 다형성 등) 을 보면 중복은 좋지 않다?
<br />
유지보수 관점에서 중복을 하는것이 좋을지, 중복을 제거하는것이 좋을지 고려해야 한다.
<br />
멀티모듈의 최상위 모듈을 하나두고 설계하는 패턴의 장,단점과 관련이 있다고 한다.</p>

<p><br /></p>

<h2 id="중복이-나쁜경우">중복이 나쁜경우</h2>
<p>중복은 중복을 부르고, 논리의 조그마한 실수도 큰 오류가 날 가능성이 높아진다.
<br />
또한 어플리케이션이 복잡해 질수록 생산성은 떨어진다.
<br />
대부분의 경우 중복은 좋지 않다.</p>

<p><br /></p>

<h2 id="중복이-차라리-나은경우">중복이 차라리 나은경우</h2>
<p>자원의 효율적인 사용이나 중복으로 인한 문제 발생보다 시스템의 안정성을 위주로 할 경우
<br />
코드의 중복 보다는 인스턴스들의 중복이 포인트이다.
<br />
예를들면, 인스턴스를 여러개 둘 수 있지만, 그 인스턴스를 만드는 코드는 하나만 존재해야 한다.
<br />
이렇지 않을 경우 언제나 동기화를 시켜주는 문제가 발생할 수도 있다.
<br />
또한 중복코드가 서로 의존을 해서 순환참조가 발생할 때?
<br /></p>

<h2 id="멀티모듈의-설계">멀티모듈의 설계?</h2>
<p>모듈은 패키지의 한단계 위의 집합체이며, 관련된 패키지와 리소스들을 재사용할 수 있는 그룹이라고 정의한다.</p>

<p><br /></p>

<h3 id="msa프로젝트를-구성할-때-문제점">MSA프로젝트를 구성할 때 문제점</h3>
<hr />
<p>인증 서버, API서버, 배치서버 등을 각각 나누다 보니 기존 모놀리식에선 신경쓰지 못했던 문제중 하나가 중복코드의 문제이다.
<br />
<code class="language-plaintext highlighter-rouge">ResponseEntity</code>, <code class="language-plaintext highlighter-rouge">ExceptionHandler</code> 등의 모든 서버에서 쓰이는 로직은 서버 전부에서 코드를 가지고 있어야 했고, 변경되면 모두 다 바꿔줘야하는 비효율적인 문제가 발생한다. 
<br />
IDE를 몇개씩 띄워놓고 서버를 돌리는것도 힘들기 때문에 멀티프로젝트로 구성되 있던 서비스를 멀티모듈로 전환하는 경우도 많이 있다.</p>

<p><br /></p>

<h3 id="멀티모듈">멀티모듈</h3>
<hr />
<p>공통적인 기능을 모아 하나의 모듈(common)로 만들고 각 모듈에서 의존한다.
<br />
<strong>common 모듈에 공통로직을 몰아넣는다?</strong>
<br />
<strong>아니다.</strong> 어느 정도의 중복을 기준으로 common module 에 넣을 것이고, 어디까지의 역할만 시킬 것인지를 확실하게 나눠야 한다. 그렇지 않으면 common이 점 차 커지며 common안에 비즈니스가 흐르기 시작하고,
<br />
이것이 어쩔수 없이 반복되고 결국 다른 애플리케이션은 날씬하고 common만 굉장이 큰 프로젝트가 되버리는 지옥이 발생한다.</p>

<p><br /></p>

<h3 id="멀티모듈의-장점">멀티모듈의 장점</h3>
<hr />
<ul>
  <li>코드의 중복을 줄일 수 있다.
  공통된 로직이 있는 여러 서비스를 운영할 때, 공통부분을 모듈화 하고 이 의존성을 추가하여 공유할 수 있다.</li>
  <li>각 모듈의 기능을 파악하기 쉽다.
  공통의 기능은 의존송 주입으로, 모둘별로 기능을 분리하여 코드이해에 도움이 된다.</li>
  <li>독립된 jar 로 단독 실행 가능
    <ul>
      <li>빌드도 쉬워진다.</li>
    </ul>
  </li>
  <li>독립된 모듈(library)로서 여기저기서 가져다 쓸 수 있는 확장성</li>
  <li>모듈별로 사용하는 의존성 (버전포함)을 다르게 관리할 수 있음</li>
</ul>

<p><br /></p>

<h3 id="주의할점">주의할점</h3>
<hr />
<ul>
  <li>공통 모듈이 가져야 하는 의존성을 고려해야 한다.</li>
  <li>특정 모듈에선 불필요한 의존성으로 인해 어플리케이션이 무거워 질 수 있다.
    <ul>
      <li>모든 모든 모듈에서 전역적으로 적용되어야 할 때 common모듈에 넣자</li>
    </ul>
  </li>
  <li>각 어플리케이션(모듈)에 대한 설정은 공통 모듈에 적용하지 않고 분리한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Generic" /><category term="시공간복잡도" /><category term="Nested Class" /><category term="Multi Module" /><category term="Lambda" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">3 Week</title><link href="http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="3 Week" /><published>2022-12-29T00:00:00+09:00</published><updated>2022-12-29T00:00:00+09:00</updated><id>http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="property">Property</h1>
<p>속성이란 뜻이다. 해당 <code class="language-plaintext highlighter-rouge">Object</code>의 특징.
<br />
사람을 예로들면 피부색, 키, 나이, 몸무게 등이다.
<br />
Property의 읽기와 쓰기는 일반적으로 <code class="language-plaintext highlighter-rouge">getter</code> 와 <code class="language-plaintext highlighter-rouge">setter</code> 메서드 호출로 변환된다.</p>
<ul>
  <li>자바는 property가 없고 코틀린이나 자바스크립트는 property를 사용 이건 왜그래?</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="string">String</h1>
<p>자바에서 제일 많이 사용되는 String은 <strong>특별대우</strong>를 받는다.
<br />
Reference Type 이지만 기본적인 사용은 Primitive Type 이다.
<br />
String 객체생성은 2가지 방법이 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"kim"</span><span class="o">;</span>			<span class="c1">// 리터럴로 생성</span>
<span class="nc">String</span> <span class="n">name2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"lee"</span><span class="o">);</span>	<span class="c1">// new 연산자로 생성</span>
</code></pre></div></div>
<ul>
  <li><strong>new</strong> : 일반 객체들처럼 힙 영역에 할당된다.</li>
  <li><strong>리터럴</strong> : <code class="language-plaintext highlighter-rouge">Constant Pool</code> 영역에 할당된다.
    <ul>
      <li>String의 intern()메서드를 호출한다.
        <ul>
          <li>intern() 메서드 : <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 생성하려는 문자열이 존재할 경우 주소값을 반환하고 
  <br />
  없으면 객체 생성 후 주소값을 반환한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="constant-pool">Constant Pool</h2>
<p>문자열 리터럴을 사용해서 생성한 String 객체가 담기는 곳이며 자바8 이후 힙 영역에 속한다.
<br />
같은 문자열을 각각 2개씩 리터럴과 new연산자로 생성했을 때, new 연산자로 생성된 문자열은 서로 다른객체를 만들고 바라보지만 리터럴로 생성해 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 담긴 두 객체는 동일한 객체를 바라본다.</p>

<p><br /></p>

<h2 id="string은-불변immutable하고-thread-safe-하다">String은 불변(immutable)하고 thread-safe 하다.</h2>
<p>문자열 리터럴은 불변이기 때문에 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에서 문자열이 같다면 동일한 객체를 참조할 수 있다.</p>
<ul>
  <li><strong><em>static String?</em></strong>
<br />
  두개의 클래스의 각각 <code class="language-plaintext highlighter-rouge">static String abc = "abc";</code> 를 선언하고
  해시코드 값을 출력해보면 동일하다.
  <br />
  즉, <code class="language-plaintext highlighter-rouge">static</code> 으로 선언해도 동일성과 동등성이 보장된다.</li>
</ul>

<p><br /></p>

<h2 id="string-연산">String 연산</h2>
<p><code class="language-plaintext highlighter-rouge">Constant Pool</code>의 특성 때문에 연산을 하게되서 문자열이 변경될 경우 기존 객체는 불변이기 때문에 새로운 객체를 만들고 해당 객체를 참조한다. 그리고 곧 참조가 사라진 기존 문자열은 가비지컬렉터의 수집 대상이 된다.
<br />
그렇기 때문에 문자열의 <code class="language-plaintext highlighter-rouge">+ 연산</code> 또는 <code class="language-plaintext highlighter-rouge">concat 연산</code> 은 좋지 않다.
<br />
아래 두 클래스는 내부 Buffer에 문자열을 저장해두고 그 안에서 추가,수정,삭제 등을 작업할 수 있다.</p>

<ul>
  <li><strong>StringBuffer</strong>
    <ul>
      <li>StringBuilder 보다 성능이 좋지 않다.</li>
      <li>동기화를 지원하여 thread-safe 하다.</li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuilder</strong>
    <ul>
      <li>StringBuffer 보다 성능이 좋다</li>
      <li>동기화를 지원하지 않아 thread-safe 하지 않다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="활용">활용</h3>
<hr />
<p>새로운 객체를 만들지 않고 문자열을 수정할 수 있기 때문에 참조가 끊어진 String 객체가
<br />
가비지컬렉션에 의해 메모리 해제를 기다리지 않아도 된다.
<br />
하지만 buffer의 크기를 초기에 설정해줘야 해서 생성속도가 String 객체보다 느리고 read가 느리다.
<br />
문자열 수정을 할 경우에도 Buffer의 크기를 줄이고 늘리고 명칭을 변경하는 등의 연산이 필요하다.</p>

<ul>
  <li><strong>String</strong>
    <ul>
      <li>문자열의 연산이 적을 경우</li>
      <li>빠른 조회 성능을 기대해야 할때</li>
      <li>문자열 연산이 적고 멀티스레드 환경일 경우</li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuffer</strong>
    <ul>
      <li>문자열 연산이 많을 경우</li>
      <li>thread-safe 이 필요한 경우
        <ul>
          <li>멀티스레드 환경</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuilder</strong>
    <ul>
      <li>문자열 연산이 많을 경우</li>
      <li>thread-safe 이 필요하지 않은 경우
        <ul>
          <li>단일스레드 환경</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="jdk-15-이후">JDK 1.5 이후</h3>
<hr />
<p>자바 1.5 이후  String의 <code class="language-plaintext highlighter-rouge">immutable</code>속성의 문제점을 해결하기 위해 도입되었다.
<br />
그래서 자바 1.5 이후 <code class="language-plaintext highlighter-rouge">한줄 +</code> 연산시 자동으로 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 로 자동변환되어 성능 최적화를 이뤘다.
<br />
하지만 <code class="language-plaintext highlighter-rouge">여러줄 +</code> 연산할 경우 매 연산마다 새로운 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 객체를 선언한다.
<br />
또한 for문 같은 반복문같은 경우에도 컴파일러가 최적화를 해주지 못하고 있다.
<br />
추가로 <code class="language-plaintext highlighter-rouge">concat</code> 연산은 컴파일러가 아예 최적화를 해주지 못한다.
<br />
그냥 문자열 연산에는 <code class="language-plaintext highlighter-rouge">StringBuffer / StringBuilder</code> 를 쓰도록 하자.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="annotation">Annotation</h1>
<p><code class="language-plaintext highlighter-rouge">Annotation</code> 의 사전적인 의미로는 주석이다.
<br />
자바에서는 코드사이에 주석처럼 쓰여서 특별한 의미, 기능을 수행하도록 한다.
<br />
프로그램에게 추가정보를 제공해주는 메타데이터라고 볼 수 있다.
<br />
이 클래스에게 어떤 역할을 줄까? 이 속성을 어떤용도로 사용할까?</p>

<ul>
  <li>메타데이터 : 데이터를 위한 데이터</li>
</ul>

<p><br /></p>

<h2 id="용도">용도</h2>
<ul>
  <li>컴파일러에게 에러를 체크하도록 정보 제공</li>
  <li>빌드나 패치 시 코드를 자동으로 생성할 수 있도록 정보 제공</li>
  <li>런타임단계에서 특정 기능을 실행하도록 정보 제공</li>
</ul>

<p><br /></p>

<h2 id="설정">설정</h2>
<ul>
  <li><strong>@Target</strong> : 적용대상
    <ul>
      <li>어디(클래스, 필드, 메서드…)에 <code class="language-plaintext highlighter-rouge">Annotation</code> 을 적용할지</li>
    </ul>
  </li>
  <li><strong>@Retention</strong> : 정보유지되는 대상
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Annotation</code> 값들을 언제까지 유지할 것인지 (대부분 Runtime)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="왜쓰는데">왜쓰는데?</h2>
<p><code class="language-plaintext highlighter-rouge">Annotation</code> 을 붙일 타겟과 유지시기 등을 설정해 자신이 원하는 용도로 활용이 가능하다.
<br />
이것은 비즈니스 로직과는 별도로 시스템 설정과 관련된 부가적인 사항들을 <code class="language-plaintext highlighter-rouge">Annotation</code>
<br />
에게 위임하고 개발자는 비즈니스 로직 구현에만 집중할 수 있도록 하는 일종의 <code class="language-plaintext highlighter-rouge">AOP</code>
<br />
즉, <code class="language-plaintext highlighter-rouge">Annotation</code> 을 사용함으로써 관심사의 분리를 가능하게 한다는 의미기도 하다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="exception">Exception</h1>
<p>예외는 기본적으로 폭탄돌리기와 같다.
<br />
처리하거나 처리 <code class="language-plaintext highlighter-rouge">try catch</code> 할 수 없다면 <code class="language-plaintext highlighter-rouge">throw</code> 즉, 던져야 한다.
<br />
예외를 처리하지 못하고 계속 던지게 되면 결국 메인메서드까지 던져지게 되고 결국 어플리케이션이 종료된다.</p>

<p><img src="/images/2021-05-10-first-posting/exception%EA%B3%84%EC%B8%B5.png" alt="이미지" /></p>

<ul>
  <li>
    <p>Throwable : 최상위 예외 이며, 객체이기 때문에 <code class="language-plaintext highlighter-rouge">Object</code>를 상속받는다.</p>
  </li>
  <li>
    <p>Error : 메모리부족, 시스템 오류같은 어플리케이션 레벨에서 복구가 불가능한 시스템 장애이다.
<br />
<code class="language-plaintext highlighter-rouge">Exception</code>과 <code class="language-plaintext highlighter-rouge">Error</code>는 다르다</p>
  </li>
  <li>
    <p><strong><em>상위 예외를 잡으면 하위 예외까지</em></strong> 잡아버리기 때문에 어플리케이션에선 <code class="language-plaintext highlighter-rouge">Exception</code> 예외부터 필요한 예외로 잡아야 한다.
<br />
또한, <code class="language-plaintext highlighter-rouge">Layer</code>에 역할에 맞는 <code class="language-plaintext highlighter-rouge">Exception</code>을 던질 필요가 있다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="checked-exception"><strong><em>Checked Exception</em></strong></h2>
<p><code class="language-plaintext highlighter-rouge">Exception</code>을 상속받는 예외는 <code class="language-plaintext highlighter-rouge">checked exception</code>이 되며 <code class="language-plaintext highlighter-rouge">Exception</code>은 어플리케이션에서 사용할 수 있는 실질적인 최상위 예외이다. 컴파일러가 체크하며 잡아서 처리하거나, 또는 밖으로 던지도록 선언해야 한다.
<br />
예외 발생 시 트랜잭션 <code class="language-plaintext highlighter-rouge">roll-back</code> 처리를 하지 않는다. 
<br />
(복구가 가능하다는 매커니즘을 가지고 있기 때문에 복구를 하라고 하고 롤백은 처리하지 않겠다 아닐까?)
<br />
<strong><em>단, RuntimeException을 상속받는 경우 unchecked exception이 된다.</em></strong></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>예외를 처리하거나 밖으로 던지는 <code class="language-plaintext highlighter-rouge">throw</code> 를 필수로 선언해야 컴파일 오류가 발생하지 않기 때문에 
  <br />
  개발자가 실수로 누락하는 상황이 발생하지 않는다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>모든 체크예외를 반드시 잡거나 던지도록 처리해야 한다.</li>
      <li>의존관계 문제가 발생한다.
        <ul>
          <li>예를들어 <code class="language-plaintext highlighter-rouge">Controller / Service</code> 등에서 SQL예외를 던졌을때 해당 클래스에서 <code class="language-plaintext highlighter-rouge">SQLException</code>을 의존하게 된다. 이럴경우 JDBC가 아닌 JPA같은 기술로 변경할 시 모든 코드를 고쳐야한다. 
  <br />
  즉, <code class="language-plaintext highlighter-rouge">OCP / DI</code>를 위반한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><em>활용</em></strong>
<br />
  기본적으로 <code class="language-plaintext highlighter-rouge">unecked exception</code>을 사용하자. <code class="language-plaintext highlighter-rouge">checked exception</code>은 비즈니스 로직상 반드시 처리해야 하는 경우에만 (계좌 이체 실패, 결제시 포인트 부족 등)
  <br />
  즉, 개발자가 실수로 놓치게 되면 치명적인 문제가 발생하는 경우에 컴파일러의 도움을 받기위해 사용하자.
  <br />
  또한, <code class="language-plaintext highlighter-rouge">catch</code> 절에서 딱히 할일이 없을 경우 사용하지 말고 확실히 할일이 있는 경우에 사용하자</p>
  </li>
  <li>대표적인 <code class="language-plaintext highlighter-rouge">Exception</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IOException</code></li>
      <li><code class="language-plaintext highlighter-rouge">SQLException</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="unchecked-exception"><strong><em>UnChecked Exception</em></strong></h2>
<p><code class="language-plaintext highlighter-rouge">RuntimeException</code>과 그걸 상속받는 예외들은 <code class="language-plaintext highlighter-rouge">unchecked exception</code>이다.
<br />
컴파일러가 체크하지 않는 예외이며 <code class="language-plaintext highlighter-rouge">throw</code>를 생략할 수 있고 이럴 경우 자동으로 예외를 던진다.
<br />
즉, 예외를 잡아서 처리하지 않아도 <code class="language-plaintext highlighter-rouge">throw</code>를 생략할 수 있다.
<br />
예외 발생 시 트랜잭션 <code class="language-plaintext highlighter-rouge">roll-back</code> 처리를 한다.</p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">throw</code> 생략으로 예외를 무시할 수 있다.</li>
      <li>시스템에서 발생하는 복구가 불가능한 예외에 대해 신경쓰지 않아도 된다.</li>
      <li>신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>컴파일 단계에서 체크가 안되기 때문에 실수할 가능성이 있다.</li>
    </ul>
  </li>
  <li>대표적인 <code class="language-plaintext highlighter-rouge">Exception</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NullPointerException</code></li>
      <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="예외-던져도-안죽던데">예외 던져도 안죽던데?</h2>
<p>웹 어플리케이션은 <code class="language-plaintext highlighter-rouge">servlet</code>의 오류 페이지나, 또는 <code class="language-plaintext highlighter-rouge">Spring MVC</code>가 제공하는 <code class="language-plaintext highlighter-rouge">ControllerAdvice</code> 에서 이런 예외를 공통으로 처리해 주기 때문에 예외가 메인메서드까지 가지 않는다.</p>
<ul>
  <li>하지만 이런 문제들은 클라이언트 입장에선 어떤 문제가 발생했는지 자세히 알기 어렵다.</li>
  <li><code class="language-plaintext highlighter-rouge">API</code>라면 HTTP 상태코드 <code class="language-plaintext highlighter-rouge">500</code>으로 응답을 내려준다.</li>
  <li>수정하기 전까진 해결되지 않으므로 별도의 오류 로그를 남기고 메일, 알림등을 통해 
<br />
개발자가 빨리 인지할 수 있도록 처리해두는게 좋다.</li>
</ul>

<p><br /></p>

<h2 id="자바의-checked-exception-도입">자바의 Checked Exception 도입?</h2>
<p>자바의 <code class="language-plaintext highlighter-rouge">Checked Exception</code>은 자바만의 독특한 특징이다.
<br />
<strong><em>“강제성이 없기 때문에 실수할 여지가 있다”</em></strong> 를 해결하기위해 도입했지만
컴파일단계에서 예외를 처리하라고 
<br />
강요하는 <code class="language-plaintext highlighter-rouge">Checked Exception</code> 은 자바 이후 설계된 <code class="language-plaintext highlighter-rouge">C#</code> 이나 <code class="language-plaintext highlighter-rouge">ruby</code>등에서도 채택되지 않았다.
<br />
요즘은 극단적으로 자바의 <code class="language-plaintext highlighter-rouge">Checked Exception</code> 도입은 실패라는 주장도 심심치 않게 보인다.
<br />
<code class="language-plaintext highlighter-rouge">JDBC API</code>에서는 <code class="language-plaintext highlighter-rouge">Checked Exception</code>을 남발하고 <code class="language-plaintext highlighter-rouge">catch</code>절에서 아무것도 하지 않았고 
<br />
이런 문제점을 알고 그후에 <code class="language-plaintext highlighter-rouge">JDBC</code>를 활용한 <code class="language-plaintext highlighter-rouge">Spring-JdbcTemplet</code>, <code class="language-plaintext highlighter-rouge">Hibernate</code>, <code class="language-plaintext highlighter-rouge">JPA</code> 등에서는 
<br />
<code class="language-plaintext highlighter-rouge">Checked Exception</code>인 <code class="language-plaintext highlighter-rouge">SQLException</code>을 볼수 없게 설계되었고 이런 사례들을 보면 자바의 
<br />
<code class="language-plaintext highlighter-rouge">Checked Exception</code>은 도입은 논란의 여지가 있는듯 하다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="의문점">의문점</h1>
<p>가비지컬렉터는 알아서 메모리를 관리해 주는데, 결국 한계점에선 Major GC를 실행할 수 밖에 없고
<br />
이것이 실행되는 동안에는 결국 <code class="language-plaintext highlighter-rouge">stop the world</code> 즉, JVM이 멈추게 되는 현상이 발생하는데 그렇기 때문에
<br />
과거에는 GC를 튜닝해서(도메인에 따라 메모리 관리가 틀리기 때문에) 이런 현상이 최대한 적게 일어나게
<br />
하는것이 한동안 이슈였다.<br />
<br />
그렇다면 하나의 큰 JVM 말고 여러개의 소규모 컨테이너로 JVM을 실행하면? 마치 로드밸런싱과도 비슷한데..
<br />
이렇게 하면 하나의 JVM에서 Major GC가 발생해도 어플리케이션 전체가 <code class="language-plaintext highlighter-rouge">stop the world</code>에 빠지진 않는데?
<br />
하지만 이 방법은 JVM이 나뉘어 짐에 따라 스택프레임을 공유할 수 없다는 단점이 있는데
<br />
<br />
요즘은 웬만한 프로그램도 웹어플리케이션으로 패러다임이 움직임에 따라 프로그램은 
<br />
request -&gt; response 이후 스레드가 종료되는 단순한 형태로 바뀌기 시작했고
<br />
그 결과 스택프레임을 공유하는 빈도 수 가 줄면서 GC튜닝 이슈는 좀 사그라 들었다.
<br />
하지만 완벽한 해결법은 아니고 자바 11 이후 GC의 방식이 조금 바뀌었다. 하지만 이것도 장단점..</p>

<p><br /></p>

<h2 id="자바-11-이후-바뀐-가비지컬렉션에-대해-자세히-알아보자">자바 11 이후 바뀐 가비지컬렉션에 대해 자세히 알아보자</h2>
<ul>
  <li>
    <p><strong><em>Generational GC</em></strong>
<br />
JDK 7부터 본격적으로 사용할 수 있는 G1 GC를 제외한, Oracle JVM에서 제공하는 모든 GC</p>
  </li>
  <li>
    <p><strong><em>The Serial GC</em></strong>
<br />
가장 단순한 GC이지만 사용하지 않는 것을 추천한다. 싱글 쓰레드 환경을 위해 설계 되었고 아주 작은 Heap영역을 가진다. 
<br />
Full GC가 일어나는 동안 애플리케이션 전체가 대기해야하는 현상이 발생하기 때문에 서버 애플리케이션에 적당하지 않다.</p>
  </li>
  <li>
    <p><strong><em>Parallel GC</em></strong>
<br />
Java 8의 디폴트 GC이고 병렬로 GC한다. 
<br />
메모리가 충분하고 CPU의 성능과 코어 개수가 많아 순간적으로 트래픽이 몰려도 일시 중단을 견딜 수 있고 GC에 의해 야기된 CPU 오버 헤드에 대해 최적화할 수 있는 애플리케이션에 가장 적합하다.</p>
  </li>
  <li>
    <p><strong><em>G1(Garbage First) GC</em></strong>
<br />
<strong>대용량 메모리가 있는 다중 프로세서 시스템을 대상</strong>으로 하는 서버-스타일 가비지 컬렉터이다.
<br />
GC GC는 Generational 한 알고리즘과는 다르게 백그라운드의 멀티 쓰레드를 활용해 1MB에서 32MB까지의 수 많은 리젼으로 Heap을 분할한다.
<br />
G1 GC는 위와 같이 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면
<br />
다른 영역에서 객체를 할당하고 GC를 실행한다. 
<br />
즉, 지금까지 설명한 Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식이라고 이해하면 된다.
<br />
<br />
G1 GC의 가장 큰 장점은 성능이다. 
<br />
G1은 지연 시간을 줄이기 위해서 지금까지 설명한 어떤 GC 방식보다도 빠르다.
<br />
하지만 이와 같이 4GB 이상의 큰 Heap을 가지는 것은 요즘과 같이 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 
<br />
지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다.
<br />
이러한 Garbage Collector에 대한 변화는 Parallel GC와 같이 처리량을 극대화하는 것보다 GC의 지연 시간을 제한하는 것이 더 중요하다는 가정 하에 이루어졌다</p>
  </li>
</ul>

<p><br /></p>

<h2 id="튜닝">튜닝?</h2>
<p>JVM을 튜닝한다는 의미는 기존 GC 에서 Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 노력이다.
<br />
Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생하거나 
<br />
Full GC 횟수가 늘어난다. 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. 
<br />
Old 영역의 크기를 적절하게 <strong>잘</strong> 설정해야 한다.
<br />
G1 GC를 제외한 GC에서는 JVM Heap을 무한정 늘리면 Full GC 시간 증가로 인해 오히려 성능 병목이 될 수 있다.
<br />
JVM의 Heap을 증가시키기 보다는 JVM의 인스턴스를 늘려 클러스터링이나 로드밸런서로 가용성을 확보하는 방법을 권장한다.
<br />
<br />
<br />
멀티코어상황에서 유용하다는데? 알아보자</p>

<p><br /></p>

<h2 id="스택프레임에-대해-알고있는-것보다-더-자세히-알아보자">스택프레임에 대해 알고있는 것보다 더 자세히 알아보자</h2>

<p><br /></p>

<h2 id="하나의-jvm으로-띄우는-것과-여러개의-컨테이너로-띄우는-것의-장단점에-대해-자세히-알아보자">하나의 JVM으로 띄우는 것과 여러개의 컨테이너로 띄우는 것의 장단점에 대해 자세히 알아보자</h2>
<p>노드js에선 쓰고있는거 같던데?</p>

<p><br /></p>

<h2 id="멀티코어에서의-jvm과-멀티스레드">멀티코어에서의 JVM과 멀티스레드</h2>
<p>과거에는 싱글코어의 성능을 극한으로 올렸다. 하지만 전력소모, 코어의 면적을 넓히는 방식으로의 해결등이 한계에 다다르면서 코어 수를 늘려서 CPU 전체의 성능을 향상하는 쪽으로 발전했다.</p>

<ul>
  <li>멀티코어 : 2개 이상의 독립코어를 단일 직접회로로 이루어진 하나의 CPU로 통합한 것</li>
  <li>프로세서 : 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛 즉, 중앙처리장치 혹은 CPU
    <ul>
      <li>소프트웨어적으로는 데이터포맷을 변환하는 역할을 수행하는 프로세싱 시스템
        <ul>
          <li>워드프로세서, 컴파일러, 어셈블러 등</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프로세스 : 메모리에 적재되어 프로세서에 의해 실행중이거나 대기중인 프로그램</li>
</ul>

<p><br /></p>

<ul>
  <li>멀티스레드
    <ul>
      <li>프로세스를 생성하여 자원을 할당하는 운영체제의 시스템콜이 줄어든다.</li>
      <li>프로세스간 통신보다 스레드간의 통신의 비용이 적다.</li>
      <li>힙영역을 공유하므로 동기화 문제에 안전하지 않다.</li>
      <li>하나의 스레드에 문제가 생기면 전체 프로세스 전체가 영향을 받는다.</li>
    </ul>
  </li>
  <li>멀티프로세스
    <ul>
      <li>하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않는다.</li>
    </ul>
  </li>
</ul>

<p>JVM은 하나의 프로세스에서 동작한다.
<br />
하나의 프로세스는 여러 작업단위를 가질 수 있는데 이것이 스레드 이다.
<br />
해당 JVM에서 스레드를 생성해 사용할 때는 OS의 스레드를 사용하는데 이 OS의 스레드는 다른 코어에 있고, 
<br />
결국 하나의 JVM에서 멀티코어를 사용할 수 있는것이다.
<br />
<br />
<br />
근데 이말은 무슨말인지 자세히 알아보자</p>
<ul>
  <li>프로세스는 독자적인 메모리를 할당받아서 서로 다른 프로세스끼리는 일반적으로 서로의 메모리 영역을 침범하지 못한다?</li>
</ul>

<p><br /></p>

<h2 id="로드밸런싱에-대해서-자세히-알아보자">로드밸런싱에 대해서 자세히 알아보자</h2>

<p><br /></p>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="String" /><category term="Annotation" /><category term="Exception" /><category term="Property" /><category term="JVM" /><category term="GC" /><summary type="html"><![CDATA[]]></summary></entry></feed>