<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-12-15T18:16:58+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">1주차</title><link href="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="1주차" /><published>2022-12-15T00:00:00+09:00</published><updated>2022-12-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="today-i-learned">Today I Learned</h1>

<h2 id="객체와-클래스는-무엇이-다른가-인스턴스는-무엇인가">객체와 클래스는 무엇이 다른가? 인스턴스는 무엇인가</h2>
<ul>
  <li>객체
    <ul>
      <li>물리적, 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.</li>
      <li>소프트웨어 에서 구현할 대상</li>
    </ul>
  </li>
  <li>클래스
    <ul>
      <li>java에서 객체를 생성하기 위한 일종의 설계도</li>
      <li>속성(필드)을 가지고 있고, 행위(메소드)를 가지고있다.</li>
      <li>oop의 관점에서 클래스 타입으로 선언되었을 때 ‘객체’라고 부른다.</li>
    </ul>
  </li>
  <li>인스턴스
    <ul>
      <li>클래스를 가지고 객체를 실체화 한것.</li>
      <li>메모리에 할당되어 실제로 사용되는 객체</li>
    </ul>
  </li>
</ul>

<h2 id="절차형-객체지향-함수형-프로그래밍은-무엇인가">절차형, 객체지향, 함수형 프로그래밍은 무엇인가</h2>

<ul>
  <li>함수형은 데이터를 핸들링 함수형은 어떤 데이터가 들어가도 로직 수행 후 의도한 데이터를 리턴한다. 객체지향은 여기에 상태까지 관리해 줘야 하기 때문에 신경 쓸것이 많다. 어플리케이션은 함수형과 객체지향을 모두 사용한다. 내가 매일 작업하는 로직들은 함수형 이지만, 디비에 접근하는 순간만큼은 함수형일 수가 없다. 데이터를 저장해야 하고 값을 리턴받아야 하고 등의 상태값이 존재하기 때문에.. 이외에도 여러가지가 있겠지만 둘다 사용한다 자바8에 추가된 람다의 함수형 프로그래밍도 이와 같다. 람다로 코드를 짤 경우 데이터의 무결성을 보장한다. 왜냐하면 전통적인 for루프의 경우 객체를 작업하지만 람다의 경우 데이터 그 자체를 핸들링 하기 때문에</li>
</ul>

<h2 id="기본형-타입primitive-type과-참조형-타입reference-type은-무엇이-다른가">기본형 타입(Primitive type)과 참조형 타입(Reference type)은 무엇이 다른가</h2>

<h2 id="wrapper-class는-무엇이며-왜쓰는가">wrapper class는 무엇이며 왜쓰는가?</h2>
<ul>
  <li>기본타입을 객체로 써야할 경우가 있음 - 리스트에 넣던가</li>
</ul>

<h2 id="동일성과-동등성">동일성과 동등성</h2>

<p><br /></p>

<h1 id="next-week-learn">Next Week Learn</h1>

<h2 id="자바의-4가지-접근제어자">자바의 4가지 접근제어자</h2>
<h2 id="상속">상속</h2>
<h2 id="다형성">다형성</h2>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">22.12</title><link href="http://localhost:4000/til/1-TIL/" rel="alternate" type="text/html" title="22.12" /><published>2022-12-04T00:00:00+09:00</published><updated>2022-12-04T00:00:00+09:00</updated><id>http://localhost:4000/til/1-TIL</id><content type="html" xml:base="http://localhost:4000/til/1-TIL/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="lombok">lombok</h1>
<h2 id="getter---prefix">@getter - prefix</h2>
<p>lombok은 boolean 타입일 때 변수의 prefix가 is인 경우 getIsXXX 대신 isXXX 으로 get메서드를 만들어준다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">lombok.Getter</span><span class="o">;</span>

<span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이때 @Getter 로 만들어진 메서드는 getIsMan() 가 아니고 isMan() 가 된다.
<br />
결국 이 DTO 를 받을 경우 아래와 같다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"man"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p><strong><em>해결방법 1. boolean -&gt; Boolean</em></strong>
<br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>원시타입 대신 래퍼타입을 사용한다.
<br />
하지만 래퍼타입이라 null값이 들어가게 되므로 지양하자
<br />
<br />
<strong><em>해결방법 2. get 메서드 직접 작성</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">getIsMan</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="builder">@Builder</h2>
<p>생성자 대신 builder 패턴 적용</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="nd">@Builder</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 사용</span>
    <span class="nc">Person</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">"이름"</span><span class="o">).</span><span class="na">age</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
같은 이름과 같은 매게변수를 가진 메서드가 있으면 @Getter는 메서드를 생성하지 않는다.</p>

<h2 id="noargsconstructor">@NoArgsConstructor</h2>
<p>파라미터 없는 기본생성자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 기본생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="allargsconstructor">@AllArgsConstructor</h2>
<p>모든 필드값을 파라미터로 받는 생성자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 모든 필드를 가진 생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="requireargsconstructor">@RequireArgsConstructor</h2>
<p>final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequireArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span> 
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// final이나 @NonNull인 필드를 가진 생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="data">@Data</h2>
<p>@Getter @Setter @ToString @EqualsAndHashCode @RequiredArgsConstructor 자동생성
<br />
최대한 지양하자</p>
<ul>
  <li>무분별한 getter / setter 남용</li>
  <li>ToString으로 인한 양방향 연관관계시 순환 참조 문제</li>
</ul>

<p><br /></p>

<h1 id="maven--gradle">maven / gradle</h1>
<p>빌드관리도구
<br /></p>
<ul>
  <li>소스코드에서 어플리케이션 생성을 하면서 여러가지 여부 라이브러리를 사용하는데, 빌드 관리 도구는 사용자가 직접 관리할 필요 없이 필요한 라이브러리들을 자동으로 관리한다.</li>
</ul>

<h2 id="maven">maven</h2>
<ul>
  <li>java용 프로젝트 관리 도구로 Apache 의 Ant 대안으로 만들어졌다.</li>
  <li>빌드중인 프로젝트, 빌드순서, 외부라이브러리 종속성 관계를 pom.xml파일에 명시</li>
  <li>멀티프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 <strong><em>상속</em></strong>방식 사용</li>
</ul>

<h2 id="gradle">gradle</h2>
<ul>
  <li>JVM의 스크립트 언어인 groovy로 만들어졌다.</li>
  <li>멀티프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 <strong><em>설정주입</em></strong>방식 사용</li>
</ul>

<h2 id="maven-vs-gradle">maven vs gradle</h2>
<ul>
  <li>gradle 은 빌드시 <strong><em>변경된 파일만 작업</em></strong>하기 때문에 maven 보다 빠름 (10~100배)</li>
  <li>gradle 은 스크립트 언어로 프로젝트가 커질수록 가독성이 maven 보다 좋음</li>
  <li>gradle 이 멀티 프로젝트에 maven보다 적합하다.</li>
</ul>

<p><br /></p>

<h1 id="oom-java-out-of-memory">OOM (java Out Of Memory)</h1>
<h2 id="자바의-메모리">자바의 메모리</h2>
<p>자바는 가비지컬렉터로 메모리 관리를 한다.
<br />
덕분에 개발자는 메모리에 큰 신경을 쓰지 않고 코드를 작성할수 있다
<br />
하지만 가비지컬렉터가 정리해야 할 메모리가 정리되지 못하고 계속 메모리에 남아있게 되는걸 Memory Leak(메모리 누수)
라고 한다. 
<br />
메모리 릭이 계속 될 경우 결국 JVM이 종료되고 만다. 
<br />
메모리 릭의 양이 아주 작고 메모리는 많은 경우에는 주기적으로 JVM을 재시작 하면서 크게 신경안써도 될 경우도 있지만, 메모리릭이 빠르게 증가하는 경우에는 반드시 해결해줘야 한다</p>

<h2 id="왜-발생">왜 발생?</h2>
<p>메모리가 부족하기 때문이다. 한정된 서버 자원에 여러 어플리케이션을 띄운다던가
<br />
static같은 정적 메모리를 남발하여 지워지지 않고 계속 쌓일경우 이다.</p>

<h2 id="어떻게-찾을까">어떻게 찾을까?</h2>
<ol>
  <li>JVM이 oom 에러로 정지된걸 확인</li>
  <li>정지된 JVM 메모리영역을 확인했더니 특정 영역이 Full로 가득차있고, GC후 메모리할당에 실패하는걸 확인</li>
  <li>코드레벨 (대게 싱글톤이나 static 잘못사용)</li>
  <li>쓰레드생성이나 JNI에서 oom이 일어날 경우 OS의 자원소진일 수 있다. 이경우 외부자원을 조심스럽게 쓰던지 외부자원량을 늘림</li>
  <li>외부 라이브러리가 많을 경우 문제해결이 쉽지않다. JVM옵션과 tool의 도움을 받자</li>
  <li>옵션 추가
    <ul>
      <li>JVM 시작시 -verbose:gc옵션을 추가 - 가비지콜렉션 로그를 자세히 볼수있음</li>
      <li>JVM 시작시에 -XX:+HeapDumpOnOutOfMemoryError 추가 - JVM 정지시에 힙덤프를 받아놓을수 있음</li>
      <li>JVM 시작시에  –verbose:class옵션을 추가 - 클래스 로드, 언로드 상황을 볼수 있음</li>
    </ul>
  </li>
  <li>힙덤프 내역을 분석</li>
</ol>

<h2 id="함수형">함수형</h2>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="lombok" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">이펙티브 자바 - 객체 생성과 파괴</title><link href="http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/" rel="alternate" type="text/html" title="이펙티브 자바 - 객체 생성과 파괴" /><published>2022-11-30T00:00:00+09:00</published><updated>2022-11-30T00:00:00+09:00</updated><id>http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94</id><content type="html" xml:base="http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="정적-팩토리-메소드">정적 팩토리 메소드</h1>
<p><br />
<strong><em>생성자 대신 정적 팩토리 메서드를 고려하라</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정적 팩토리 메소드 ex</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">of</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자 이다.
<br />
하지만 클래스는 public 생성자와 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다.
<br /></p>

<h2 id="장점">장점</h2>
<h3 id="1-이름을-가질-수-있다">1. 이름을 가질 수 있다.</h3>

<p>생성자에 넘기는 매개변수와 생성자 만으로는 반환될 객체의 특성을 제대로 파악하기 힘들다.
<br />
그러나 정적 팩터리는 네이밍이 가능함으로 반환될 객체의 특성을 쉽게 파악할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">brand</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">String</span> <span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">brand</span> <span class="o">=</span> <span class="n">brand</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Car</span> <span class="nf">brandFrom</span><span class="o">(</span><span class="nc">String</span> <span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Car</span><span class="o">(</span><span class="n">brand</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-호출될-때마다-인스턴스를-새로-생성하지-않을-수-있다">2. 호출될 때마다 인스턴스를 새로 생성하지 않을 수 있다.</h3>
<p>불변클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 
<br />
불필요한 객체 생성을 피할 수 있다.
<br />
enum과 같이 자주 사용되는 요소의 개수가 정해져있다면 해당 개수만큼 미리 생성해놓고 
<br />
조회(캐싱)할 수 있는 구조로 만들수 있다.
<br />
정적 팩터리 메서드와 캐싱구조를 함께 사용하면 매번 새로운 객체를 생성할 필요가 없어진다.
<br />
즉, 객체 생성 비용이 큰 객체가 자주 생성된다면 성능상 이점을 볼 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumberCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">MIN_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">MAX_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lottoNumberCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LottoNumber</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">LottoNumber</span> <span class="nf">from</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lottoNumberCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-하위-객체를-반환할-수-있다">3. 하위 객체를 반환할 수 있다.</h3>
<p>상속을 사용할 때 확인할 수 있다.
<br />
클라이언트에게 구현체를 노출하지 않고 반환할 수 있고 결국 API의 개념적 무게가 가벼워 진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Grade</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">score</span> <span class="o">&lt;</span> <span class="mi">70</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Fail</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Pass</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Fail</span> <span class="kd">extends</span> <span class="nc">Grade</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Pass</span> <span class="kd">extends</span> <span class="nc">Grade</span> <span class="o">{}</span>
</code></pre></div></div>

<h2 id="단점">단점</h2>
<h3 id="1-상속문제">1. 상속문제</h3>
<p>인스턴스 통제 클래스를 구현하기 위해서는 new 키워드를 사용하여 임의로 객체를 생성함을 막아야한다. 
<br />
이를 위해 생성자의 접근 제어자를 private 로 설정해야하는데, 생성자가 private 인 클래스는 상속을 할 수 없다. 
<br />
즉, 부모 클래스가 될 수 없다.
<br />
이 제약은 컴포지션을 사용하도록 유도하고 불변타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로
받아들여 진다는데, 
<br />
이해가 가지 않는다. 이펙티브 자바를 조금더 공부해 보자</p>

<h3 id="2-정적-팩터리-메서드는-프로그래머가-찾기-어렵다">2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.</h3>

<h2 id="네이밍-컨벤션">네이밍 컨벤션</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">from</code> : 하나의 매개 변수를 받아서 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">of</code> : 여러개의 매개 변수를 받아서 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">getInstance</code> &amp; <code class="language-plaintext highlighter-rouge">instance</code> : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">newInstance</code> &amp; <code class="language-plaintext highlighter-rouge">create</code> : 새로운 인스턴스를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">get[OtherType]</code> : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">new[OtherType]</code> : 다른 타입의 새로운 인스턴스를 생성.</li>
</ul>]]></content><author><name>NNIIE</name></author><category term="Effective_Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">22.11</title><link href="http://localhost:4000/til/TIL/" rel="alternate" type="text/html" title="22.11" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/til/TIL</id><content type="html" xml:base="http://localhost:4000/til/TIL/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="equals--hashcode">equals &amp; hashcode</h1>
<p>Object 클래스의 메소드이다.
<br />
모든 클래스가 Object를 상속받기 때문에
<br />
어떤 객체라도 Object의 메소드인 equals와 hashcode를 사용할 수 있다.
<br /></p>

<h2 id="equals">equals</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Object의 equals()</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>equals()는 오로지 참조값(객체의 주소값)이 같은지 즉, 동일 객체인지 확인하는 기능이다.
<br />
equals 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 반환한다.
<br />
논리적으로 동등하다는 것은 둘의 참조값이 다르더라도 객체 내부의 value는 같다는걸 의미한다.
<br /></p>
<ul>
  <li><strong><em>동일성</em></strong> : ==비교. 객체 인스턴스 주소 값을 비교</li>
  <li><strong><em>동등성</em></strong> : equals() 메소드를 사용해 객체 내부의 값을 비교한다.</li>
</ul>

<h2 id="hashcode">hashcode</h2>
<p>객체 해시코드란 객체를 식별하는 하나의 정수값을 말한다. 
<br />
Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다.
<br /><br />
<strong><em>hashcode 를 재정의 하지 않으면</em></strong></p>
<ul>
  <li>같은 값을 가진 객체가 서로 다른 해시값을 갖게 될 수 있다.</li>
  <li>특히 HashMap의 key 값으로 해당 객체를 사용할 경우 문제가 발생한다.</li>
</ul>

<h3 id="hashtable">HashTable</h3>
<p>HashTable은 &lt;key,value&gt; 형태로 데이터를 저장한다. 이 때 해시 함수(Hash Function)을 이용하여 key값을 기준으로 고유한 식별값인 해시값을 만든다. (hashcode가 해시값을 만드는 역할을 한다.) 
<br />
이 해시값을 버킷(Bucket)에 저장한다.
<br />
하지만 HashTable 크기는 한정적이기 때문에 같은 서로 다른 객체라 하더라도 같은 해시값을 갖게 될 수도 있다.
<br />
이것을 <strong>해시 충돌(Hash Collisions)</strong>이라고 한다.
<br />
이런 경우 아래와 같이 해당 버킷(Bucket)에 LinkedList 형태로 객체를 추가한다.
<br /><br />
이처럼 같은 해시값의 버킷 안에 다른 객체가 있는 경우 equals 메서드가 사용된다.
<br /><br />
HashTable에 put 메서드로 객체를 추가하는 경우
<br /></p>
<ul>
  <li>값이 같은 객체가 이미 있다면(equals()가 true) 기존 객체를 덮어쓴다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) 해당 entry를 LinkedList에 추가한다.
<br /><br /></li>
</ul>

<p>HashTable에 get 메서드로 객체를 조회하는 경우</p>

<ul>
  <li>값이 같은 객체가 있다면 (equals()가 true) 그 객체를 리턴한다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) null을 리턴한다.</li>
</ul>

<h2 id="equals-와-hashcode를-같이-재정의-하는-이유">equals() 와 hashcode()를 같이 재정의 하는 이유</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">LottoNumber</span> <span class="n">that</span> <span class="o">=</span> <span class="o">(</span><span class="nc">LottoNumber</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">(),</span> <span class="n">that</span><span class="o">.</span><span class="na">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>만약 equals()와 hashcode() 중 하나만 재정의 하면 어떻게 될까?
<br /> 
위 예에서도 봤듯이 hashcode()를 재정의 하지 않으면 같은 값 객체라도 해시값이 다를 수 있다. 따라서 HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없다.
<br />
반대로 equals()를 재정의하지 않으면 hashcode()가 만든 해시값을 이용해 객체가 저장된 버킷을 찾을 수는 있지만 해당 객체가 자신과 같은 객체인지 값을 비교할 수 없기 때문에 null을 리턴하게 된다. 
<br />
따라서 역시 원하는 객체를 찾을 수 없다.
<br />
이러한 이유로 객체의 정확한 동등 비교를 위해서는 (특히 Hash 관련 컬렉션 프레임워크를 사용할때!) Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.</p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry></feed>