<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-30T23:14:43+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">22.11.4</title><link href="http://localhost:4000/til/" rel="alternate" type="text/html" title="22.11.4" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/</id><content type="html" xml:base="http://localhost:4000/til/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="equals--hashcode">equals &amp; hashcode</h1>
<p>Object 클래스의 메소드이다.
<br />
모든 클래스가 Object를 상속받기 때문에
<br />
어떤 객체라도 Object의 메소드인 equals와 hashcode를 사용할 수 있다.
<br /></p>

<h2 id="equals">equals</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Object의 equals()</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>equals()는 오로지 참조값(객체의 주소값)이 같은지 즉, 동일 객체인지 확인하는 기능이다.
<br />
equals 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 반환한다.
<br />
논리적으로 동등하다는 것은 둘의 참조값이 다르더라도 객체 내부의 value는 같다는걸 의미한다.
<br /></p>
<ul>
  <li><strong><em>동일성</em></strong> : ==비교. 객체 인스턴스 주소 값을 비교</li>
  <li><strong><em>동등성</em></strong> : equals() 메소드를 사용해 객체 내부의 값을 비교한다.</li>
</ul>

<h2 id="hashcode">hashcode</h2>
<p>객체 해시코드란 객체를 식별하는 하나의 정수값을 말한다. 
<br />
Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다.
<br /><br />
<strong><em>hashcode 를 재정의 하지 않으면</em></strong></p>
<ul>
  <li>같은 값을 가진 객체가 서로 다른 해시값을 갖게 될 수 있다.</li>
  <li>특히 HashMap의 key 값으로 해당 객체를 사용할 경우 문제가 발생한다.</li>
</ul>

<h3 id="hashtable">HashTable</h3>
<p>HashTable은 &lt;key,value&gt; 형태로 데이터를 저장한다. 이 때 해시 함수(Hash Function)을 이용하여 key값을 기준으로 고유한 식별값인 해시값을 만든다. (hashcode가 해시값을 만드는 역할을 한다.) 
<br />
이 해시값을 버킷(Bucket)에 저장한다.
<br />
하지만 HashTable 크기는 한정적이기 때문에 같은 서로 다른 객체라 하더라도 같은 해시값을 갖게 될 수도 있다.
<br />
이것을 <strong>해시 충돌(Hash Collisions)</strong>이라고 한다.
<br />
이런 경우 아래와 같이 해당 버킷(Bucket)에 LinkedList 형태로 객체를 추가한다.
<br /><br />
이처럼 같은 해시값의 버킷 안에 다른 객체가 있는 경우 equals 메서드가 사용된다.
<br /><br />
HashTable에 put 메서드로 객체를 추가하는 경우
<br /></p>
<ul>
  <li>값이 같은 객체가 이미 있다면(equals()가 true) 기존 객체를 덮어쓴다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) 해당 entry를 LinkedList에 추가한다.
<br /><br /></li>
</ul>

<p>HashTable에 get 메서드로 객체를 조회하는 경우</p>

<ul>
  <li>값이 같은 객체가 있다면 (equals()가 true) 그 객체를 리턴한다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) null을 리턴한다.</li>
</ul>

<h2 id="equals-와-hashcode를-같이-재정의-하는-이유">equals() 와 hashcode()를 같이 재정의 하는 이유</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">LottoNumber</span> <span class="n">that</span> <span class="o">=</span> <span class="o">(</span><span class="nc">LottoNumber</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">(),</span> <span class="n">that</span><span class="o">.</span><span class="na">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>만약 equals()와 hashcode() 중 하나만 재정의 하면 어떻게 될까?
<br /> 
위 예에서도 봤듯이 hashcode()를 재정의 하지 않으면 같은 값 객체라도 해시값이 다를 수 있다. 따라서 HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없다.
<br />
반대로 equals()를 재정의하지 않으면 hashcode()가 만든 해시값을 이용해 객체가 저장된 버킷을 찾을 수는 있지만 해당 객체가 자신과 같은 객체인지 값을 비교할 수 없기 때문에 null을 리턴하게 된다. 
<br />
따라서 역시 원하는 객체를 찾을 수 없다.
<br />
이러한 이유로 객체의 정확한 동등 비교를 위해서는 (특히 Hash 관련 컬렉션 프레임워크를 사용할때!) Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.</p>

<h1 id="정적-팩토리-메소드">정적 팩토리 메소드</h1>
<p><strong><em>생성자 대신 정적 팩토리 메서드를 고려하라</em></strong></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="java" /><category term="디자인패턴" /><summary type="html"><![CDATA[]]></summary></entry></feed>