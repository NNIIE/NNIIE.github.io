<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-31T02:27:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">7 Week</title><link href="http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="7 Week" /><published>2023-01-26T00:00:00+09:00</published><updated>2023-01-26T00:00:00+09:00</updated><id>http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/7%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="jdbc">JDBC</h1>
<h2 id="jdbc의-정의">JDBC의 정의</h2>
<p>데이터베이스 접근기술</p>

<p><br /></p>

<h2 id="jdbc-driver">JDBC Driver</h2>
<p>서로 다른 디비들에 대한 연결방법이 모두 다르기 때문에 거기에 대응하기 위해서 사용한다.
<br />
결국 디비가 서로 다르고 다른 연결방식 이어도 모두 같은방식으로 다루고 싶고
<br />
또한 프로그래밍 단에서는 하나의 방식으로 사용하고 싶기 때문에 사용한다.</p>

<p><br /></p>

<h2 id="jdbc-api">JDBC API</h2>
<p>드라이버가 매꿔준 걸 이용해서 같은방식으로 디비에 대한 접근을 제공하는 <strong>인터페이스</strong>
<br />
API는 <code class="language-plaintext highlighter-rouge">Application Programming Interface</code>의 약자이고
<br />
<code class="language-plaintext highlighter-rouge">JDBC API</code>란 여기에 접근하기 위해 추상적으로 공개한 루트이다.
<br />
이것도 결국 프로그래밍 단에서 다른걸 신경쓰지 않고 하나의 방법으로 사용하고 싶기 때문</p>

<p><br /></p>

<h2 id="connection-pool">Connection Pool</h2>
<p>데이터베이스에 대한 커넥션을 미리 생성해두고 재사용 하기 위한 방법
<br />
어플리케이션 시작 시점에 필요한 만큼의 커넥션을 미리 확보해서 풀에 보관한다.
<br />
<br />
<br />
<strong>왜쓰는데?</strong>
<br /></p>

<p>DB Driver는 데이터베이스와 <strong>TCP/IP</strong> 커넥션을 연결하는데, 이 과정에서 <code class="language-plaintext highlighter-rouge">3 way handshake</code> 같은
<br /> 
네트워크 동작이 발생하게 된다.
<br />
<code class="language-plaintext highlighter-rouge">3 way handshake</code> 는 <strong>Network Pass</strong> 를 확보하는데 3번의 통신을 해야 서로가 신뢰를
<br />
가지고 <strong>Pass</strong> 를 확정하기 때문에 이 과정에서 시간이라는 리소스가 많이 들어가게 된다.
<br />
비용적인 측면에서 <strong>느린거로</strong>는 네트워크가 압도적이기 때문에 <code class="language-plaintext highlighter-rouge">Connection Pool</code> 을 사용한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvc">MVC</h1>
<p>어플리케이션을 <strong>Model-View-Controller</strong> 의 세가지 컴포넌트로
<br />
각각 담당하는 역할을 구분한 디자인패턴</p>
<ol>
  <li>사용자가 입력을 담당하는 <strong>View</strong> 를 통해 요청을 보낸다.</li>
  <li>해당 요청을 <strong>Controller</strong> 가 받고 <strong>Model</strong> 을 통해 데이터를 가져온다.</li>
  <li>해당 데이터를 바탕으로 출력을 담당하는 <strong>View</strong> 를 통해 사용자에게 전달한다.
<br />
MVC패턴은 모델1과 모델2가 있다.</li>
</ol>

<ul>
  <li>모델 1
    <ul>
      <li>JSP에서 출력과 로직을 전부 담당</li>
      <li>사용자 요청을 JSP가 <code class="language-plaintext highlighter-rouge">JavaBean Service Class</code> 를 사용해 전부 처리</li>
      <li>빠르고 쉽게 개발할 수 있지만 유지보수맟 확장에 어려움</li>
    </ul>
  </li>
  <li>모델 2
    <ul>
      <li>JSP에서 출력만 담당</li>
      <li>사용자 요청을 서블릿이 받음</li>
      <li>설계가 어렵지만 분업이 가능하며 유지보수 및 확장에 용이</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Model</strong></p>
<ul>
  <li>어플리케이션의 정보, 데이터 등을 담당하고 정보들의 가공을 책임지는 컴포넌트</li>
  <li>비즈니스 로직 처리</li>
  <li>편집하기 원하는 모든 데이터를 가지고 있어야 한다.</li>
  <li>변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.</li>
  <li><strong>View / Controller</strong> 에 대해 의존하지 말아야 한다.</li>
</ul>

<p><br /></p>

<p><strong>View</strong></p>
<ul>
  <li>데이터의 입력과 보여지는 출력을 담당</li>
  <li><strong>Model</strong> 의 정보를 가지고 있지 말아야 한다.</li>
  <li>변경이 일어나면, 변경통지에 대해 처리방법을 구현해야 한다.</li>
  <li><strong>Model / Controller</strong> 에 의존하지 말아야 한다.</li>
</ul>

<p><br /></p>

<p><strong>Controller</strong></p>
<ul>
  <li><strong>Model / View</strong> 의 중간다리 역할을 한다.</li>
  <li>요청에 대해 해당 요청을 담당하는 <strong>Model</strong> 을 호출한다.</li>
  <li><strong>Model</strong> 의 작업결과를 리턴받아 <strong>View</strong> 에게 전달한다.
    <ul>
      <li><strong>Model / View</strong> 에 대해 알고있어야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Web에 적용할 시</strong></p>
<ol>
  <li>유저가 웹사이트에 접속</li>
  <li><strong>Controller</strong> 는 접속요청에 대해 <strong>Model</strong> 호출</li>
  <li><strong>Model</strong> 은 디비나 파일같은 데이터를 비즈니스 로직을 통해 처리 후 리턴</li>
  <li><strong>Controller</strong> 는 리턴받은 결과를 <strong>View</strong> 에 전달</li>
  <li>리턴받은 결과는 <strong>View</strong> 를 통해 유저에게 보여짐</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
사용자 <strong>UI / 비즈니스 로직 / 중간다리</strong> 이렇게 3가지로 구분하여 어플리케이션을
<br />
설계하면 각각 자신의 역할에만 집중할 수 있다.
<br />
이로인해 유지보수, 확장성, 유연성이 증가하고 중복을 줄일 수 있다.</p>

<p><br /></p>

<p><strong>단점</strong>
<br />
<br />
설계에 리소스가 들어간다. 예를들어</p>
<ul>
  <li><strong>Model / View</strong> 가 다른 컴포넌트 들에게 독립적이게 설계하는 것</li>
  <li><strong>Model</strong> 의 설계를 잘해야 변경에 유연할 수 있는것
<br /></li>
</ul>

<p>제대로 설계를 하지 않으면 <strong>View</strong> 와 <strong>Model</strong> 의 분리가 어려운데
<br />
<strong>Controller</strong> 를 통해 하나의 View에 연결될 수 있는 <strong>Model</strong> 도 여러 개가 될 수 있어
<br />
<strong>View</strong> 와 <strong>Model</strong> 이 서로 의존성을 띄게 될 수 있다.
<br />
즉, <strong>Controller</strong> 하나에 다수의 <strong>Model / View</strong> 가 복잡하게 얽히는 상황이 일어날 수 있다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvp">MVP</h1>
<p><strong>Model-View</strong> 는 <strong>MVC</strong> 패턴과 동일하고 <strong>Controller</strong> 대신 <strong>Presenter</strong> 가 존재하는 패턴</p>
<ul>
  <li><strong>Presenter</strong>
    <ul>
      <li><strong>View</strong> 와 <strong>Model</strong> 의 <strong>인스턴스</strong> 를 가지고 있다.</li>
      <li><strong>Presenter</strong> 와 <strong>View</strong> 는 1:1 관계이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>동작</strong></p>
<ol>
  <li>사용자 요청은 <strong>View</strong> 를 통해 들어옴</li>
  <li><strong>View</strong> 는 데이터를 <strong>Presenter</strong> 에 요청</li>
  <li><strong>Presenter</strong> 는 <strong>Model</strong> 에게 데이터 요청</li>
  <li><strong>Model</strong> 은 <strong>Presenter</strong> 에게 요청받은 데이터 응답</li>
  <li><strong>Presenter</strong> 는 <strong>View</strong> 에게 데이터를 응답</li>
  <li><strong>View</strong> 는 <strong>Presenter</strong> 가 응답한 데이터를 사용해 화면을 나타냄</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<strong>Presenter</strong> 를 통해서만 데이터를 전달 받기 때문에 <strong>View-Model</strong> 간의 의존성이 없다.
<br />
하지만 <strong>View-Model</strong> 간의 의존성은 해결되었지만 반대로 <strong>View-Presenter</strong> 간의
<br />
의존성이 높아지고 어플리케이션이 복잡해 질 수록 의존성을 더 강해진다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="mvvm">MVVM</h1>
<p>Command 패턴과 Data Binding 이라는 두 가지 패턴을 사용하여 구현되었다.
<br />
Command 패턴과 Data Binding을 이용하여 <strong>View</strong> 와 <strong>View Model</strong> 사이의 의존성을 없앰
<br />
<strong>View Model</strong> 과 <strong>View</strong> 는 <strong>1:N</strong> 관계이다.
<br />
<strong>Model-View</strong> 는 <strong>MVC</strong> 패턴과 동일하고 <strong>Controller</strong> 대신 <strong>View Model</strong> 이 존재한다.</p>
<ul>
  <li><strong>View Model</strong>
    <ul>
      <li><strong>View</strong> 를 표현하기 위해 만든 <strong>View</strong> 를 위한 <strong>Model</strong> 이다.</li>
      <li><strong>View</strong> 에서 필요로 하는 데이터 처리와 비즈니스 로직을 수행한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>동작</strong></p>
<ol>
  <li>사용자 요청은 <strong>View</strong> 를 통해 들어옴</li>
  <li><strong>View</strong> 는 Command 패턴으로 <strong>View Model</strong> 에게 요청 전달</li>
  <li><strong>View Model</strong> 은 <strong>Model</strong> 에게 데이터 요청</li>
  <li><strong>Model</strong> 은 <strong>View Model</strong> 에게 요청받은 데이터 응답</li>
  <li><strong>View Model</strong> 은 응답받은 데이터를 가공하여 저장</li>
  <li><strong>View</strong> 는 <strong>View Model</strong> 과 <strong>Data Binding</strong> 하여 화면을 나타냄</li>
</ol>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<strong>View-Model</strong> 간의 의존성이 없다. 또한 Command 패턴과 Data Binding을 사용하여 
<br />
<strong>View-View Model</strong> 간의 의존성 또한 없앤 디자인패턴 
<br />
각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있는 장점이 있지만
<br />
<strong>View Model</strong> 의 설계가 쉽지 않다는 단점이 있다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="MVC" /><category term="MVP" /><category term="MVVM" /><category term="JDBC" /><category term="Connection Pool" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">6 Week</title><link href="http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="6 Week" /><published>2023-01-19T00:00:00+09:00</published><updated>2023-01-19T00:00:00+09:00</updated><id>http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/6%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="web">Web</h1>
<p>아래 내용들을 무엇이다 라고 정의해보려고 했는데 명쾌하게 떠오르지 않았다.
<br />
이참에 한번 짚고 넘어가자.
<br />
<br />
<br />
<strong>World Wide Web</strong>
<br />
<br />
인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간</p>

<ul>
  <li>텍스트, 그림, 소리, 영상 등의 멀티미디어 정보를 하이퍼텍스트 방식으로 연결
    <ul>
      <li>하이퍼텍스트 : 문서 내부에 또다른 문서가 연결되는 참조를 넣음</li>
    </ul>
  </li>
</ul>

<p>웹페이지들은 각각 연결되어 있는데 이로 인해 거미줄처럼 얽혀있는 정보의 모음이라고도 불림</p>

<p><br /></p>

<p><strong>웹페이지</strong>
<br />
<br />
정보제공을 목적으로한 <code class="language-plaintext highlighter-rouge">정적</code>인 사이트
<br />
수동적으로 정보를 관람함</p>

<p><br /></p>

<p><strong>웹어플리케이션</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">동적</code>기능을 가진 웹으로 상호작용을 통해 유저가 
<br />
능동적으로 어플리케이션 상의 서비스를 이용하는것을 목적으로 함</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="browser-rendering">Browser Rendering</h1>

<p><br /></p>

<h2 id="ssr">SSR</h2>
<p><strong>서버사이드 렌더링 - Server Side Rendering</strong>
<br />
서버로부터 완전하게 만들어진 <code class="language-plaintext highlighter-rouge">HTML</code>  파일을 받아오는 방식
<br />
렌더링이 서버에서 일어난다.
<br /></p>
<ul>
  <li><strong>동작</strong>
    <ol>
      <li>클라이언트가 요청을 보냄</li>
      <li>서버는 <code class="language-plaintext highlighter-rouge">HTML</code> 에 데이터, <code class="language-plaintext highlighter-rouge">CSS</code>, <code class="language-plaintext highlighter-rouge">JS</code> 를 렌더링하여 컴파일 후 보낸다.</li>
      <li>클라이언트는 즉시 <code class="language-plaintext highlighter-rouge">HTML</code> 을 먼저 렌더링 하고 그 후 <code class="language-plaintext highlighter-rouge">JS</code> 코드를 받아 실행한다.
<br />
<br /></li>
    </ol>
  </li>
  <li><strong>장점</strong>
    <ul>
      <li>빠른 초기 로딩</li>
      <li><code class="language-plaintext highlighter-rouge">HTML</code> 안에 모든 데이터가 포함되어 있어 검색엔진에 노출이 잘됨 (크롤링)
<br />
<br /></li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>요청시마다 새로고침 (깜빡임)</li>
      <li>서버부하 (작은 변경이라도 서버에서 모든걸 다시 받아옴)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="csr">CSR</h2>
<p><strong>클라이언트 사이드 렌더링 - Client Side Rendering</strong>
<br />
사용자에 요청에 따라 필요한 부분만 응답받아 렌더링 하는 방식
<br />
렌더링이 클라이언트 쪽에서 일어난다.
<br /></p>
<ul>
  <li><strong>동작</strong>
    <ol>
      <li>클라이언트에서 초기화면을 로드하기 위해 서버에 요청을 보냄</li>
      <li>서버는 화면에 표시하는데 필요한 완전한 리소스 응답
<br />
<br /></li>
    </ol>
  </li>
  <li><strong>장점</strong>
    <ul>
      <li>빠른속도 (초기화면 렌더링X)</li>
      <li>서버부하 감소 (클라이언트에서 변경부분만 요청)</li>
      <li>유저경험 증가 (깜빡임)
<br />
<br /></li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>초기화면 로딩 느림 (<code class="language-plaintext highlighter-rouge">JS</code>포함 모든 파일을 받아야 함)</li>
      <li>검색엔진에 노출이 잘 안됨 (<code class="language-plaintext highlighter-rouge">HTML</code> 자체는 깡통이므로)</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="http의-전송방식">HTTP의 전송방식</h1>
<p><code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">POST</code> 등의 전송방식이 있지만 모두 텍스트 형식이다.
<br />
HTTP 전송방식에 왜 텍스트를 사용했을까?</p>
<ul>
  <li>다양한 환경에 맞는 (범용적, 유연함) 규약이 필요했다.</li>
  <li>왜나햐면 <code class="language-plaintext highlighter-rouge">Web</code>은 말그대로 전세계 모든 사람이 이용하는, 엄창나게 많은 곳에서 쓰인다.</li>
  <li>일단 텍스트는 눈으로 보고 어느정도 의미를 유추할 수 있고</li>
  <li>클라이언트에 상황에 구애받지 않는 텍스트가 가장 보편적이었다.</li>
  <li>따라서 바이트코드나 비트같이 가볍지만 제약이 따르는 것들 대신 보편적인 텍스트를 쓰는것이다.</li>
</ul>

<p><br /></p>

<p><strong>그렇다면 HTTPS는?</strong>
<br />
<br />
하이퍼 텍스트 전송 프로토콜 즉, <code class="language-plaintext highlighter-rouge">HTTP</code>는 <code class="language-plaintext highlighter-rouge">HTML</code>을 전송하기 위한 통신 규약이다.
<br />
하지만 암호화 되지 않은 방법으로 데이터를 전송하기 때문에 보안에 취약하다.
<br />
그래서 이를 보완한 것이 <code class="language-plaintext highlighter-rouge">SSL</code> 또는 <code class="language-plaintext highlighter-rouge">TLS</code> 사용해 암호화된 <code class="language-plaintext highlighter-rouge">HTTPS</code> 이다.
<br />
<code class="language-plaintext highlighter-rouge">SSL, TLS</code> 는 응용계층<code class="language-plaintext highlighter-rouge">(HTTP)</code> 과 전송계층<code class="language-plaintext highlighter-rouge">(TCP)</code> 사이에 위치해 있다.</p>

<ul>
  <li><strong>SSL</strong> : 서버와 브라우저 사이에 전송되는 데이터를 암호화 함</li>
  <li><strong>TSL</strong> : <code class="language-plaintext highlighter-rouge">SSL</code>의 향상된 버전, 통신하는 대상간의 데이터의 무결성을 제공하는걸 목표로 함
<br />
<br /></li>
</ul>

<p><strong>인증서 동작</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">SSL/TSL</code> 세션은 핸드셰이크라는 과정을 통해 클라이언트-서버 간에 암호화 된 연결을 수립한다.</p>
<ul>
  <li><strong>인증</strong>
    <ul>
      <li>클라이언트가 시작하는 모든 신규 세션에 대해 서버는 각각 다른 <code class="language-plaintext highlighter-rouge">SSL</code> 인증서를 교환하고 검증한다.</li>
    </ul>
  </li>
  <li><strong>암호화</strong>
    <ul>
      <li>서버는 클라이언트와 공개 키를 공유하고 클라이언트는 이 키를 사용해 프리마스터 키를 생성해 암호화한다. 이를 키교환이라고 한다.</li>
    </ul>
  </li>
  <li><strong>복호화</strong>
    <ul>
      <li>서버는 개인 키를 사용해 프리마스터 키를 복호화 하고, 세션기간동안 사용되는 암호화된 보안연결을 수립한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="base64">Base64</h1>
<p><strong>Binary Data 를 Text로 바꾸는 인코딩</strong> 의 하나로써 <code class="language-plaintext highlighter-rouge">Binary Data</code> 를 Character set에 영향을 받지 않는 공통 <code class="language-plaintext highlighter-rouge">ASCII</code> 영역의 문자로만 이루어진 문자열로 바꾸는 인코딩이다.
<br />
<code class="language-plaintext highlighter-rouge">Base64</code>는 직역하면 64진법인데, 64진법은 2의 제곱수에 기반한 진법 중 화면에 표시되는 <code class="language-plaintext highlighter-rouge">ASCII</code> 문자들로 표시할 수 있는 가장큰 진법이다.</p>
<ul>
  <li><strong>인코딩</strong> : 정보의 형태나 형식을 표준화, 보안, 처리속도향상 등을위해 다른 형태나 형식으로 변환하는 처리</li>
</ul>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">Base64</code>로 인코딩하면 데이터양이 약 33% 늘어나고 다시 디코딩하는 추가연산도 필요하다. 근데 왜쓸까?
<br />
HTTP로 <code class="language-plaintext highlighter-rouge">Binary Data</code>(이미지, 오디오 등)를 전송하면 문제가 발생하는데, 대표적으로</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ASCII</code>는 <code class="language-plaintext highlighter-rouge">7bits</code> 인코딩 인데 나머지 <code class="language-plaintext highlighter-rouge">1bit</code> 를 처리하는 방식이 시스템 별로 상이하다.</li>
  <li>일부 제어문자 (e.g. Line ending)의 경우 시스템 별로 다른 코드값을 갖는다.
<br /></li>
</ul>

<p>즉,<code class="language-plaintext highlighter-rouge">Binary Data</code>의 손실이 일어나기 때문에, <strong>ASCII는 시스템간 데이터를 전달하기에 안전하지가 않다.</strong> 
<br />
그래서 <code class="language-plaintext highlighter-rouge">ASCII</code> 중 제어문자와 일부 특수문자를 제외한 64개의 안전한 출력 문자만 사용하는 <code class="language-plaintext highlighter-rouge">Base64</code>를 사용한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="bulk-처리">Bulk 처리</h1>
<p>대량의 데이터를 한번의 트랜잭션으로 삽입하는 방법이다.
<br />
<br />
insert 로 예를들면
<br />
<code class="language-plaintext highlighter-rouge">MyBatis</code> 기준 insert 구문 수행 시 values 리스트를 다중으로 사용한다.
<br /></p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">insert</span> <span class="k">into</span> <span class="n">A</span> <span class="k">values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">)</span> <span class="p">...</span>


<span class="k">insert</span> <span class="k">into</span> <span class="n">A</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">c</span><span class="p">)</span> <span class="k">values</span>
<span class="o">&lt;</span><span class="n">foreach</span> <span class="n">collection</span><span class="o">=</span><span class="nv">"list"</span> <span class="n">item</span><span class="o">=</span><span class="nv">"item"</span> <span class="n">separator</span><span class="o">=</span><span class="nv">","</span><span class="o">&gt;</span>
	<span class="o">#</span><span class="p">{</span><span class="n">item</span><span class="p">}</span>
<span class="o">&lt;/</span><span class="n">foreach</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>왜쓰는데?</strong>
<br />
<br />
DB와의 트랜잭션은 커넥션을 열고 닫는 등의 생각보다 복잡하고 리소스가 큰데 10000건의 데이터를 
<br />
저장하는 경우를 생각해 보면 데이터를 저장하는데 10000번의 트랜잭션이 일어나게 된다.
<br />
<br />
하지만 <code class="language-plaintext highlighter-rouge">bulk insert</code> 의 경우 단 한번의 트랜잭션으로 처리를 할 수 있기 때문에
<br />
데이터 수가 많을수록 비약적으로 성능이 향상된다.
<br />
<br />
실제로도 예전에 거의 안쓰이는 스케쥴러 처리한 <code class="language-plaintext highlighter-rouge">insert</code> 용도의 <code class="language-plaintext highlighter-rouge">API</code> 가 있는데 어느순간
<br />
급격히 사용량이 많아져서 데이터 처리에 딜레이가 발생하는 상황이 생긴적이 있는데
<br />
이때 <code class="language-plaintext highlighter-rouge">bulk</code> 처리 하나로 비약적인 성능향상과 이슈를 해결한 적이 있었다.</p>

<p><br /></p>

<p><strong>단점</strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">bulk insert</code> 로 10000건의 데이터를 insert 하던 중 마지막 <code class="language-plaintext highlighter-rouge">low</code> 에서 에러가 발생한다면?
<br />
이럴경우 모두 롤백된다.
<br />
<br />
10000번의 트랜잭션을 1번의 트랜잭션으로 해결해서 비약적인 성능향상을 가져올 수 있지만 하나라도 
<br />
실패하는 순간 트랜잭션은 롤백되고 그 트랜잭션 안에 10000건이 있기 때문에 이렇게 되면 매우 비효율적이다.
<br />
그래서 너무 대량의 데이터를 <code class="language-plaintext highlighter-rouge">bulk</code> 처리 하는건 좋지않고,
<br />
실패할 경우를 대비해 <code class="language-plaintext highlighter-rouge">retry</code> 하는 코드도 별도로 짜주는게 좋다.
<br />
제일 좋은건 정합성이 뛰어난 데이터여서 실패할 가능성이 거의 없을때 사용하는게 좋겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="세션이-왜필요할까">세션이 왜필요할까?</h1>
<p><code class="language-plaintext highlighter-rouge">HTTP</code>프로토콜은 비연결 지향이기 때문에 세션과 쿠키를 사용하는데
<br />
세션은 서버에서 관리하고 프론트에선 그 키를 받아서 내가 누구인지 알려준다.
<br />
이런식으로 인증에 대한 세션과 쿠키의 협업이 일어난다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="apache-tomcat">Apache Tomcat</h1>
<p>가장 범용적인 <code class="language-plaintext highlighter-rouge">WAS</code> 중 하나이며, Apache 재단 에서 개발한 <code class="language-plaintext highlighter-rouge">HTTP Web Application Server</code>이다.
<br />
오픈소스이기 때문에 무료이고 구축이 쉽다는 이유로 전세계에서 매우 많이 사용되고 있다.
<br />
기본적으로 <code class="language-plaintext highlighter-rouge">Apache</code> 와 <code class="language-plaintext highlighter-rouge">Tomcat</code> 의 기능은 나뉘어져 있지만, <code class="language-plaintext highlighter-rouge">Tomcat</code> 안에 컨테이너를 통해 
<br />
일부 <code class="language-plaintext highlighter-rouge">Apache</code> 기능을 발휘하기 때문에 보통 <code class="language-plaintext highlighter-rouge">Apache Tomcat</code> 으로 부른다.</p>
<ul>
  <li><strong>Apache</strong>
    <ul>
      <li>웹서버이며, 80포트로 클라이언트 요청(GET, POST 등)이 왔을때만 응답한다.</li>
      <li>정적인 데이터만 처리한다 (HTML, CSS, 이미지 등)
        <ul>
          <li><strong>웹서버</strong> : <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜 요청을 처리하는 서버</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Tomcat</strong>
    <ul>
      <li>동적인 웹을 만들기 위한 <code class="language-plaintext highlighter-rouge">Web Container</code>, <code class="language-plaintext highlighter-rouge">Servlet Container</code> 로도 불림</li>
      <li><code class="language-plaintext highlighter-rouge">Servlet</code> 을 실행키고 <code class="language-plaintext highlighter-rouge">JSP</code> 코드가 포함되어 있는 웹 페이지를 만들어준다.</li>
      <li>DB, 로직처리 등을 요구하는 동적타입을 제공하는 소프트웨어</li>
      <li>프로그램 실행환경과 DB 접속 기능 등을 제공한다.</li>
      <li>여러개의 트랜잭션을 관리한다.</li>
      <li>비즈니스 로직을 수행한다.</li>
    </ul>
  </li>
  <li><strong>Sevrlet</strong>
    <ul>
      <li>동적인 처리를 하는 역할을 담당하는 자바 기반 기술</li>
      <li><code class="language-plaintext highlighter-rouge">WAS</code>에서 동작하는 Java 클래스이며, <code class="language-plaintext highlighter-rouge">HttpServlet</code> 을 상속받는다.</li>
      <li><code class="language-plaintext highlighter-rouge">Request / Response</code> 흐름을 간단한 메서드 호출로 다룰 수 있게 해준다.</li>
    </ul>
  </li>
  <li><strong>Sevrlet Container</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Sevrlet</code> 을 담고 관리하는 컨테이너</li>
      <li>새로운 요청이 들어올 때 마다 스레드를 생성</li>
      <li>작업이 끝난 서블릿 스레드를 제거</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>정리하면</strong>
<br />
<br />
<strong>Apache Tomcat != Apache</strong></p>
<ul>
  <li><strong>Apache 만 사용하면?</strong>
    <ul>
      <li>구조가 단순하여 트래픽 과부하에 장점이 있다.</li>
      <li>정적인 웹페이지만 처리가 가능하다.</li>
    </ul>
  </li>
  <li><strong>Tomcat 만 사용하면?</strong>
    <ul>
      <li>동적인 웹페이지 처리가 가능하지만 <code class="language-plaintext highlighter-rouge">Apache</code> 에서 필요한 기능을 가져오지 못한다.</li>
      <li><code class="language-plaintext highlighter-rouge">Apache</code> 에 비해 속도가 느려 트래픽 과부하에 단점이 있다.</li>
    </ul>
  </li>
  <li><strong>둘을 같이쓰면?</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Apache</code> 는 정적인 데이터만 처리하고, JSP 처리는 Web Container(Tomcat의 일부)로 보낸다. 
  <br />
  결국 분산처리가 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servlet-filter">Servlet Filter</h1>
<p>J2EE 표준 스펙을 구현한 기술이다. <code class="language-plaintext highlighter-rouge">Tomcat</code>과 같은 <code class="language-plaintext highlighter-rouge">Web Container</code>에 의해 관리된다.
<br />
<code class="language-plaintext highlighter-rouge">Servlet</code>으로 전달되는 클라이언트의 <code class="language-plaintext highlighter-rouge">request</code> 혹은 <code class="language-plaintext highlighter-rouge">Servlet</code>에서 클라이언트로 전달되는 <code class="language-plaintext highlighter-rouge">response</code>를
<br />
중간에 가로채서 <code class="language-plaintext highlighter-rouge">request / response</code> 객체 자체를 조작할 수 있다.
<br />
<br />
사용자인증, 로깅, 인코딩 같은 기능들은 모든 <code class="language-plaintext highlighter-rouge">Servlet</code>이나 JSP가 공통적으로 필요로 하기 때문에 공통적인
<br />
기능들을 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 호출되기 전에 전처리 혹은 후처리 하고 싶을 때 <code class="language-plaintext highlighter-rouge">Servlet Filter</code>로 구현한다.
<br />
클라이언트 요청을 <code class="language-plaintext highlighter-rouge">Servlet</code> 이 받기전에 먼저 가로채서 서버컴포넌트의 공통적인 기능을 수행시킬 수 있다.
<br />
<br />
예를들어 모든 페이지에서 로그인 유무를 확인해야 할 경우 각 <code class="language-plaintext highlighter-rouge">Controller</code> 마다 로그인 유무를 체크하는 로직을
<br />
작성하면 추후 로그인 관련 로직이 변경될 경우 모든 로직을 바꿔야 하기 때문에 매우 비효율 적일 것이다.
<br />
그렇다면 이 <strong>공통관심사</strong> 를 분리해서 필터에 위임하면 유지보수가 훨씬 용이해 질 것이다. 
<br />
<code class="language-plaintext highlighter-rouge">Servlet Filter</code> 는 <code class="language-plaintext highlighter-rouge">Servlet</code>과 비슷한 <code class="language-plaintext highlighter-rouge">LifeCycle</code>을 가진다. (생성 - 초기화 - 필터 - 종료)</p>
<ul>
  <li>필터로 구현하면 좋은 기능들
    <ul>
      <li>인증(사용자 인증) 필터</li>
      <li>로깅 및 감시 필터</li>
      <li>이미지 변환 및 데이터 압축 필터</li>
      <li>암호화 필터</li>
      <li>XML 컨텐츠를 변형하는 XSLT 필터</li>
      <li>URL 및 기타 정보들을 캐싱하는 필터</li>
    </ul>
  </li>
</ul>

<p><br /></p>
<h2 id="관심사의-분리">관심사의 분리?</h2>
<p><code class="language-plaintext highlighter-rouge">Filter</code>를 공부하다가 <code class="language-plaintext highlighter-rouge">관심사의 분리</code> 라는 키워드를 보게 되었다.
<br />
<code class="language-plaintext highlighter-rouge">Filter</code>는 무슨 행동을 하기전에 먼저 실행하거나, 실행한 후 추가적인 행동을 할 때 사용하는데
<br />
스프링에는 <strong>공통처리</strong> 를 위해 활용할 수 있는 <code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">AOP</code> 가 더 있다.
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code>는 <code class="language-plaintext highlighter-rouge">Servlet</code>단위에서 실행되지만 <code class="language-plaintext highlighter-rouge">AOP</code>는 메소드 앞에 Proxy패턴의 형태로 실행된다.
<br />
실행순서는 <code class="language-plaintext highlighter-rouge">Filter</code>가 가장 밖에 있고 그안에 <code class="language-plaintext highlighter-rouge">Interceptor</code>, 그안에 <code class="language-plaintext highlighter-rouge">AOP</code>가 있는 형태이다.
<br />
따라서 요청이 들어오면 <code class="language-plaintext highlighter-rouge">Filter</code> → <code class="language-plaintext highlighter-rouge">Interceptor</code> → <code class="language-plaintext highlighter-rouge">AOP</code> → <code class="language-plaintext highlighter-rouge">Interceptor</code> → <code class="language-plaintext highlighter-rouge">Filter</code> 순으로 거치게 된다.</p>

<p><br /></p>

<h3 id="interceptor">Interceptor</h3>
<p>스프링에서 제공하는 기술이다. 
 <br />
 <code class="language-plaintext highlighter-rouge">DistpatcherServlet</code>이 <code class="language-plaintext highlighter-rouge">Controller</code>를 호출하기 전과 후에 응답을 참조하거나 가공한다.
<br />
<code class="language-plaintext highlighter-rouge">Filter</code>는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작하지만
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>는 스프링의 <code class="language-plaintext highlighter-rouge">DistpatcherServlet</code>이 <code class="language-plaintext highlighter-rouge">Controller</code>를 호출하기 전, 후로 끼어들기 때문에 
<br />
스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.</p>
<ul>
  <li>스프링의 모든 빈 객체에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">Interceptor</code>는 여러개를 사용할 수 있고 다음과 같은 작업을 수행한다.
    <ul>
      <li>로그인 체크</li>
      <li>권한 체크</li>
      <li>프로그램 실행시간 계산작업</li>
      <li>API 호출에 대한 로깅</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="aop">AOP</h3>
<p><strong>OOP</strong>를 보완하기 위해 나온 개념 
<br />
객체지향 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.
<br />
주로 <strong>비즈니스단</strong>의 메서드에서 로깅, 트랜잭션, 에러처리 등을 조금 더 세밀하게 조정하고 싶을 때 사용한다.
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code> 와 다르게 메서드 전후의 지점에 자유롭게 설정이 가능하고
<br />
<code class="language-plaintext highlighter-rouge">Interceptor</code>와 <code class="language-plaintext highlighter-rouge">Filter</code>는 주소로 대상을 구분해서 걸러내지만 <code class="language-plaintext highlighter-rouge">AOP</code>는 주소, 파라미터, 어노테이션 등 다양하게 대상을 지정할 수 있다.</p>
<ul>
  <li><strong>메서드 단위 공통로직</strong> 에 적합 예를들면, 각 메서드가 얼마나 걸리는지 시간측정하는 로그를 뿌리는 작업</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servletcontextlistener">ServletContextListener</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="tcp--udp">TCP / UDP</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="배치시스템-vs-스트리밍-시스템">배치시스템 vs 스트리밍 시스템</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="osi-7-계층">OSI 7 계층</h1>
<p>계층이 올라간다는건 무슨 의미일까?
<br />
<br />
TCP 기반의 HTTP가 UDP통신을 도입하고 있는데 과연 데이터 정합성의 문제는?</p>

<ul>
  <li>데이터 정합성의 검증을 한 계층 더 올려서 거기서 한다는데?</li>
  <li>그러니까 TCP를 사용하는 계층에선 정합성의 문제에서 자유로우니 UDP 통신을 이용한다?</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Apache Tomcat" /><category term="Servlet Filter" /><category term="Web" /><category term="Session" /><category term="OSI 7계층" /><category term="TCP / UDP" /><category term="Bulk 처리" /><category term="SSR" /><category term="CSR" /><category term="HTTPS" /><category term="Base64" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">refactoring</title><link href="http://localhost:4000/til/refactoring/" rel="alternate" type="text/html" title="refactoring" /><published>2023-01-13T00:00:00+09:00</published><updated>2023-01-13T00:00:00+09:00</updated><id>http://localhost:4000/til/refactoring</id><content type="html" xml:base="http://localhost:4000/til/refactoring/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="리팩토링">리팩토링?</h1>

<p>소프트웨어 관점으로 결과의 변경 없이 코드의 구조를 재조정함 을 의미한다.
<br />
즉, 기능은 보존하면서 설계 및 구조를 개선하는 것이다.</p>
<ul>
  <li>소프트웨어 설계가 좋아진다.</li>
  <li>소프트웨어를 이해하기 쉬워진다.</li>
  <li>버그를 쉽게 찾을 수 있다.</li>
  <li>프로그래밍 속도를 높일 수 있다.</li>
</ul>

<p><br />
<br /></p>

<p><strong>진짜 중복</strong></p>
<ul>
  <li>한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야한다.</li>
</ul>

<p><strong>우발적 중복 (거짓된 중복)</strong></p>
<ul>
  <li>중복으로 보이는 두 코드의 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="3의-법칙">3의 법칙</h1>
<ol>
  <li>처음에는 그냥 한다.</li>
  <li>비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.</li>
  <li>비슷한 일을 세 번째 하게 되면 리팩토링한다.</li>
</ol>

<p><br />
<br />
<br /></p>

<p><strong>기능을 새로 추가하기 직전</strong></p>
<ul>
  <li>리팩터링 하기 가장 좋은 시점은 기존 기능에 새로운 기능을 추가하기 직전이다.</li>
  <li>기능을 추가하기 쉽게만드는 것이 리팩터링의 핵심</li>
  <li>구조를 살짝 바꾸면 다른 작업하기 쉬워질 만한 부분을 찾는다.</li>
  <li>기능을 추가하면서 중복코드가 생길만한 부분을 함수화 시킨다.</li>
</ul>

<p><br /></p>

<p><strong>코드를 이해하기 어려울때</strong></p>
<ul>
  <li>코드 수정시 코드를 이해하기 어렵다면 이해를 위한 리팩터링을 진행한다.</li>
  <li>코드만 보더라도 이해를 쉽게 할 수 있도록 변수와 함수의 이름을 변경한다.</li>
  <li>코드를 이해하기 쉽게 만드는것은 협업하기도 좋고 코드를 오래 보존 할 수 있게된다.</li>
</ul>

<p><br /></p>

<p><strong>불필요한 코드를 발견했을때</strong></p>
<ul>
  <li>코드가 비효율적으로 수행되는 것을 발견했을대 리팩터링을 진행한다.</li>
  <li>로직 혹은 코드가 쓸데없이 복잡하거나 불필요한 코드를 발견했다면 보이스카웃 규칙을 떠올리자.</li>
  <li>원래 하려던 작업시간을 뺏길 수 있으니 간단한 일이라면 바로 처리하고, 시간이 좀 걸릴 것 같으면 <code class="language-plaintext highlighter-rouge">TODO</code>를 남겨두자.</li>
</ul>

<p><br /></p>

<p><strong>계획된 리팩토링</strong></p>
<ul>
  <li>수시로 진행하는 리팩터링 외에도 따로 시간을 내서 리팩터링을 진행 할 수 있다.</li>
  <li>미리 새기능을 추가 할 수 있도록 코드를 개선해둔다.</li>
  <li>코드가 이미 깔끔하다면 리팩터링을 하기에도 더 쉽다.</li>
</ul>

<p><br /></p>

<p><strong>오래걸리는  리팩토링</strong></p>
<ul>
  <li>각 잡고 전체 개발자들이 달려들어서 리팩토링을 하는 짓은 좋지않다.</li>
  <li>리팩토링 해야될 코드와 관련된 작업을 하게 될 때 마다 원하는 방향으로 조금씩 개선하는 방향을 추구하자</li>
</ul>

<p><br /></p>

<p><strong>코드리뷰에 리팩토링 활용하기</strong></p>
<ul>
  <li>PR 피드백을 활용하여 리팩토링 해나가는 것도 좋은 방법이다.</li>
</ul>

<p><br /></p>

<p><strong>리팩토링 하지 말아야 할 때</strong></p>
<ul>
  <li>호출해서 쓰는 코드라면 굳이 건들지 말자</li>
  <li>리팩터링보다 새로 코드를 작성하는 쉬운 코드의 경우 그냥 둔다.</li>
  <li>어떤 코드가 리팩터링보다 새로 만드는게 쉬운가에 대한 판단은 많은 경험이 뒷받침 되어야한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Refactoring" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">5 Week</title><link href="http://localhost:4000/til/5%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="5 Week" /><published>2023-01-12T00:00:00+09:00</published><updated>2023-01-12T00:00:00+09:00</updated><id>http://localhost:4000/til/5%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/5%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="solid">SOLID</h1>
<p>객체지향의 5가지 설계원칙</p>

<p><br /></p>

<p><strong><em>단일 책임 원칙 (SRP) - 한 클래스는 하나의 책임만 가져야 한다.</em></strong>
<br />
<br />
모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다.
<br />
한 클래스가 수행할 수 있는 책임 (기능)이 여러가지라면, 클래스 내부 함수끼리의 강한 결합이
<br />
발생할 가능성이 높아지고 이는 유지보수에 비효율적이다.
<br />
한 클래스를 변경하기 위해 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고있는 것이다.</p>

<p><br />
<br /></p>

<p><strong><em>개방-폐쇄 원칙 (OCP) - 확장에는 열려있고 변경에는 닫혀 있어야 한다.</em></strong>
<br />
<br />
수많은 모듈 중 하나를 수정할 때, 해당 모듈을 이용하는 다른 모듈들을 고쳐야 한다면 비효율적이다.
<br />
즉, 기능을 추가하거나 변경해도 이미 제대로 동작하고 있던 코드를 변경하지 않아도 기존의 코드에
<br />
새로운 코드를 추가함으로써 기능의 추가나 변경이 가능한걸 의미한다.
<br />
추상화는 개방-폐쇄 원칙의 핵심요소이다.
<br />
자주 변화하는 부분을 추상화 함으로써 유연함을 높인다.
<br />
모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 추상화의 파생클래스를 만드는것으로 확장이 가능하다.
<br />
객체지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성을 위한 핵심원칙이다.</p>

<p><br />
<br /></p>

<p><strong><em>리스코프 치환원칙 (LSP) - 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입의 인스턴스로 바꿀 수 있어야 한다.</em></strong>
<br />
<br />
하위타입객체는 상위타입객체에서 가능한 행위를 수행할 수 있어야 한다.
<br />
즉, 상위타입객체를 하위타입객체로 치환해도 정상적으로 동작해야 한다. == IS-A
<br />
객체지향 초기에는 상속을 사용하도록 가이드하는 방법 정도로 간주되었지만 시간이 지나면서 인터페이스와 구현체에도 적용되는 광범위한 원칙으로 바뀌었다.</p>

<p><br />
<br /></p>

<p><strong><em>인터페이스 분리원칙 (ISP) - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</em></strong>
<br />
<br />
클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.
<br />
큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
<br />
이는 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않게 한다.</p>

<p><br />
<br /></p>

<p><strong><em>의존관계 역전원칙 (DIP) - 추상화에 의존해야하고, 구체화에 의존하면 안된다.</em></strong>
<br />
<br />
의존 관계를 맺을 때, 
<br />
변하기 쉬운 것 (구체적인 것) 보다는 변하기 어려운 것 (추상적인 것)에 의존해야 한다
<br />
즉, 구체화된 클래스 보단 추상클래스나 인터페이스에 의존해야 한다.
<br />
<br />
상위계층이 하위계층의 구현으로부터 독립적이어야 한다.</p>
<ul>
  <li>상위모듈은 하위모듈에 의존해선 안되고, 상위모듈과 하위모듈 모두 추상화에 의존해야한다.</li>
  <li>추상화는 세부사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스레드">스레드</h1>
<p>운영체제에 메모리를 할당받아 실행중인 프로그램을 프로세스라고 한다.
<br />
스레드란 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다.
<br />
모든 프로세스는 한 개 이상의 스레드가 존재하며 1개는 단일스레드 2개 이상은 멀티스레드 라고 한다.
<br />
<br />
독립적인 프로세스들은 자원 및 데이터를 공유하지않아 리소스가 많이들어가지만 
<br />
멀티스레드의 경우는 자원 및 데이터 공유를 공유하기 때문에 리소스가 적게들어간다.
<br />
물론 데이터를 공유하기 때문에 동기화가 중요하다 -&gt; <code class="language-plaintext highlighter-rouge">thread-safe</code></p>

<p>모든 자바 어플리케이션은 메인스레드가 <code class="language-plaintext highlighter-rouge">main()</code> 메서드를 실행하면서 시작한다.
<br />
이러한 Main Thread 흐름 안에서 싱글 스레드가 아닌 멀티 스레드 어플리케이션은 필요에 따라 작업 쓰레드를 
<br />
만들어 병렬로 코드를 실행할 수 있다. 단일 스레드 같은 경우 메인 스레드가 종료되면 프로세스도 종료되지만 
<br />
멀티 스레드는 <strong>메인 스레드가 종료되더라도 실행 중인 스레드가 하나라도 있다면 프로세스는 종료되지 않는다.</strong></p>

<p><br /></p>

<p><strong>생성</strong></p>
<ul>
  <li>Runnable 인터페이스 구현</li>
  <li>Thread 클래스 상속</li>
  <li>람다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OfThreadClass</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">OfRunnableInterface</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">OfLambda</span> <span class="o">{</span>
	<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
		<span class="nc">String</span> <span class="n">threadName</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">threadName</span><span class="o">);</span>
	<span class="o">});</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"Thread #1"</span><span class="o">);</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>자바에서는 다중상속이 안되기 때문에, <code class="language-plaintext highlighter-rouge">Thread</code> 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없다. 
<br />
하지만 <code class="language-plaintext highlighter-rouge">Runnable</code> 인터페이스를 구현하는 경우에는 다른 인터페이스를 구현할 수도 있고 다른클래스도 상속 받을수 있다는 장점이 있다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="자바는-느리다">자바는 느리다?</h1>
<p>자바는 <code class="language-plaintext highlighter-rouge">Python</code> , <code class="language-plaintext highlighter-rouge">JavaScript</code> 같은 인터프리터 , 스크립트 언어 보다는 빠르다.
<br />
하지만 <code class="language-plaintext highlighter-rouge">C/C++</code> , <code class="language-plaintext highlighter-rouge">Pascal</code> , <code class="language-plaintext highlighter-rouge">Fortran</code> 같은 네이티브 바이너리 코드를 만드는 언어에 비해선 느리다.
<br />
그 이유는 여러가지가 있지만 크게 2가지를 들 수 있다.</p>
<ul>
  <li>객체지향 언어의 특성</li>
  <li>JVM이라는 가상머신 사용</li>
</ul>

<p>자바는 개발자의 편의성을 위해 성능을 희생하고 있는데 시간이 지나면서
<br />
자바의 소프트웨어와 하드웨어가 발전해서 초기이슈였던 성능이슈는 잠잠해 졌지만
<br />
여전히 부족한 하드웨어 스펙을 쓰는 소규모 장비에선 C언어를 주로 사용한다.</p>

<p><br /></p>

<p><strong><em>객체지향의 특성</em></strong>
<br />
<br />
자바는 클래스 단위로 모든 코드를 작성한다. C언어와 같은 함수단위가 아니기때문에
<br />
다른 클래스에 있는 메서드나 정보를 사용하기 위해선 해당 클래스 전체를 인스턴스로 만들어야 한다.
<br />
그만큼 메모리와 코드를 찾아 로드하는 시간에 많은 리소스가 들게되고 이것을 피하려고 <code class="language-plaintext highlighter-rouge">static</code> 사용이나
<br />
클래스 단위를 잘게 쪼개서 작성할 경우 객체를 다루는 효율성이 떨어지게 된다.
<br />
그렇기 때문에 자바는 C언어와 달리 모든 코드를 미리 메모리에 올려두지 않고 필요할 때 마다 가져다 쓰는
<br />
<strong>동적 할당 방식</strong>을 사용하기 때문에 C언어보다 상대적으로 느릴 수 밖에 없다.</p>

<p><br /></p>

<p><strong><em>JVM</em></strong>
<br />
<br />
C언어는 컴파일 시 코드를 모드 기계어로 번역해 메모리에 올려두고 실행한다. 하지만 자바에서는
<br />
바이트코드로 먼저 컴파일 한 뒤, 동적할당 된 코드를 JVM의 JIT과 같은 방식으로 실행한다.
<br />
이렇게 함으로써 운영체제에 종속적이지 않게 된다는 이점이 있지만 그만큼 성능을 희생하게 된다.
<br />
또한 C언어에서는 동적할당한 메모리를 개발자가 직접 바로 해제하지만, 자바는 GC가 메모리를 해제하기 때문에
<br />
이 GC또한 프로그램이기 때문에 메모리와 연산작업을 동반하게 된다.</p>

<p><br /></p>

<p><strong><em>인터프리터 / 스크립트 언어</em></strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">Python</code>과 같은 인터프리터 방식의 언어는 <strong>코드를 한줄씩</strong> 읽어 기계어로 번역한다.
<br />
그리고 같은 기능을 하는 코드가 다시 나와도 또 다시 해석하여 결과를 출력한다. 
<br />
이 때문에 일반적으로 컴파일 방식의 언어보다 수행 속도가 느리다.
<br />
하지만 수정사항이 발생했을 때, 컴파일러가 소스코드를 읽어 실행 파일을 만드는 자바는 소스코드를
<br /> 
다시 컴파일 해야하지만 인터프리터 언어는 소스코드를 수정해서 실행시키면 끝나기 때문에 수정이
<br />
아주 간단하다는 장점이 있다. 즉, 개발편의성이 좋다는 의미이다.
<br />
<code class="language-plaintext highlighter-rouge">Python</code>은 이 약점을 극복하기 위해 라이브러리들의 내부는 C / C++ 으로 되어있다.
<br />
<br />
그리고 이 장점을 최대한 살린것이 스크립트 언어이다.</p>

<p><br /></p>

<h2 id="io--nio">IO / NIO</h2>
<p>자바는 직접 메모리를 관리하고 운영체제의 <strong>시스템 콜</strong> 을 직접 사용하기 힘들다.
<br />
자바가 특별히 성능이 좋지 않은 부분이 <code class="language-plaintext highlighter-rouge">IO</code> 이고 이걸 개선한 것이 <code class="language-plaintext highlighter-rouge">NIO</code> 패키지 이다.</p>

<p><br /></p>

<ul>
  <li><strong><em>IO</em></strong>
    <ul>
      <li>
        <p><strong><em>Blocking API</em></strong>
  <br />
  API 를 호출한 스레드가 API의 작업이 끝날 때까지 다른동작을 하지 않는 API 를 말한다. <code class="language-plaintext highlighter-rouge">(idle 상태)</code>
  <br />
  자바의 기본 IO는 이 <code class="language-plaintext highlighter-rouge">Blocking API</code>로 사용되어 왔기 때문에 <code class="language-plaintext highlighter-rouge">File IO</code> 뿐만 아니라
  <br />
  <code class="language-plaintext highlighter-rouge">Network IO</code> 또한 오래 걸리기 때문에 더욱 자바에게 느리다는 인상을 심어준 녀석이다.</p>
      </li>
      <li>
        <p><strong><em>Stream 기반</em></strong>
  <br />
  스트림 기반의 IO는 스트림으로부터 한번에 여러 바이트를 읽는다. 데이터는 캐싱되어 있지 않고
  <br />
  스트림 속 데이터에서 앞뒤로 이동할 수 없다. 만약 스트림으로 읽은 데이터 내부에서 앞뒤로
  <br />
  이동해야 한다면 버퍼를 만들어 캐싱을 해야한다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>NIO</em></strong>
    <ul>
      <li>
        <p><strong><em>Non Blocking API</em></strong>
  <br />
  API 호출 시 요청한 작업의 완료여부와 상관없이 즉각적으로 현재 상태에 대한 답이 온다.
  <br />
  그렇기 때문에 API 호출 후 스레드 제어권이 있기 때문에 다른작업을 진행할 수 있다.</p>
      </li>
      <li>
        <p><strong><em>Buffer 기반</em></strong>
  <br />
  이미 처리된 버퍼로부터 데이터를 읽는다. 필요하다면 버퍼 내부에서 앞뒤로 이동할 수 있다.
  <br />
  즉, 데이터를 처리하는 동안 좀 더 유연함을 제공해 주지만 데이터를 완벽하게 처리하려면
  <br />
  필요한 데이터가 모두 버퍼 안에 있어야 한다. 또한 버퍼에서 더많은 데이터를 읽을때 버퍼속에서
  <br />
  아직 전처리되지 않은 데이터를 사용하지 않도록 확실히 해야한다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<code class="language-plaintext highlighter-rouge">NIO</code>는 불특정 다수의 클라이언트 연결 또는 멀티 파일들을 넌블로킹이나 비동기로 처리할 수 있다.
<br />
과도한 스레드 생성을 피하고 스레드를 효과적으로 재사용한다는 점이 큰 장점이다.
<br />
운영체제의 버퍼(다이렉트 버퍼)를 이용한 입출력이 가능하기 때문에 입출력 성능 향상
<br />
<code class="language-plaintext highlighter-rouge">NIO</code>는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우에 사용하는것이 좋다.
<br />
스레드에서 입출력 처리가 오래 걸린다면 대기하는 작업의 수가 늘어나기 때문에 제한된 스레드로 처리하는 것이 불편할 수 있다.
<br />
<br />
<br />
대용량의 데이터 처리의 경우 <code class="language-plaintext highlighter-rouge">IO</code>가 좋다.
<br />
연결 클라이언트 수가 적고 전송되는 데이터가 대용량이면서 순차적으로 처리될 필요성이 있는 경우 
<br />
<code class="language-plaintext highlighter-rouge">IO</code>로 서버를 구현하는 것이 좋다. <code class="language-plaintext highlighter-rouge">NIO</code>는 버퍼 할당 크기도 문제되고, 모든 입출력 작업에 버퍼를
<br />
무조건 사용해야 하므로 받은 즉시 처리하는 <code class="language-plaintext highlighter-rouge">IO</code>보다 복잡하다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="io">I/O</h1>
<p>데이터의 입력(Input) / 출력(Output)이다. <code class="language-plaintext highlighter-rouge">I/O</code> 는 어플리케이션 성능에 가장 큰 영향을 미치는데
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 에서 발생하는 시간은 CPU를 사용하는 시간과 대기 시간이 있고 어플리케이션이 연산을 할 때까지
<br />
CPU가 다음 작업 실행을 block 한다. <code class="language-plaintext highlighter-rouge">I/O</code> 로 인한 blocking은 CPU를 긴 시간동안 idle 상태에 두는데
<br />
이것은 다른작업을 할 수 있음에도 할수가 없어 매우 비효율 적이다.</p>
<ul>
  <li>파일 <code class="language-plaintext highlighter-rouge">I/O</code> 뿐만 아니라 어떤 디바이스를 통해 입력과 출력이 이뤄지는 작업을 모두 말한다.
    <ul>
      <li>다른 서버로부터 데이터를 전송받는것도 <code class="language-plaintext highlighter-rouge">I/O</code> 에 포함한다.</li>
      <li>콘솔에 출력하는 것도 스트림을 통해 출력하는 것이기 때문에 <code class="language-plaintext highlighter-rouge">I/O</code> 이다.</li>
    </ul>
  </li>
</ul>

<p><br />
<code class="language-plaintext highlighter-rouge">I/O</code> 는 어플리케이션에서 직접 수행 될 수 없고 무조건 커널에 한번 이상 시스템콜을 보내야 한다.
<br />
시스템 콜을 보내면 그순간 커널로 제어권이 넘어가고 (context-switch), 유저 프로세스 / 스레드는 제어권이
<br />
다시 돌아오기 전까진 block상태가 되고 그동안 다른 작업을 하지 못하게 된다.</p>

<p><br /></p>

<h2 id="blocking-io">blocking I/O</h2>
<p><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 진행되는 동안 프로세스가 자신의 작업을 중단하고 <code class="language-plaintext highlighter-rouge">I/O</code>가 끝날때까지 block 되는 방식이다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 가 호출되면 완료되기 전까지 제어권을 커널이 가져가서 유저 프로세스 / 스레드는 block 상태가 된다.</p>

<ul>
  <li>장점
    <ul>
      <li>호출마다 스레드를 생성하니 요청이 적은 서비스에서 효율이 좋다. (병렬작업의 장점)</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>요청마다 스레드를 생성하는 부분의 리소스가 크다.</li>
      <li><code class="language-plaintext highlighter-rouge">context-switching</code> 이 빈번하게 일어난다.</li>
      <li>각각의 스레드는 <code class="language-plaintext highlighter-rouge">I/O</code> 작업이 완료되기 전까진 block 상태가 된다.</li>
    </ul>
  </li>
</ul>

<p><br />
전통적인 방식에서는 스레드를 늘려 멀티스레드를 지원하는 방식으로 진화해 나갔다.
<br />
하지만 스레드 갯수에는 한계가 있고 리소스 측면에서도 좋지 않기 때문에 각 <code class="language-plaintext highlighter-rouge">I/O</code>에 대해서 장시간 
<br />
사용하지 않고 실행되어 있는 스레드를 방치하는 것은 효율성 측면에서 최상의 방법은 아니다.</p>

<p><br /></p>

<h2 id="non-blocking">non blocking</h2>
<p><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 완료될 때 까지 커널이 제어권을 가지지 않고 <code class="language-plaintext highlighter-rouge">I/O</code> 호출에 대해 즉시 응답을 리턴하는 방식이다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 호출되면 작업 여부와는 무관하게 즉시 결과를 리턴하고, 커널이 시스템콜을 받자마자 CPU 제어권을 다시 어플리케이션에게
넘겨주게 된다. 그리고 어플리케이션은 다른 작업을 수행하다 중간중간 시스템콜을 보내 <code class="language-plaintext highlighter-rouge">I/O</code>가 완료되었는지 커널에게 물어보고 완료되면 <code class="language-plaintext highlighter-rouge">I/O</code> 작업을 완료한다.</p>

<ul>
  <li>장점
    <ul>
      <li><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 완료되기 전까진 block 상태가 되지 않는다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>반복적으로 시스템콜이 일어나게 된다.</li>
    </ul>
  </li>
</ul>

<p><br />
싱글스레드 방식으로 block되는 시간을 최소화 할 수 있어 <code class="language-plaintext highlighter-rouge">I/O</code> 작업(read/write) 이 많은 경우 유리하지만
<br />
CPU의 할일이 많은 경우에는 적합하지 않다.</p>

<p><br />
<br /></p>

<h2 id="io-이벤트-통지-모델">I/O 이벤트 통지 모델</h2>
<p><code class="language-plaintext highlighter-rouge">non blocking</code> 의 문제인 반복적 시스템콜 호출을 해결하기 위해 <code class="language-plaintext highlighter-rouge">I/O</code> <strong>이벤트 통지 모델</strong>이 도입되었다.
<br />
반복적으로 시스템콜을 호출하지 않고 입력 버퍼에서 완료되었다는 알림(이벤트 통지 모델)을 주게 된다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 결과 반환 방식에 따라 <strong>Sync(동기)</strong> / <strong>Async(비동기)</strong> 모델로 분류한다.</p>
<ul>
  <li><strong>이벤트</strong> : <strong>수신버퍼</strong> or <strong>출력버퍼</strong>에 데이터를 처리하는 동작을 의미한다.</li>
  <li><strong>수신버퍼</strong> : 입력버퍼에 데이터가 수신되었다는 걸 알림 출력</li>
  <li><strong>출력버퍼</strong> : 출력버퍼가 비었으니 데이터 전송이 가능한 상황을 알림</li>
</ul>

<p><br /></p>

<h3 id="sync-동기">Sync (동기)</h3>
<p><code class="language-plaintext highlighter-rouge">I/O</code> 작업이 진행되는 동안 유저 프로세스는 결과를 기다렸다가 이벤트(결과)를 직접 처리하는 방식이다.
<br />
<code class="language-plaintext highlighter-rouge">blocking</code> 방식처럼 완료될 때 까지 기다릴 수도 있고, <code class="language-plaintext highlighter-rouge">non blocking</code> 방식처럼 커널에 계속 요청할 수 도 있다.
<br />
<code class="language-plaintext highlighter-rouge">I/O</code> 가 완료될 때 까지 계속 기다리던가, 다른작업을 하면서 기다리던가 결국에는 기다려야 하지만
<br />
<strong><em>다른점</em></strong>은 <code class="language-plaintext highlighter-rouge">notify</code>를 <strong>유저 프로세스가 주체적</strong>으로 진행하고 커널은 유저 프로세스의 요청에 수동적으로 응답한다.</p>

<p><br /></p>

<h3 id="async-비동기">Async (비동기)</h3>
<p><code class="language-plaintext highlighter-rouge">I/O</code>가 진행되는 동안 유저 프로세스는 자신의 일을 하다가 이벤트 핸들러에 의해 알림이 오면 처리하는 방식이다.
<br />
결국 <code class="language-plaintext highlighter-rouge">notify</code>를 <strong>커널이 주체적</strong>으로 진행하며, 유저 프로세스는 수동적인 입장에서 통지가 오면 그때 <code class="language-plaintext highlighter-rouge">I/O</code> 처리를 
<br />
한다. (이벤트 핸들러, callback)에 의해 운영체제에서 처리 결과 통지받는다.</p>

<p><br /></p>

<h3 id="뭐쓰는데">뭐쓰는데?</h3>
<p><strong>Sync</strong> : 어떤 작업을 수행한 결과로 다음 작업을 수행해야 하는 즉, 순차적 작업일 때 (인출 후 송금)
<br />
<strong>Async</strong> : <code class="language-plaintext highlighter-rouge">I/O</code> 작업이 많을 때</p>

<p><br /></p>

<h2 id="차이">차이?</h2>
<ul>
  <li><strong><em>블로킹/논블로킹</em></strong> : 각 작업의 수행 형태와 우선순위에 따라 각 작업의 수행가능 시기를 어떻게 제어할 것인가.</li>
  <li><strong><em>동기/비동기</em></strong> : 각 작업이 주고받는 데이터의 상태와 흐름을 어떻게 제어할 것인가. 데이터의 일관성 유지
<br />
<br />
즉, <strong>특정 작업의 행위가 일어나는 시점 관리</strong> 라는 관심사가 다르다.
<br />
또한 <code class="language-plaintext highlighter-rouge">notify</code>의 제어권을 가짐으로써 시스템콜 호출에 대한 차이도 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="동시성이슈">동시성이슈</h1>
<p>동시성이슈란?
<br />
<br /></p>
<ul>
  <li>노드js는 프로세스에 참가하는 스레드가 하나 인데 동시성문제에 어떻게 이점을 가져갈까?
    <ul>
      <li>노드는 컨텍스트 스위칭에 들어가는 리소스가없다?</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="동시성-임계구역">동시성 임계구역</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="web-동작">Web 동작</h1>
<ul>
  <li><strong>Request</strong>
    <ul>
      <li>사용자가 입력한 <code class="language-plaintext highlighter-rouge">URL</code> 주소 중 도메인 네임 부분을 <code class="language-plaintext highlighter-rouge">DNS</code> 서버에서 검색 후 IP 주소로 변환</li>
      <li>IP 주소로 <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 사용해 <code class="language-plaintext highlighter-rouge">HTTP</code> 요청 메시지를 생성 후 <code class="language-plaintext highlighter-rouge">TCP</code> 프로토콜을 사용해 사용자가 입력한 <code class="language-plaintext highlighter-rouge">URL</code> 정보와 함께 전송</li>
    </ul>
  </li>
  <li><strong>Response</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code> 메시지를 받고 요청 URL에 대한 데이터 검색</li>
      <li>검색된 데이터를 <code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 사용해 <code class="language-plaintext highlighter-rouge">HTTP</code> 응답 메시지를 <code class="language-plaintext highlighter-rouge">TCP</code> 프로토콜을 사용해 전송</li>
      <li>랜더링 과정을 거쳐 클라이언트 화면에 표시</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Web Server</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">HTTP</code> 프로토콜을 기반으로 하여 웹 브라우저의 요청을 서비스 하는 기능을 담당</li>
      <li><strong>정적</strong> 인 컨텐츠를 제공할 때는 <code class="language-plaintext highlighter-rouge">WAS</code>를 거치지 않고 바로 제공</li>
      <li><strong>동적</strong> 인 컨텐츠 요청이 들어오면 요청을 <code class="language-plaintext highlighter-rouge">WAS</code> 로 보내고 처리한 결과는 <code class="language-plaintext highlighter-rouge">WAS</code> 가 전달</li>
      <li><code class="language-plaintext highlighter-rouge">Apache Server</code>, <code class="language-plaintext highlighter-rouge">Nginx</code>, <code class="language-plaintext highlighter-rouge">IIS</code> 등</li>
    </ul>
  </li>
  <li><strong>WAS (Web Application Server)</strong>
    <ul>
      <li>DB 조회나 다양한 로직 처리를 요구하는 <strong>동적</strong> 인 컨텐츠를 <code class="language-plaintext highlighter-rouge">HTTP</code> 통신을 통해 제공하는 기능을 담당</li>
      <li>웹 컨테이너, 혹은 서블릿 컨테이너 라고도 불리우며 <code class="language-plaintext highlighter-rouge">JSP</code>, <code class="language-plaintext highlighter-rouge">Servlet</code> 구동 환경을 제공하는 서버</li>
      <li>분산 트랜잭션, 보안, 메시징, 스레드 처리 등의 기능을 처리하는 분산 환경에서 사용</li>
      <li><code class="language-plaintext highlighter-rouge">Tomcat</code>, <code class="language-plaintext highlighter-rouge">JBoss</code>, <code class="language-plaintext highlighter-rouge">Jeus</code>, <code class="language-plaintext highlighter-rouge">Web Sphere</code> 등</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>2개를 따로 쓰는 이유?</strong>
    <ul>
      <li>기능을 분리하여 서버 부하를 방지</li>
      <li>오류 화면 노출 가능 (<code class="language-plaintext highlighter-rouge">WAS</code> 장애 시 오류 화면 노출 불가능 할 수 있음)</li>
      <li>여러 대의 <code class="language-plaintext highlighter-rouge">WAS</code>를 연결해 로드 밸런싱 용도로 사용</li>
      <li>물리적으로 분리하여 보안을 강화
        <ul>
          <li><code class="language-plaintext highlighter-rouge">SSL</code> 대한 암복호화 처리에 <code class="language-plaintext highlighter-rouge">Web Server</code> 를 사용</li>
        </ul>
      </li>
      <li>여러 언어의 웹 어플리케이션 서비스가 가능
        <ul>
          <li>하나의 서버에서 <code class="language-plaintext highlighter-rouge">PHP Application</code>, <code class="language-plaintext highlighter-rouge">Java Application</code> 를 함께 사용하는 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="쿠키--세션">쿠키 / 세션</h1>
<p>HTTP 프로토콜 환경은 <code class="language-plaintext highlighter-rouge">connectionless, stateless</code> 하기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 하기 때문에 이 특성을 보완하기 위해서 쿠키와 세션을 사용한다.
<br />
예를들어 쇼핑몰에서 옷을 구매하기위해 로그인했지만 페이지를 이동해야할때마다 계속 로그인을 해야한다.
<br />
쿠키와 세션은 비슷한 역할을 하며 동작원리도 비슷하지만 정보가 저장되는 위치가 다르다.</p>

<ul>
  <li><strong>connectionless</strong>
    <ul>
      <li>클라이언트가 요청한 후 응답을 받으면 연결을 끊어버림</li>
      <li>클라이언트가 request를 보내면 서버는 response를 보내고 접속을 끊는다.</li>
    </ul>
  </li>
  <li><strong>stateless</strong>
    <ul>
      <li>통신이 끝나면 상태를 유지하지 않는 특성</li>
      <li>연결이 끝나는 순간 클라와 서버의 통신이 끝나며 상태정보를 유지하지 않는다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>cookie</strong>
<br /></p>
<ul>
  <li>클라이언트 로컬에 저장되어 있는 키와 값으로 구성된 데이터 파일</li>
  <li>인증의 유효시간을 명시할 수 있고, 유효시간이 정해지면 브라우저가 종료되도 인증이 유지됨</li>
  <li>쿠키는 클라이언트의 상태정보를 로컬에 저장했다가 참조함</li>
  <li>따로 요청하지 않아도 Request Header를 넣어서 자동으로 서버에 전송</li>
  <li>
    <p>요청속도는 세션보다 빠르다.</p>
  </li>
  <li><strong>어디에써?</strong>
    <ul>
      <li>로그인 시 “아이디와 비밀번호를 저장하시겠습니까?”</li>
      <li>장바구니 기능</li>
      <li>자동로그인, 팝업 등에서 “오늘 더이상 이창을 보지 않음”</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>session</strong></p>
<ul>
  <li>쿠키를 기반으로 하지만 서버에서 관리함</li>
  <li>클라이언트를 구분하기 위해 세션 ID를 부여해 브라우저를 종료할 때 까지 인증상태를 유지</li>
  <li>접속시간에 제한을 둬서 정보가 유지되지 않게 할 수 있음</li>
  <li>서버에 정보를 둬서 보안에 더 좋지만 메모리를 많이 차지하게 됨</li>
</ul>

<p><br /></p>

<p><strong>cache</strong>
<br />
<br />
캐시는 웹페이지를 빠르게 렌더링 할 수 있게 도와주기 위해 웹페이지의 요소(css, 이미지, 비디오 등등) 를 저장하기 위한 임시저장소이다.
<br />
쿠키/세션은 정보를 저장하기위해 사용하고 사용자의 인증을 도와준다.</p>

<p><br /></p>

<p><strong>JWT</strong>
<br />
<br />
JWT는 Json Web Token의 약자이고 인증에 필요한 정보들을 암호화 시킨 토큰을 말한다.
<br />
토큰 자체를 쿠키에 담아서 보내줄 수 있고 HTTP 헤더에 담아서 보내줄 수 도 있다.
<br />
하지만 일단 발급을 하면 토큰이 만료되기 전까지 토큰의 유효성을 막을 수 없다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="servlet">Servlet</h1>
<p>동적인 웹페이지를 만들 때 사용되는 자바기반 기술이다.
<br />
<code class="language-plaintext highlighter-rouge">Request / Response</code> 흐름을 간단한 메서드 호출로 다룰 수 있게 해준다.
<br />
서블릿을 통해 개발자는 비즈니스 로직에 더 집중할 수 있다.</p>

<ul>
  <li>Request에 동적으로 작동하는 웹 어플리케이션 컴포넌트</li>
  <li>HTML을 사용해 response 한다.
    <ul>
      <li>HTML 변경 시 재 컴파일해야 한다.</li>
    </ul>
  </li>
  <li>자바의 스레드를 이용해 동작한다.</li>
  <li>MVC패턴에서 Controller 로 이용된다.</li>
  <li>HTTP 프로토콜을 지원하는 HttpServlet 클래스를 상속받는다.</li>
</ul>

<p><br /></p>

<p><strong>서블릿 동작 과정</strong></p>
<ol>
  <li>Servlet Request, Servlet Response 객체를 생성</li>
  <li>설정 파일을 참고하여 매핑할 Servlet을 확인</li>
  <li>해당 서블릿 인스턴스 존재의 유무를 확인하여 없으면 생성</li>
  <li>Servlet Container에 스레드를 생성하고 service를 실행</li>
  <li>응답을 처리하면 Servlet Request, Servlet Response 객체를 소멸</li>
</ol>

<p><br />
<br /></p>

<h2 id="servlet-container">Servlet Container</h2>
<p>서블릿을 담고 관리해주는 컨테이너
<br />
Request에가 오면 HttpServletRequest, HttpServletResponse 객체를 생성해 
<br />
GET / POST 여부에 따라 동적 페이지를 생성해 Response를 보낸다.</p>

<ul>
  <li>
    <p><strong>HttpServletRequest</strong>
<br />
헤더정보, 파라미터, 쿠키, URL 등의 정보를 읽는 메서드와 body의 stream을 읽는 메서드 보유</p>
  </li>
  <li>
    <p><strong>HttpServletResponse</strong>
<br />
WAS는 HttpServleResponse 객체를 생성해 서블릿에게 전달하고 이 객체로 contentType, 응답코드, 응답메시지 등을 전송한다.</p>
  </li>
</ul>

<p><br /></p>

<p><strong>주요기능</strong></p>
<ul>
  <li>
    <p><strong>생명주기 관리</strong>
<br />
서블릿클래스를 인스턴스화 하고 요청에 따라 적절한 서블릿메서드를 찾아 동작한다.
<br />
그리고 라이프사이클이 끝나면 가비지컬렉션을 통해 메모리에서 지운다.</p>
  </li>
  <li>
    <p><strong>통신지원</strong>
<br />
클라이언트와 Request / Response 할 수 있게 웹서버와 소켓을 만들어 통신을 해준다.</p>
  </li>
  <li>
    <p><strong>멀티스레드 관리</strong>
<br />
해당 서블릿의 요청이 들어오면 스레드를 생성해 작업을 수행한다.</p>
  </li>
  <li>
    <p><strong>선언적인 보안관리</strong>
<br />
보안관련 기능을 제공하기 때문에 자바 클래스에 보안관련 메서드를 구현하지 않아도 된다.</p>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="SOLID" /><category term="스레드" /><category term="인터프리터 언어" /><category term="Blocking / Non Blocking" /><category term="동시성" /><category term="Servlet" /><category term="Cookie / Session" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">4 Week</title><link href="http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="4 Week" /><published>2023-01-05T00:00:00+09:00</published><updated>2023-01-05T00:00:00+09:00</updated><id>http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="cqrs-pattern">CQRS Pattern</h1>
<p>Command and Query Responsibility Segregation (명령과 조회의 책임 분리)
<br />
즉, 명령(command)및 쿼리의 책임을 분리하는 패턴이다. 책임분리를 위해서는 코드의 모듈이 분리되어야 한다.
<br />
read 와 write를 분리하는것을 뜻하며 어플리케이션까지만 적용할 수도 있고, DB의 모델까지만 분리할 수도 있고, DB 그 자체를 분리하여 적용할 수도 있다.</p>

<ul>
  <li>명령은 데이터중심이 아니라 작업 기반이어야 한다.</li>
  <li>명령은 동기적으로 처리되지 않고 비동기처리를 위해 큐에 배치될 수 있다.</li>
  <li>쿼리는 데이터베이스를 수정하지 않는다. 쿼리는 도메인 지식을 캡슐화하지 않는 DTO를 반환한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>읽기 모델과 쓰기 모델을 필요에 따라 독립적으로 확장 가능</li>
      <li>읽기 모델은 쿼리에 최적화된 스키마를 사용 가능</li>
      <li>호출되는 도메인 엔티티에 대해 확인하는 로직 구현이 더 쉬움</li>
      <li>보통 복잡한 비지니스 로직 구현은 대부분 쓰기 모델에 속하며, 읽기 모델은 간단하게 구현된다. 그에 따라 읽기와 쓰기를 분리하면 유지관리가 더 쉽고 유연한 모델이 구현될 수 있다.</li>
      <li>DB에 논리적인 View가 아닌, Materialized View를 저장함으로써 애플리케이션에서 복잡한 조인이 사용된 쿼리문을 피할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>언제 쓰면 좋을까?</em></strong>
    <ul>
      <li>많은 사용자가 동일한 테이터에 병렬로 엑세스 하는 공동작업 도메인일 경우</li>
      <li>한팀은 쓰기모델에 포함되는 복잡한 도메인 모델에 집중하고 다른팀은 읽기모델과 사용자 인터페이스에 집중할 수 있을 환경일 경우</li>
      <li>시스템이 시간이 자나면서 진화할 것으로예상되어 여러 버전의 모델을 포함할 수 있거나 비즈니스 규칙이 정기적으로 변하는 경우</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="generic">Generic</h1>
<p>아주 유용한 문법이고 대부분 최신 언어에선 사용한다.
<br />
타입시스템을 더 견고하게 사용하기 위해 제네릭을 사용한다.
<br />
제네릭은 형변환시 발생할 수 있는 문제들을 사전에 없앨 수 있다.
<br />
즉, 타입을 파라미터화 해서 컴파일 시 구체적인 타입이 결정되도록 해준다.</p>

<ul>
  <li>파라미터 타입, 리턴 타입에 대한 정의를 클래스 내부가 아닌 외부에서 지정</li>
  <li>타입에 대해 유연성과 안정성을 확보한다.</li>
  <li>런타임 환경에 영향이 없는 컴파일 시점의 전처리 기술이다.
    <ul>
      <li>타입을 유연하게 처리하며, 런타임에 발생할 수 있는 타입에러를 컴파일전에 검출한다.</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CastingDTO</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="no">T</span> <span class="nc">Object</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setObject</span><span class="o">(</span><span class="no">T</span> <span class="nc">Object</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">object</span> <span class="o">=</span> <span class="n">object</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="no">T</span> <span class="nf">getObject</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">object</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 형변환을 하지않고 편리하게 사용할 수 있다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkCastingDTO</span><span class="o">()</span> <span class="o">{</span>
	<span class="nc">CastingDTO</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dto1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CastingDTO</span><span class="o">&lt;&gt;();</span>
	<span class="n">dto1</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">());</span>

	<span class="nc">CastingDTO</span><span class="o">&lt;</span><span class="nc">StringBuffer</span><span class="o">&gt;</span> <span class="n">dto2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CastingDTO</span><span class="o">&lt;&gt;();</span>
	<span class="n">dto2</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">());</span>

	<span class="nc">String</span> <span class="n">test1</span> <span class="o">=</span> <span class="n">dto1</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span> 
	<span class="nc">StringBuffer</span> <span class="n">test2</span> <span class="o">=</span> <span class="n">dto2</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="특징">특징</h2>
<ul>
  <li>클래스 또는 메서드에 선언 가능</li>
  <li>동시에 여러타입 선언 가능</li>
  <li>와일드카드를 이용해 타입에 대해 유연한 처리 가능</li>
  <li>제네릭 선언 및 정의시 타입의 상속관계 지정 가능</li>
</ul>

<p><br /></p>

<h2 id="컨벤션">컨벤션</h2>
<p>제네릭 타입을 선언할 때 어느정도의 컨벤션이 존재한다.</p>
<ul>
  <li>E : Element (컬렉션에서 주로 사용됨)</li>
  <li>K : Key</li>
  <li>T : Type</li>
  <li>N : Number</li>
  <li>V : Value</li>
  <li>? : Wild Card
    <ul>
      <li>모든 타입을 다 매개변수로 받을 수 있다.
        <ul>
          <li> extends T : 상한 경계</li>
          <li>? super T : 하한 경계</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="타입범위지정">타입범위지정</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// T에 비교불가능한 타입이 온다면 이 메서드는 기능을 수행할 수 없다.</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span> <span class="no">T</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span> 
	<span class="kt">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="kt">double</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="k">return</span> <span class="nc">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">);</span> 
<span class="o">}</span>

<span class="c1">// Number를 상속받는 클래스만 올 수 있도록 지정할 수 있다.</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span> <span class="no">T</span> <span class="n">t2</span><span class="o">)</span> <span class="o">{</span> 
	<span class="kt">double</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="kt">double</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span> 
	<span class="k">return</span> <span class="nc">Double</span><span class="o">.</span><span class="na">compare</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">);</span> 
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong>&lt;? extends T&gt;</strong> 와일드 카드의 상한 제한(upper bound) : T 타입과 T를 상속 받고 있는 타입</li>
  <li><strong>&lt;? super T&gt;</strong> 와일드 카드의 하한 제한(lower bound) : T 타입과 T의 상위 타입</li>
</ul>

<p><br /></p>

<h2 id="제네릭-클래스">제네릭 클래스</h2>
<p>클래스 인스턴스화 시점에 제네릭 파라미터를 통해 타입 전달</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Sample</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span> 
	<span class="kd">private</span> <span class="no">T</span> <span class="n">anonyTypeData</span><span class="o">;</span> 
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="제네릭-메서드">제네릭 메서드</h2>
<p>메서드 호출 시점에 제네릭으로 리턴 타입, 파라미터의 타입이 정해지는 메서드</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span> 
	<span class="kd">static</span> <span class="no">T</span> <span class="nf">getName</span><span class="o">(</span><span class="no">T</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> 
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span> 
	<span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>
<p>static 메서드는 제네릭을 사용할 수 없다.
<br />
인스턴스화 되기전에 메모리에 올라가야 하는데 타입이 결정되지 않았기 때문이다.</p>

<p><br /></p>

<h2 id="제네릭의-타입소거">제네릭의 타입소거</h2>
<p><strong>제네릭의 primitive 타입 사용 불가</strong>
<br />
<strong>타입소거</strong>란 원소 타입을 컴파일 타임에만 검사하고 <strong>런타임에는 해당 타입 정보를 알 수 없는 것</strong>이다. 
<br />
다른 말로는 컴파일 타임에만 타입에 대한 제약 조건을 적용하고, 런타임에는 타입에 대한 정보를 소거하는 것을 말한다.
<br />
제네릭에 primitive 타입을 사용하지 못하는 이유는 타입 소거와 관련이 있다.
<br />
제네릭 클래스는 타입 소거의 첫번째 규칙에 의해 타입 파라미터를 Object로 교체하는데 primitive 타입은 
<br />
Object의 하위 타입이 아니기 때문에 제네릭에서 사용하는 것이 불가능하기 때문이다.</p>

<ul>
  <li>자바 컴파일러의 타입소거규칙
    <ul>
      <li>모든 타입 파라미터를 그들의 바운드나 Object 타입으로 교체한다.</li>
      <li>제네릭 타입을 제거한 후 타입이 일치하지 않으면 타입 캐스팅을 추가한다</li>
      <li>확장된(extended) 제네릭 타입의 다형성을 보존하기 위해 브릿지 메서드를 생성한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="왜쓰는데">왜쓰는데?</h2>
<p>특정 타입으로 종속받지 않아서 편리하다.</p>
<ul>
  <li>재사용성 증가
    <ul>
      <li>여러타입의 파라미터를 삽입할 수 있기 때문에 코드를 간결하게하고 재사용성을 높임</li>
    </ul>
  </li>
  <li>컴파일시 타입에러 발견
    <ul>
      <li>잘못된 타입이 들어오는걸 컴파일 단계에서 방지할 수 있음</li>
      <li>컴파일단계에서 타입에러를 발견할 수 있다.
        <ul>
          <li>즉, 타입시스템을 더욱 견고하게 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>컴파일러가 타입 변환 수행
    <ul>
      <li>컴파일 단계에서 형변환을 해주기때문에 <strong>코드에서 형변환 불필요</strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="타입시스템">타입시스템?</h2>
<p>개발자가 올바른 프로그램을 작성하기 위해 도우미 역할을 하고 컴파일단계에서 타입을 체크하는 대충 뭐 그런거다. 불편하기 때문에 많은 개발자들이 정적타이핑 하는 자바를 버리고 동적타이핑 하는 파이썬, 루비 같은 스크립트 언어로 갈아타는 이유이기도 하다.
<br />
대표적인 프론트엔드, 백엔드 언어인 자바스크립트와 자바는 각각 약타입언어, 강타입언어 라고도 불린다.
<br />
<br />
<strong><em>왜 이런 차이가 발생할까?</em></strong>
<br />
더 고민을 해볼 주제이긴 하지만 일단 한가지 확실한 것은 자바는 보통 서버 언어로 쓰이는 경우가 많다. 
<br />
강타입 언어인 자바를 서버 언어로 채택하는 이유는 바로 서버이기 때문이다. 
<br />
생각해보자 런타임단계가 아닌 컴파일단계에서 강하게 체크를한다? 
<br />
이건 결국 서버에서 고치기 보다 서버에 올라가기 전에 고치려고 하기 때문이다.
<br />
서버에 올라간것을 고치는 것보다 서버에 올라가기전에 고치는것이 훨씬 비용이 적게들기 때문에 최대한 빠른단계
<br />
즉, 컴파일단계에서 실수를 잡는게 좋기 때문이다.
<br />
<br />
ex) 디비에 올라간걸 고치기 힘들잖아… 그러니까 올라가기 전에 잡아야지</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="시간공간-복잡도의-상관관계">시간/공간 복잡도의 상관관계</h1>
<p><br /></p>
<ul>
  <li>시간복잡도 : 특정크기의 연산에 걸리는 절대적인 시간 즉, 연산 횟수</li>
  <li>공간복잡도 : 특정크기의 연산에 드는 메모리 사용량</li>
</ul>

<p><br />
우리가 하는 거의 모든 작업들은 시간복잡도와 공간복잡도를 서로 교환 한다.
<br />
물론 이 둘이 모든 상황에서 정 반대에 있는건 아니다.</p>

<p><br /></p>

<h2 id="caching">Caching</h2>
<ul>
  <li>시간복잡도의 리소스를 공간복잡도의 리소스로 바꾸는거다.</li>
  <li><code class="language-plaintext highlighter-rouge">redis</code>를 사용 해서 데이터를 보다 빠르게 조회할 수 있다면 그만큼 탐색범위를 줄여 시간복잡도를
<br />
줄일 수 있지만 그만큼 캐싱에 들어가는 메모리를 사용해서 공간복잡도는 올라가게 된다.</li>
</ul>

<p><br /></p>

<h2 id="hashmap">HashMap</h2>
<ul>
  <li>해시알고리즘으로 만든 key를 메모리에 올려두고 그 key값만 찾아가면 되기때문에 데이터 크기에 상관 없이 시간복잡도가 O(1)인 대신 그만큼 key값을 저장하는 메모리 공간을 사용하기 때문에 공간복잡도는 올라간다.</li>
</ul>

<p><br /></p>

<h2 id="만약-메모리가-부족하다면">만약 메모리가 부족하다면?</h2>
<p>메모리를 적게 써야하는 상황이라면 공간복잡도를 줄여서 시간을 많이쓰는
<br />
즉, 탐색을 더해서 시간복잡도를 올려야 한다.</p>

<p><br /></p>

<h2 id="의문점">의문점</h2>
<p>보통 공간복잡도 보다 시간복잡도를 더 우위에 두고 작업을 하기 마련이다.
<br />
그렇다면 그 이유는 과거에 비해 하드웨어의 발전이 많이 이루어 졌기 때문이고
<br />
웹 어플리케이션의 등장으로 request / response의 단순함으로 인해 
<br />
메모리에 올려둔 객체들의 생명주기가 짧아져 가비지컬렉터에 의해 금방금방 지워지기 때문일까?</p>

<hr />

<p>틀린 접근은 아니다. 세상이 발전함에 따라 과거보다 현재 시간복잡도가 더 중요하게 되었다.</p>
<ul>
  <li>하드웨어의 폭발적인 발전</li>
  <li>멀티코어를 통한 동시성 개발</li>
  <li>request / response 사이클로 인한 짧은 객체의 생명주기</li>
</ul>

<p>하지만 우리가 접할 기회가 흔한건 아니지만
<br />
여전히 공간복잡도의 한계가 있는 경우가 있다.</p>

<ul>
  <li>빅데이터</li>
  <li>백데이터의 크기
    <ul>
      <li>ex) 구글이 검색을 제공하기 위한 백데이터의 크기</li>
    </ul>
  </li>
  <li>머신러닝이 학습하는 학습데이터는 거대한 메모리를 사용할까? 오랜 학습시간을 들일까?</li>
</ul>

<hr />

<p>명확하지 않은 결론을 내리자면,
<br />
우리는 현재는 시간복잡도를 더 우선해서 경감하는게 더 장점이 많은 시대에 살고있고 
<br />
현업에서 어떠한 규칙으로 삼아도 될 정도이지만 몇십만명이 될지도 모르는 회원정보를 
<br />
<code class="language-plaintext highlighter-rouge">redis</code>에 올리지 않는 것처럼 경우에 따라 적절하게 사용하는것이 중요하겠다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="nested-class">Nested Class</h1>
<p>중첩클래스(nested class)는 클래스 내에 정의된 클래스를 말한다. 
<br />
중첩클래스는 <code class="language-plaintext highlighter-rouge">static</code>으로 선언되지 않은 내부클래스(inner class)와
<br />
<code class="language-plaintext highlighter-rouge">static</code>으로 선언된 정적 클래스(static class)로 나뉜다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">class</span> <span class="nc">NestedClass</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="inner-class">Inner Class</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kd">class</span> <span class="nc">InnerClass</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OuterClass.a = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>를 인스턴스화 하려면 외부 클래스를 먼저 인스턴스화 해야 한다.
    <ul>
      <li>외부클래스와 <code class="language-plaintext highlighter-rouge">innerClass</code> 두 객체의 참조값은 서로 다르다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 자신을 둘러싼 외부 클래스의 인스턴스 변수 / 메서드에 접근할 수 있다.
    <ul>
      <li>외부클래스 인스턴스에 대한 외부참조를 가지기 때문이다.
        <ul>
          <li>따라서 가비지컬렉션이 수거하지못해 <code class="language-plaintext highlighter-rouge">memory leak</code>의 위험성이 존재한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>외부클래스에선 <code class="language-plaintext highlighter-rouge">inner class</code> 멤버를 사용할수 없다. (사용하려면 객체를 직접 발생시켜야함)</li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 외부클래스의 멤버와 동일한 이름을 사용할 경우 외부클래스 멤버에 접근하고 싶으면 
<br />
명시적으로 나타내야 한다. (OuterClass.this.a)</li>
  <li>외부클래스의 <code class="language-plaintext highlighter-rouge">private</code> 멤버에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 외부 클래스의 멤버이므로 접근제한자를 사용할 수 있다.</li>
  <li>정적 멤버선언(static)이 불가능하다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">final</code>키워드를 사용하면 가능하다.</li>
      <li>자바 16 이후부터는 <code class="language-plaintext highlighter-rouge">inner class</code>에서 정적멤버 생성이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="static-inner-class">Static Inner Class</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">StaticInnerClass</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>같은 <code class="language-plaintext highlighter-rouge">static inner class</code>의 객체를 2개 만들어도 두 객체의 참조값은 서로 다르다.</li>
  <li>정적클래스는 외부 클래스를 인스턴스화 할 필요가 없기 때문에 외부클래스의 변수 / 메서드에 접근할 수 없다. 
<br />
(외부클래스의 static 멤버만 접근 가능)</li>
  <li>정적클래스 내부에서 <code class="language-plaintext highlighter-rouge">static</code> 멤버를 사용할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="local-class">Local Class</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
    	<span class="kd">class</span> <span class="nc">LocalClass</span> <span class="o">{</span> <span class="c1">// 로컬 클래스</span>
    		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
    			<span class="c1">// ...</span>
    		<span class="o">}</span>
    	<span class="o">}</span>    	
    	<span class="nc">LocalClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LocalClass</span><span class="o">();</span>
    	<span class="n">obj</span><span class="o">.</span><span class="na">doSomething</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>패키지나 클래스의 멤버가 아니므로 접근제어자 사용 불가</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> 멤버 선언 불가</li>
  <li>객체 생성은 외부에서 불가능하고, 내부에서만 가능</li>
</ul>

<p><br /></p>

<h2 id="익명-클래스">익명 클래스</h2>
<p>펑션을 상속받는? 이름이 없는 로컬클래스.
<br />
선언과 동시에 초기화가 이루어 진다.
<br />
이름이 없기 때문에 익명클래스는 객체를 여러번 생성할 수 없으며 생성자를 만들수도 없다.
<br />
클래스가 딱 한번만 필요할 때 (일회용) 유용하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Ex</span> <span class="o">{</span>
	<span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
	
	<span class="nc">Inner</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Inner</span><span class="o">()</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"overriding"</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">printX</span><span class="o">()</span> <span class="o">{</span>
			<span class="c1">//익명 클래스 안에서 메서드를 생성하여 사용 가능</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method 추가"</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>Outer Class의 지역변수가 <code class="language-plaintext highlighter-rouge">final</code> 로 선언되어야만 접근 가능</li>
  <li><code class="language-plaintext highlighter-rouge">static</code> 멤버 선언 불가</li>
  <li>멤버 인터페이스 선언 불가</li>
</ul>

<p><br /></p>

<h3 id="장점">장점</h3>
<hr />
<p>어느 메서드에서 <strong>부모 클래스의 자원을 상속받아 재정의하여 사용할 자식 클래스가 한번만 사용</strong>되고 버려질 자료형이면, 굳이 상단에 클래스를 정의하기보다는, <strong>지역 변수처럼</strong> 익명 클래스로 정의하고 스택이 끝나면 삭제되도록 하는 것이 유지보수면에서나 프로그램 메모리면에서나 이점을 얻을 수 있다.
<br />
<br />
즉, 익명 클래스는 재사용할 필요가 없는 일회성 클래스를 굳이 클래스를 정의하고 생성하는 것이 비효율적이기 때문에, 익명 클래스를 통해 <strong>코드를 줄이는 일종의 기법</strong>이라고 말 할 수 있다.
<br />
<br />
다만, 익명 클래스 방식으로 선언한다면 <strong>오버라이딩 한 메서드 사용</strong>만 가능하고,
<br />
<strong>새로 정의한 메서드는 외부에서 사용이 불가능</strong> 하다.</p>

<p><br /></p>

<h2 id="활용">활용</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 참조값을 담아야 하기 때문에 인스턴스 생성시 시간,공간적으로 성능이 낮아진다.</li>
  <li><code class="language-plaintext highlighter-rouge">static inner class</code>는 외부 인스턴스에 대한 참조가 존재하기 때문에, 
<br />
<strong><em>가비지 컬렉션이 인스턴스 수거를 하지 못하여 memory leak이 생길 수 있다.</em></strong></li>
  <li><code class="language-plaintext highlighter-rouge">static inner class</code>를 사용하는 것이 좋으며 <code class="language-plaintext highlighter-rouge">static</code> 키워드를 사용하고싶지 않으면 별개의 클래스로 만드는 것이 좋다.</li>
  <li>하지만 <strong><em>Lambda</em></strong> 의 경우 얘기가 조금 달라지는데…</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="람다">람다</h1>
<p>익명 함수 (Anonymous functions) 를 지칭하는 용어이다.
<br />
익명함수란 함수의 이름이 없는 함수이고 익명함수들은 공통적으로 일급객체 이다.</p>

<ul>
  <li><strong>일급객체</strong> : 다른 객체들에 적용 가능한 연산을 모두 지원가는 객체.
<br />
함수를 값으로도 사용할 수 있고 파라미터로 전달 및 변수에 대입도 가능하다.</li>
</ul>

<p><br />
<strong>Stream</strong> 연산들은 매개변수로 함수형 인터페이스를 받도록 되어있다.
<br />
그리고 람다식은 반환값으로 함수형 인터페이스를 반환하고 있다.
<br />
즉, 람다식이란 <strong>함수를 하나의 식</strong>으로 표현한 것이다.
<br />
함수를 람다식으로 표현하면 메서드의 이름이 필요 없기 때문에, 람다식은 익명 함수의 한 종류라고 볼 수 있다.</p>

<p><br /></p>

<h2 id="특징-1">특징</h2>
<ul>
  <li>람다식 내에서 사용되는 지역변수는 <code class="language-plaintext highlighter-rouge">final</code> 키워드가 붙지않아도 상수로 간주된다.
    <ul>
      <li>람다의 병렬처리가 <code class="language-plaintext highlighter-rouge">Thread safety</code> 한 이유이다.</li>
    </ul>
  </li>
  <li>람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.</li>
</ul>

<p><br /></p>

<h2 id="장점-1">장점</h2>
<ul>
  <li>지연연산수행 : 지연연산을 수행함으로써 불필요한 연산을 최소화 할 수 있다.
    <ul>
      <li><strong>지연연산</strong>이라는 단어 뜻이 헷갈리는데, 
  <br />
  메서드를 호출하여 사용하려면 클래스를 만들고 클래스를 인스턴스화 하여 해당 메서드에 접근해야 하는데 이 과정을 수행하기 위해선 클래스가 반드시 초기화 되어야 된다는 의미이다.
  <br />
  여기서 <strong><em>람다식</em></strong> 을 사용하면 이런 과정 없이 필요한 순간에 <strong>1회용으로 익명함수</strong>를 정의하고 바로 호출하면 되므로 클래스의 초기화가 필요 없다는 의미이다.</li>
    </ul>
  </li>
  <li>코드의 간결성 : 불필요한 반복문의 삭제가 가능하며 단순하게 표현할 수 있다.</li>
  <li>함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아진다.</li>
  <li>메서드를 변수처럼 다루는 것이 가능해진다.</li>
  <li><strong><em>병렬처리 : 멀티스레드를 활용한 병렬처리에 안전하다.</em></strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Stream</code>은 람다식을 사용해 별도의 스레드에서 병렬 처리를 관리한다.</li>
      <li>람다의 외부 참조변수가 항상 <code class="language-plaintext highlighter-rouge">final</code>이어야만 하는 이유이다.</li>
      <li>즉, <strong>동시성 문제</strong>에 자유롭다.</li>
      <li>어플리케이션의 크기가 거대해 짐에 따라 멀티스레드 환경에서 데이터의 무결성을 보장하는, 
  <br />
  자바에서 함수형 프로그래밍인 <strong>람다</strong> 를 도입한 이유중 가장 큰 이유 중 하나 라고 생각한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="단점">단점</h2>
<ul>
  <li>람다를 사용하면서 만든 익명함수는 재사용이 불가능하다.</li>
  <li>디버깅이 어렵다.</li>
  <li>남발할 시 오히려 가독성이 떨어진다.</li>
  <li>람다의 <code class="language-plaintext highlighter-rouge">Stream</code>은 전통적인 for문에 비해 성능이 떨어진다.
    <ul>
      <li>하지만 람다를 사용하는 이유는 이제는 성능상의 이점보다 <strong>데이터 무결성</strong> 이 더 중요해진 건 아닐까?</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="stream">Stream</h2>
<p>다양한 데이터를 표준화된 방법으로 다루기 위한 라이브러리 - <strong>Java8</strong>에 추가
<br />
<code class="language-plaintext highlighter-rouge">Stream</code>의 문법에 대해서는 이 글에서 다루지 않는다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Stream</code>의 특징
    <ul>
      <li>데이터를 변경하지 않는다.</li>
      <li>1회용 이다.</li>
      <li>지연 연산을 수행한다.</li>
      <li>병렬 실행이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="의문점-1">의문점</h2>

<ul>
  <li><strong><em>람다는 일종의 <code class="language-plaintext highlighter-rouge">inner class</code> 인데 가비지컬렉터의 메모리 누수에는 안전하다 알아보자.</em></strong>
<br />
<br />
자바에서 모든 메서드는 반드시 클래스 안에 소속되어 있어야 한다. 메서드를 만들기 위해서는 클래스를 만들어줘야 하고 클래스를 만들려면 생성자를 비롯한 멤버들도 구성해야 한다. 
<br />
그리고 이 메서드를 사용하려면 별도로 <code class="language-plaintext highlighter-rouge">instance</code>를 생성해서 이 <code class="language-plaintext highlighter-rouge">instance</code>를 통해 메서드를 호출해야 한다.
<br />
하지만 람다로 일회용 메서드를 활용한다면 이 과정이 필요 없다.
<br />
즉, 인스턴스화를 시키지 않기 때문에 람다는 외부클래스 인스턴스에 대한 외부참조가 없고
<br />
따라서 가비지컬렉터가 수거하지 못하는 상황이 일어나지 않아 <code class="language-plaintext highlighter-rouge">memory leak</code>에 안전한 것이다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="collection">Collection</h1>
<hr />

<p><br />
<br />
<br />
<br /></p>

<h1 id="중복에-관한-의문점">중복에 관한 의문점</h1>
<hr />
<p>객체지향의 장점인 재사용성(상속, 다형성 등) 을 보면 중복은 좋지 않다?
<br />
유지보수 관점에서 중복을 하는것이 좋을지, 중복을 제거하는것이 좋을지 고려해야 한다.
<br />
멀티모듈의 최상위 모듈을 하나두고 설계하는 패턴의 장,단점과 관련이 있다고 한다.</p>

<p><br /></p>

<h2 id="중복이-나쁜경우">중복이 나쁜경우</h2>
<p>중복은 중복을 부르고, 논리의 조그마한 실수도 큰 오류가 날 가능성이 높아진다.
<br />
또한 어플리케이션이 복잡해 질수록 생산성은 떨어진다.
<br />
대부분의 경우 중복은 좋지 않다.</p>

<p><br /></p>

<h2 id="중복이-차라리-나은경우">중복이 차라리 나은경우</h2>
<p>자원의 효율적인 사용이나 중복으로 인한 문제 발생보다 시스템의 안정성을 위주로 할 경우
<br />
코드의 중복 보다는 인스턴스들의 중복이 포인트이다.
<br />
예를들면, 인스턴스를 여러개 둘 수 있지만, 그 인스턴스를 만드는 코드는 하나만 존재해야 한다.
<br />
이렇지 않을 경우 언제나 동기화를 시켜주는 문제가 발생할 수도 있다.
<br />
또한 중복코드가 서로 의존을 해서 순환참조가 발생할 때?
<br /></p>

<h2 id="멀티모듈의-설계">멀티모듈의 설계?</h2>
<p>모듈은 패키지의 한단계 위의 집합체이며, 관련된 패키지와 리소스들을 재사용할 수 있는 그룹이라고 정의한다.</p>

<p><br /></p>

<h3 id="msa프로젝트를-구성할-때-문제점">MSA프로젝트를 구성할 때 문제점</h3>
<hr />
<p>인증 서버, API서버, 배치서버 등을 각각 나누다 보니 기존 모놀리식에선 신경쓰지 못했던 문제중 하나가 중복코드의 문제이다.
<br />
<code class="language-plaintext highlighter-rouge">ResponseEntity</code>, <code class="language-plaintext highlighter-rouge">ExceptionHandler</code> 등의 모든 서버에서 쓰이는 로직은 서버 전부에서 코드를 가지고 있어야 했고, 변경되면 모두 다 바꿔줘야하는 비효율적인 문제가 발생한다. 
<br />
IDE를 몇개씩 띄워놓고 서버를 돌리는것도 힘들기 때문에 멀티프로젝트로 구성되 있던 서비스를 멀티모듈로 전환하는 경우도 많이 있다.</p>

<p><br /></p>

<h3 id="멀티모듈">멀티모듈</h3>
<hr />
<p>공통적인 기능을 모아 하나의 모듈(common)로 만들고 각 모듈에서 의존한다.
<br />
<strong>common 모듈에 공통로직을 몰아넣는다?</strong>
<br />
<strong>아니다.</strong> 어느 정도의 중복을 기준으로 common module 에 넣을 것이고, 어디까지의 역할만 시킬 것인지를 확실하게 나눠야 한다. 그렇지 않으면 common이 점 차 커지며 common안에 비즈니스가 흐르기 시작하고,
<br />
이것이 어쩔수 없이 반복되고 결국 다른 애플리케이션은 날씬하고 common만 굉장이 큰 프로젝트가 되버리는 지옥이 발생한다.</p>

<p><br /></p>

<h3 id="멀티모듈의-장점">멀티모듈의 장점</h3>
<hr />
<ul>
  <li>코드의 중복을 줄일 수 있다.
  공통된 로직이 있는 여러 서비스를 운영할 때, 공통부분을 모듈화 하고 이 의존성을 추가하여 공유할 수 있다.</li>
  <li>각 모듈의 기능을 파악하기 쉽다.
  공통의 기능은 의존송 주입으로, 모둘별로 기능을 분리하여 코드이해에 도움이 된다.</li>
  <li>독립된 jar 로 단독 실행 가능
    <ul>
      <li>빌드도 쉬워진다.</li>
    </ul>
  </li>
  <li>독립된 모듈(library)로서 여기저기서 가져다 쓸 수 있는 확장성</li>
  <li>모듈별로 사용하는 의존성 (버전포함)을 다르게 관리할 수 있음</li>
</ul>

<p><br /></p>

<h3 id="주의할점">주의할점</h3>
<hr />
<ul>
  <li>공통 모듈이 가져야 하는 의존성을 고려해야 한다.</li>
  <li>특정 모듈에선 불필요한 의존성으로 인해 어플리케이션이 무거워 질 수 있다.
    <ul>
      <li>모든 모든 모듈에서 전역적으로 적용되어야 할 때 common모듈에 넣자</li>
    </ul>
  </li>
  <li>각 어플리케이션(모듈)에 대한 설정은 공통 모듈에 적용하지 않고 분리한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Generic" /><category term="시공간복잡도" /><category term="Nested Class" /><category term="Multi Module" /><category term="Lambda" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">3 Week</title><link href="http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="3 Week" /><published>2022-12-29T00:00:00+09:00</published><updated>2022-12-29T00:00:00+09:00</updated><id>http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="property">Property</h1>
<p>속성이란 뜻이다. 해당 <code class="language-plaintext highlighter-rouge">Object</code>의 특징.
<br />
사람을 예로들면 피부색, 키, 나이, 몸무게 등이다.
<br />
Property의 읽기와 쓰기는 일반적으로 <code class="language-plaintext highlighter-rouge">getter</code> 와 <code class="language-plaintext highlighter-rouge">setter</code> 메서드 호출로 변환된다.</p>
<ul>
  <li>자바는 property가 없고 코틀린이나 자바스크립트는 property를 사용 이건 왜그래?</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="string">String</h1>
<p>자바에서 제일 많이 사용되는 String은 <strong>특별대우</strong>를 받는다.
<br />
Reference Type 이지만 기본적인 사용은 Primitive Type 이다.
<br />
String 객체생성은 2가지 방법이 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"kim"</span><span class="o">;</span>			<span class="c1">// 리터럴로 생성</span>
<span class="nc">String</span> <span class="n">name2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"lee"</span><span class="o">);</span>	<span class="c1">// new 연산자로 생성</span>
</code></pre></div></div>
<ul>
  <li><strong>new</strong> : 일반 객체들처럼 힙 영역에 할당된다.</li>
  <li><strong>리터럴</strong> : <code class="language-plaintext highlighter-rouge">Constant Pool</code> 영역에 할당된다.
    <ul>
      <li>String의 intern()메서드를 호출한다.
        <ul>
          <li>intern() 메서드 : <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 생성하려는 문자열이 존재할 경우 주소값을 반환하고 
  <br />
  없으면 객체 생성 후 주소값을 반환한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="constant-pool">Constant Pool</h2>
<p>문자열 리터럴을 사용해서 생성한 String 객체가 담기는 곳이며 자바8 이후 힙 영역에 속한다.
<br />
같은 문자열을 각각 2개씩 리터럴과 new연산자로 생성했을 때, new 연산자로 생성된 문자열은 서로 다른객체를 만들고 바라보지만 리터럴로 생성해 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 담긴 두 객체는 동일한 객체를 바라본다.</p>

<p><br /></p>

<h2 id="string은-불변immutable하고-thread-safe-하다">String은 불변(immutable)하고 thread-safe 하다.</h2>
<p>문자열 리터럴은 불변이기 때문에 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에서 문자열이 같다면 동일한 객체를 참조할 수 있다.</p>
<ul>
  <li><strong><em>static String?</em></strong>
<br />
  두개의 클래스의 각각 <code class="language-plaintext highlighter-rouge">static String abc = "abc";</code> 를 선언하고
  해시코드 값을 출력해보면 동일하다.
  <br />
  즉, <code class="language-plaintext highlighter-rouge">static</code> 으로 선언해도 동일성과 동등성이 보장된다.</li>
</ul>

<p><br /></p>

<h2 id="string-연산">String 연산</h2>
<p><code class="language-plaintext highlighter-rouge">Constant Pool</code>의 특성 때문에 연산을 하게되서 문자열이 변경될 경우 기존 객체는 불변이기 때문에 새로운 객체를 만들고 해당 객체를 참조한다. 그리고 곧 참조가 사라진 기존 문자열은 가비지컬렉터의 수집 대상이 된다.
<br />
그렇기 때문에 문자열의 <code class="language-plaintext highlighter-rouge">+ 연산</code> 또는 <code class="language-plaintext highlighter-rouge">concat 연산</code> 은 좋지 않다.
<br />
아래 두 클래스는 내부 Buffer에 문자열을 저장해두고 그 안에서 추가,수정,삭제 등을 작업할 수 있다.</p>

<ul>
  <li><strong>StringBuffer</strong>
    <ul>
      <li>StringBuilder 보다 성능이 좋지 않다.</li>
      <li>동기화를 지원하여 thread-safe 하다.</li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuilder</strong>
    <ul>
      <li>StringBuffer 보다 성능이 좋다</li>
      <li>동기화를 지원하지 않아 thread-safe 하지 않다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="활용">활용</h3>
<hr />
<p>새로운 객체를 만들지 않고 문자열을 수정할 수 있기 때문에 참조가 끊어진 String 객체가
<br />
가비지컬렉션에 의해 메모리 해제를 기다리지 않아도 된다.
<br />
하지만 buffer의 크기를 초기에 설정해줘야 해서 생성속도가 String 객체보다 느리고 read가 느리다.
<br />
문자열 수정을 할 경우에도 Buffer의 크기를 줄이고 늘리고 명칭을 변경하는 등의 연산이 필요하다.</p>

<ul>
  <li><strong>String</strong>
    <ul>
      <li>문자열의 연산이 적을 경우</li>
      <li>빠른 조회 성능을 기대해야 할때</li>
      <li>문자열 연산이 적고 멀티스레드 환경일 경우</li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuffer</strong>
    <ul>
      <li>문자열 연산이 많을 경우</li>
      <li>thread-safe 이 필요한 경우
        <ul>
          <li>멀티스레드 환경</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuilder</strong>
    <ul>
      <li>문자열 연산이 많을 경우</li>
      <li>thread-safe 이 필요하지 않은 경우
        <ul>
          <li>단일스레드 환경</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="jdk-15-이후">JDK 1.5 이후</h3>
<hr />
<p>자바 1.5 이후  String의 <code class="language-plaintext highlighter-rouge">immutable</code>속성의 문제점을 해결하기 위해 도입되었다.
<br />
그래서 자바 1.5 이후 <code class="language-plaintext highlighter-rouge">한줄 +</code> 연산시 자동으로 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 로 자동변환되어 성능 최적화를 이뤘다.
<br />
하지만 <code class="language-plaintext highlighter-rouge">여러줄 +</code> 연산할 경우 매 연산마다 새로운 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 객체를 선언한다.
<br />
또한 for문 같은 반복문같은 경우에도 컴파일러가 최적화를 해주지 못하고 있다.
<br />
추가로 <code class="language-plaintext highlighter-rouge">concat</code> 연산은 컴파일러가 아예 최적화를 해주지 못한다.
<br />
그냥 문자열 연산에는 <code class="language-plaintext highlighter-rouge">StringBuffer / StringBuilder</code> 를 쓰도록 하자.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="annotation">Annotation</h1>
<p><code class="language-plaintext highlighter-rouge">Annotation</code> 의 사전적인 의미로는 주석이다.
<br />
자바에서는 코드사이에 주석처럼 쓰여서 특별한 의미, 기능을 수행하도록 한다.
<br />
프로그램에게 추가정보를 제공해주는 메타데이터라고 볼 수 있다.
<br />
이 클래스에게 어떤 역할을 줄까? 이 속성을 어떤용도로 사용할까?</p>

<ul>
  <li>메타데이터 : 데이터를 위한 데이터</li>
</ul>

<p><br /></p>

<h2 id="용도">용도</h2>
<ul>
  <li>컴파일러에게 에러를 체크하도록 정보 제공</li>
  <li>빌드나 패치 시 코드를 자동으로 생성할 수 있도록 정보 제공</li>
  <li>런타임단계에서 특정 기능을 실행하도록 정보 제공</li>
</ul>

<p><br /></p>

<h2 id="설정">설정</h2>
<ul>
  <li><strong>@Target</strong> : 적용대상
    <ul>
      <li>어디(클래스, 필드, 메서드…)에 <code class="language-plaintext highlighter-rouge">Annotation</code> 을 적용할지</li>
    </ul>
  </li>
  <li><strong>@Retention</strong> : 정보유지되는 대상
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Annotation</code> 값들을 언제까지 유지할 것인지 (대부분 Runtime)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="왜쓰는데">왜쓰는데?</h2>
<p><code class="language-plaintext highlighter-rouge">Annotation</code> 을 붙일 타겟과 유지시기 등을 설정해 자신이 원하는 용도로 활용이 가능하다.
<br />
이것은 비즈니스 로직과는 별도로 시스템 설정과 관련된 부가적인 사항들을 <code class="language-plaintext highlighter-rouge">Annotation</code>
<br />
에게 위임하고 개발자는 비즈니스 로직 구현에만 집중할 수 있도록 하는 일종의 <code class="language-plaintext highlighter-rouge">AOP</code>
<br />
즉, <code class="language-plaintext highlighter-rouge">Annotation</code> 을 사용함으로써 관심사의 분리를 가능하게 한다는 의미기도 하다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="exception">Exception</h1>
<p>예외는 기본적으로 폭탄돌리기와 같다.
<br />
처리하거나 처리 <code class="language-plaintext highlighter-rouge">try catch</code> 할 수 없다면 <code class="language-plaintext highlighter-rouge">throw</code> 즉, 던져야 한다.
<br />
예외를 처리하지 못하고 계속 던지게 되면 결국 메인메서드까지 던져지게 되고 결국 어플리케이션이 종료된다.</p>

<p><img src="/images/2021-05-10-first-posting/exception%EA%B3%84%EC%B8%B5.png" alt="이미지" /></p>

<ul>
  <li>
    <p>Throwable : 최상위 예외 이며, 객체이기 때문에 <code class="language-plaintext highlighter-rouge">Object</code>를 상속받는다.</p>
  </li>
  <li>
    <p>Error : 메모리부족, 시스템 오류같은 어플리케이션 레벨에서 복구가 불가능한 시스템 장애이다.
<br />
<code class="language-plaintext highlighter-rouge">Exception</code>과 <code class="language-plaintext highlighter-rouge">Error</code>는 다르다</p>
  </li>
  <li>
    <p><strong><em>상위 예외를 잡으면 하위 예외까지</em></strong> 잡아버리기 때문에 어플리케이션에선 <code class="language-plaintext highlighter-rouge">Exception</code> 예외부터 필요한 예외로 잡아야 한다.
<br />
또한, <code class="language-plaintext highlighter-rouge">Layer</code>에 역할에 맞는 <code class="language-plaintext highlighter-rouge">Exception</code>을 던질 필요가 있다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="checked-exception"><strong><em>Checked Exception</em></strong></h2>
<p><code class="language-plaintext highlighter-rouge">Exception</code>을 상속받는 예외는 <code class="language-plaintext highlighter-rouge">checked exception</code>이 되며 <code class="language-plaintext highlighter-rouge">Exception</code>은 어플리케이션에서 사용할 수 있는 실질적인 최상위 예외이다. 컴파일러가 체크하며 잡아서 처리하거나, 또는 밖으로 던지도록 선언해야 한다.
<br />
예외 발생 시 트랜잭션 <code class="language-plaintext highlighter-rouge">roll-back</code> 처리를 하지 않는다. 
<br />
(복구가 가능하다는 매커니즘을 가지고 있기 때문에 복구를 하라고 하고 롤백은 처리하지 않겠다 아닐까?)
<br />
<strong><em>단, RuntimeException을 상속받는 경우 unchecked exception이 된다.</em></strong></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>예외를 처리하거나 밖으로 던지는 <code class="language-plaintext highlighter-rouge">throw</code> 를 필수로 선언해야 컴파일 오류가 발생하지 않기 때문에 
  <br />
  개발자가 실수로 누락하는 상황이 발생하지 않는다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>모든 체크예외를 반드시 잡거나 던지도록 처리해야 한다.</li>
      <li>의존관계 문제가 발생한다.
        <ul>
          <li>예를들어 <code class="language-plaintext highlighter-rouge">Controller / Service</code> 등에서 SQL예외를 던졌을때 해당 클래스에서 <code class="language-plaintext highlighter-rouge">SQLException</code>을 의존하게 된다. 이럴경우 JDBC가 아닌 JPA같은 기술로 변경할 시 모든 코드를 고쳐야한다. 
  <br />
  즉, <code class="language-plaintext highlighter-rouge">OCP / DI</code>를 위반한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><em>활용</em></strong>
<br />
  기본적으로 <code class="language-plaintext highlighter-rouge">unecked exception</code>을 사용하자. <code class="language-plaintext highlighter-rouge">checked exception</code>은 비즈니스 로직상 반드시 처리해야 하는 경우에만 (계좌 이체 실패, 결제시 포인트 부족 등)
  <br />
  즉, 개발자가 실수로 놓치게 되면 치명적인 문제가 발생하는 경우에 컴파일러의 도움을 받기위해 사용하자.
  <br />
  또한, <code class="language-plaintext highlighter-rouge">catch</code> 절에서 딱히 할일이 없을 경우 사용하지 말고 확실히 할일이 있는 경우에 사용하자</p>
  </li>
  <li>대표적인 <code class="language-plaintext highlighter-rouge">Exception</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IOException</code></li>
      <li><code class="language-plaintext highlighter-rouge">SQLException</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="unchecked-exception"><strong><em>UnChecked Exception</em></strong></h2>
<p><code class="language-plaintext highlighter-rouge">RuntimeException</code>과 그걸 상속받는 예외들은 <code class="language-plaintext highlighter-rouge">unchecked exception</code>이다.
<br />
컴파일러가 체크하지 않는 예외이며 <code class="language-plaintext highlighter-rouge">throw</code>를 생략할 수 있고 이럴 경우 자동으로 예외를 던진다.
<br />
즉, 예외를 잡아서 처리하지 않아도 <code class="language-plaintext highlighter-rouge">throw</code>를 생략할 수 있다.
<br />
예외 발생 시 트랜잭션 <code class="language-plaintext highlighter-rouge">roll-back</code> 처리를 한다.</p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">throw</code> 생략으로 예외를 무시할 수 있다.</li>
      <li>시스템에서 발생하는 복구가 불가능한 예외에 대해 신경쓰지 않아도 된다.</li>
      <li>신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>컴파일 단계에서 체크가 안되기 때문에 실수할 가능성이 있다.</li>
    </ul>
  </li>
  <li>대표적인 <code class="language-plaintext highlighter-rouge">Exception</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NullPointerException</code></li>
      <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="예외-던져도-안죽던데">예외 던져도 안죽던데?</h2>
<p>웹 어플리케이션은 <code class="language-plaintext highlighter-rouge">servlet</code>의 오류 페이지나, 또는 <code class="language-plaintext highlighter-rouge">Spring MVC</code>가 제공하는 <code class="language-plaintext highlighter-rouge">ControllerAdvice</code> 에서 이런 예외를 공통으로 처리해 주기 때문에 예외가 메인메서드까지 가지 않는다.</p>
<ul>
  <li>하지만 이런 문제들은 클라이언트 입장에선 어떤 문제가 발생했는지 자세히 알기 어렵다.</li>
  <li><code class="language-plaintext highlighter-rouge">API</code>라면 HTTP 상태코드 <code class="language-plaintext highlighter-rouge">500</code>으로 응답을 내려준다.</li>
  <li>수정하기 전까진 해결되지 않으므로 별도의 오류 로그를 남기고 메일, 알림등을 통해 
<br />
개발자가 빨리 인지할 수 있도록 처리해두는게 좋다.</li>
</ul>

<p><br /></p>

<h2 id="자바의-checked-exception-도입">자바의 Checked Exception 도입?</h2>
<p>자바의 <code class="language-plaintext highlighter-rouge">Checked Exception</code>은 자바만의 독특한 특징이다.
<br />
<strong><em>“강제성이 없기 때문에 실수할 여지가 있다”</em></strong> 를 해결하기위해 도입했지만
컴파일단계에서 예외를 처리하라고 
<br />
강요하는 <code class="language-plaintext highlighter-rouge">Checked Exception</code> 은 자바 이후 설계된 <code class="language-plaintext highlighter-rouge">C#</code> 이나 <code class="language-plaintext highlighter-rouge">ruby</code>등에서도 채택되지 않았다.
<br />
요즘은 극단적으로 자바의 <code class="language-plaintext highlighter-rouge">Checked Exception</code> 도입은 실패라는 주장도 심심치 않게 보인다.
<br />
<code class="language-plaintext highlighter-rouge">JDBC API</code>에서는 <code class="language-plaintext highlighter-rouge">Checked Exception</code>을 남발하고 <code class="language-plaintext highlighter-rouge">catch</code>절에서 아무것도 하지 않았고 
<br />
이런 문제점을 알고 그후에 <code class="language-plaintext highlighter-rouge">JDBC</code>를 활용한 <code class="language-plaintext highlighter-rouge">Spring-JdbcTemplet</code>, <code class="language-plaintext highlighter-rouge">Hibernate</code>, <code class="language-plaintext highlighter-rouge">JPA</code> 등에서는 
<br />
<code class="language-plaintext highlighter-rouge">Checked Exception</code>인 <code class="language-plaintext highlighter-rouge">SQLException</code>을 볼수 없게 설계되었고 이런 사례들을 보면 자바의 
<br />
<code class="language-plaintext highlighter-rouge">Checked Exception</code>은 도입은 논란의 여지가 있는듯 하다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="의문점">의문점</h1>
<p>가비지컬렉터는 알아서 메모리를 관리해 주는데, 결국 한계점에선 Major GC를 실행할 수 밖에 없고
<br />
이것이 실행되는 동안에는 결국 <code class="language-plaintext highlighter-rouge">stop the world</code> 즉, JVM이 멈추게 되는 현상이 발생하는데 그렇기 때문에
<br />
과거에는 GC를 튜닝해서(도메인에 따라 메모리 관리가 틀리기 때문에) 이런 현상이 최대한 적게 일어나게
<br />
하는것이 한동안 이슈였다.<br />
<br />
그렇다면 하나의 큰 JVM 말고 여러개의 소규모 컨테이너로 JVM을 실행하면? 마치 로드밸런싱과도 비슷한데..
<br />
이렇게 하면 하나의 JVM에서 Major GC가 발생해도 어플리케이션 전체가 <code class="language-plaintext highlighter-rouge">stop the world</code>에 빠지진 않는데?
<br />
하지만 이 방법은 JVM이 나뉘어 짐에 따라 스택프레임을 공유할 수 없다는 단점이 있는데
<br />
<br />
요즘은 웬만한 프로그램도 웹어플리케이션으로 패러다임이 움직임에 따라 프로그램은 
<br />
request -&gt; response 이후 스레드가 종료되는 단순한 형태로 바뀌기 시작했고
<br />
그 결과 스택프레임을 공유하는 빈도 수 가 줄면서 GC튜닝 이슈는 좀 사그라 들었다.
<br />
하지만 완벽한 해결법은 아니고 자바 11 이후 GC의 방식이 조금 바뀌었다. 하지만 이것도 장단점..</p>

<p><br /></p>

<h2 id="자바-11-이후-바뀐-가비지컬렉션에-대해-자세히-알아보자">자바 11 이후 바뀐 가비지컬렉션에 대해 자세히 알아보자</h2>
<ul>
  <li>
    <p><strong><em>Generational GC</em></strong>
<br />
JDK 7부터 본격적으로 사용할 수 있는 G1 GC를 제외한, Oracle JVM에서 제공하는 모든 GC</p>
  </li>
  <li>
    <p><strong><em>The Serial GC</em></strong>
<br />
가장 단순한 GC이지만 사용하지 않는 것을 추천한다. 싱글 쓰레드 환경을 위해 설계 되었고 아주 작은 Heap영역을 가진다. 
<br />
Full GC가 일어나는 동안 애플리케이션 전체가 대기해야하는 현상이 발생하기 때문에 서버 애플리케이션에 적당하지 않다.</p>
  </li>
  <li>
    <p><strong><em>Parallel GC</em></strong>
<br />
Java 8의 디폴트 GC이고 병렬로 GC한다. 
<br />
메모리가 충분하고 CPU의 성능과 코어 개수가 많아 순간적으로 트래픽이 몰려도 일시 중단을 견딜 수 있고 GC에 의해 야기된 CPU 오버 헤드에 대해 최적화할 수 있는 애플리케이션에 가장 적합하다.</p>
  </li>
  <li>
    <p><strong><em>G1(Garbage First) GC</em></strong>
<br />
<strong>대용량 메모리가 있는 다중 프로세서 시스템을 대상</strong>으로 하는 서버-스타일 가비지 컬렉터이다.
<br />
GC GC는 Generational 한 알고리즘과는 다르게 백그라운드의 멀티 쓰레드를 활용해 1MB에서 32MB까지의 수 많은 리젼으로 Heap을 분할한다.
<br />
G1 GC는 위와 같이 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면
<br />
다른 영역에서 객체를 할당하고 GC를 실행한다. 
<br />
즉, 지금까지 설명한 Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식이라고 이해하면 된다.
<br />
<br />
G1 GC의 가장 큰 장점은 성능이다. 
<br />
G1은 지연 시간을 줄이기 위해서 지금까지 설명한 어떤 GC 방식보다도 빠르다.
<br />
하지만 이와 같이 4GB 이상의 큰 Heap을 가지는 것은 요즘과 같이 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 
<br />
지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다.
<br />
이러한 Garbage Collector에 대한 변화는 Parallel GC와 같이 처리량을 극대화하는 것보다 GC의 지연 시간을 제한하는 것이 더 중요하다는 가정 하에 이루어졌다</p>
  </li>
</ul>

<p><br /></p>

<h2 id="튜닝">튜닝?</h2>
<p>JVM을 튜닝한다는 의미는 기존 GC 에서 Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 노력이다.
<br />
Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생하거나 
<br />
Full GC 횟수가 늘어난다. 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. 
<br />
Old 영역의 크기를 적절하게 <strong>잘</strong> 설정해야 한다.
<br />
G1 GC를 제외한 GC에서는 JVM Heap을 무한정 늘리면 Full GC 시간 증가로 인해 오히려 성능 병목이 될 수 있다.
<br />
JVM의 Heap을 증가시키기 보다는 JVM의 인스턴스를 늘려 클러스터링이나 로드밸런서로 가용성을 확보하는 방법을 권장한다.
<br />
<br />
<br />
멀티코어상황에서 유용하다는데? 알아보자</p>

<p><br /></p>

<h2 id="스택프레임에-대해-알고있는-것보다-더-자세히-알아보자">스택프레임에 대해 알고있는 것보다 더 자세히 알아보자</h2>

<p><br /></p>

<h2 id="하나의-jvm으로-띄우는-것과-여러개의-컨테이너로-띄우는-것의-장단점에-대해-자세히-알아보자">하나의 JVM으로 띄우는 것과 여러개의 컨테이너로 띄우는 것의 장단점에 대해 자세히 알아보자</h2>
<p>노드js에선 쓰고있는거 같던데?</p>

<p><br /></p>

<h2 id="멀티코어에서의-jvm과-멀티스레드">멀티코어에서의 JVM과 멀티스레드</h2>
<p>과거에는 싱글코어의 성능을 극한으로 올렸다. 하지만 전력소모, 코어의 면적을 넓히는 방식으로의 해결등이 한계에 다다르면서 코어 수를 늘려서 CPU 전체의 성능을 향상하는 쪽으로 발전했다.</p>

<ul>
  <li>멀티코어 : 2개 이상의 독립코어를 단일 직접회로로 이루어진 하나의 CPU로 통합한 것</li>
  <li>프로세서 : 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛 즉, 중앙처리장치 혹은 CPU
    <ul>
      <li>소프트웨어적으로는 데이터포맷을 변환하는 역할을 수행하는 프로세싱 시스템
        <ul>
          <li>워드프로세서, 컴파일러, 어셈블러 등</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프로세스 : 메모리에 적재되어 프로세서에 의해 실행중이거나 대기중인 프로그램</li>
</ul>

<p><br /></p>

<ul>
  <li>멀티스레드
    <ul>
      <li>프로세스를 생성하여 자원을 할당하는 운영체제의 시스템콜이 줄어든다.</li>
      <li>프로세스간 통신보다 스레드간의 통신의 비용이 적다.</li>
      <li>힙영역을 공유하므로 동기화 문제에 안전하지 않다.</li>
      <li>하나의 스레드에 문제가 생기면 전체 프로세스 전체가 영향을 받는다.</li>
    </ul>
  </li>
  <li>멀티프로세스
    <ul>
      <li>하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않는다.</li>
    </ul>
  </li>
</ul>

<p>JVM은 하나의 프로세스에서 동작한다.
<br />
하나의 프로세스는 여러 작업단위를 가질 수 있는데 이것이 스레드 이다.
<br />
해당 JVM에서 스레드를 생성해 사용할 때는 OS의 스레드를 사용하는데 이 OS의 스레드는 다른 코어에 있고, 
<br />
결국 하나의 JVM에서 멀티코어를 사용할 수 있는것이다.
<br />
<br />
<br />
근데 이말은 무슨말인지 자세히 알아보자</p>
<ul>
  <li>프로세스는 독자적인 메모리를 할당받아서 서로 다른 프로세스끼리는 일반적으로 서로의 메모리 영역을 침범하지 못한다?</li>
</ul>

<p><br /></p>

<h2 id="로드밸런싱에-대해서-자세히-알아보자">로드밸런싱에 대해서 자세히 알아보자</h2>

<p><br /></p>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="String" /><category term="Annotation" /><category term="Exception" /><category term="Property" /><category term="JVM" /><category term="GC" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">자료구조</title><link href="http://localhost:4000/data_structure/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="자료구조" /><published>2022-12-24T00:00:00+09:00</published><updated>2022-12-24T00:00:00+09:00</updated><id>http://localhost:4000/data_structure/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="http://localhost:4000/data_structure/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="시간복잡도">시간복잡도</h1>
<p>알고리즘 효율성을 판단하는 지표로써,
<br />
알고리즘 수행에 걸리는 시간이 아닌
<br />
<strong><em>연산들이 몇번 이루어지는가</em></strong> 에 대한 지표이다.
<br />
메모리 사용량을 분석한 결과는 <strong><em>공간복잡도</em></strong> 이다.</p>

<ul>
  <li><strong><em>Big-O 표기법</em></strong>
    <ul>
      <li>빠른 순서</li>
      <li><strong><em>O(1)</em></strong> : 데이터의 크기에 상관없이 언제나 일정한 시간이 걸림 (<code class="language-plaintext highlighter-rouge">index</code>를 통한 접근)</li>
      <li>O(log₂ n) : 데이터가 커질수록 시간이 로그만큼 짧아짐 (이진탐색 / Tree)</li>
      <li><strong><em>O(n)</em></strong> : 데이터의 크기에 비례해 처리시간이 증가함 (선형탐색 / for문)</li>
      <li>O(n log₂ n) : 데이터가 커질수록 시간이 로그 배 만큼 늘어남 (퀵/병합/힙 정렬)</li>
      <li>O(n²): 데이터의 크기가 커질수록 처리시간이 기하급수적으로 늘어남 (이중for문 / 삽입/버블/선택 정렬)</li>
      <li>O(2ⁿ) : 데이터의 크기가 커질수록 처리시간이 기하급수적으로 늘어남 (피보나치 수열)</li>
    </ul>
  </li>
</ul>

<p><img src="/images/big-o/big-o.png" alt="이미지" /></p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="hash">Hash</h1>
<p>임의의 크기를 가진 데이터를 고정된 크기의 데이터로 바꾸는 것.
<br />
단방향 암호화 기법으로 해시함수 또는 해시 알고리즘를 이용해 고정된 길이의 비트열로 변경한다.
<br />
10 X 10 = 100 이라는 것은 쉽게 알지만, 몇과 몇을 곱해야 100이 나오는지는 많은 경우의 수가 나오는데
<br />
해싱은 이런식으로 복호화가 어렵다.
<br />
하지만 동일한 내용은 <code class="language-plaintext highlighter-rouge">항상 같은 해시값이 나온다는 단점</code>이 있다.
<br />
예를들면 동일한 비밀번호는 항상 해시값이 같다.</p>

<ul>
  <li>
    <p><strong><em>HashTable</em></strong>
<br />
key와 value의 쌍으로 이루어진 데이터 구조이다.
<br />
해시충돌이 일어나지 않는 가정 하에 평균 시간복잡도 O(1)로 효율적이다. 
<br />
이는 배열에서 <code class="language-plaintext highlighter-rouge">index</code>를 알고 접근하는 것과 동일한 시간복잡도를 보인다.</p>
  </li>
  <li><strong><em>key</em></strong> : 해시함수의 input이 되는 고유 값, 키는 해시함수를 통해 해시로 변경되고 <code class="language-plaintext highlighter-rouge">index</code> 역할을 하게된다.</li>
  <li><strong><em>value</em></strong> : 저장소(버킷, 슬롯)에 최종적으로 저장되는 값.</li>
  <li><strong><em>Hash</em></strong> : 임의의 값을 가지는 key값을 고정된 길이로 변환하는 것</li>
  <li><strong><em>Hash Function</em></strong> : 임의의 값을 고정된 크기의 값으로 변환하는 함수.  key -&gt; hash</li>
  <li><strong><em>저장소(Bucket, Slot)</em></strong> : Hash Table 에서 하나의 데이터가 저장되는 공간</li>
  <li>
    <p><strong><em>해시충돌</em></strong> : 서로 다른 key가 같은 hash값이 되는 경우</p>

    <ul>
      <li>
        <p><strong><em>데이터 저장</em></strong>
  <br />
  해시함수를 이용해 키값을 해시로 변경한 후 미리 준비해둔 저장소(버킷, 슬롯)중 
  <br />
  알맞는 해시값을 찾아 value를 저장한다.
  <br />
  이 과정의 시간복잡도는 O(1) 이다.</p>
      </li>
      <li>
        <p><strong><em>데이터 삭제</em></strong>
  <br />
  버킷에서 삭제하려고 하는 key와 매핑되는 value값을 찾아서 삭제한다
  <br />
  이 과정의 시간복잡도는 O(1) 이다.</p>
      </li>
      <li>
        <p><strong><em>데이터 검색</em></strong>
  <br />
  key를 이용해 value를 찾아내는 과정.
  <br />
  먼저 key값과 해시함수를 이용해 hash를 찾아내고 해당 hash로 value를 찾는다.
  <br />
  이 과정의 시간복잡도는 O(1) 이다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>자바의 Hash?</em></strong>
    <ul>
      <li>자바에서는 <code class="language-plaintext highlighter-rouge">Object</code>클래스의 hashCode() 메서드로 모든 객체의 해시코드를 쉽게 구할 수 있다</li>
      <li>자바는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 중복되지 않는 값을 제공한다.</li>
      <li>String의 경우 <code class="language-plaintext highlighter-rouge">Object</code>로부터 상속받은 hashCode()를 오버라이딩 하여 문자열의 내용으로 해시코드를 만들어 낸다. 그렇기 때문에 다른 인스턴스의 String이어도 문자열이 같다면 같은 해시코드값을 가진다.</li>
      <li>HashMap도 같은 방법으로 객체를 구별하기 때문에 이미 존재하는 키와 동일한 값을 저장하면 기존의 값을 덮어쓰게 된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong><em>단점</em></strong></p>
<ul>
  <li>정렬이나 순차적인 데이터 저장에 적합하지 않다</li>
  <li>데이터가 저장되기 전에 저장공간을 확보해야 하기 때문에 공간효율성이 떨어진다.</li>
  <li>Hash Function이 복잡할수록 연산속도가 증가한다.</li>
  <li>해시충돌이 발생할 경우 최악의 경우 시간복잡도가 O(N) 에 점점 수렴함</li>
</ul>

<p><br />
<br /></p>

<p><strong><em>HashMap</em></strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">thread-safe</code> 하지 않아 싱글스레드 환경에 적합하며, 동기화 처리를 하지않기 때문에 탐색속도가 가장 빠르다.</p>
<ul>
  <li>Key, Value 에 null을 허용한다.</li>
  <li>동기화를 보장하지 않는다.</li>
</ul>

<p><br />
<br /></p>

<p><strong><em>HashTable</em></strong>
<br />
<br />
<code class="language-plaintext highlighter-rouge">thread-safe</code> 하기 때문에 멀티스레드 환경에 적합하며, get(), put(), remove()등에 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드가
<br />
붙어있다. 스레드간 락을 걸기 때문에 데이터의 무결성을 보장하지만 <code class="language-plaintext highlighter-rouge">synchronized</code> 때문에 느리다.</p>
<ul>
  <li>Key, Value 에 null을 허용하지 않는다.</li>
  <li>동기화를 보장한다.</li>
</ul>

<p><br />
<br /></p>

<p><strong><em>ConcurrentHashMap</em></strong>
<br />
<br />
HashMap의 동기화 문제를 보완하기 위해 나왔다. 동기화 처리를 할때, data를 조작하는 경우에만
<br />
선택적으로 락을건다.  락의 범위는 HashMap의 Bucket수준이다. 
<br />
즉, data 수정작업에만 동기화 되며, read작업은 hashMap과 동일한 성능을 제공한다.</p>
<ul>
  <li>Key, Value 에 null을 허용하지 않는다.</li>
  <li>동기화를 보장한다.</li>
</ul>

<p><br />
<br /></p>

<p><strong><em>그래서 뭐쓰는데?</em></strong>
<br />
<br />
싱글스레드 에선 HashMap을, 멀티스레드 환경에서 동기화처리가 필요하다면 스레드간 락을거는 HashTable보다 
<br />
Entry 아이템별로 락을 거는 ConcurrentHashMap 을 쓰는게 좋다.
<br />
완벽한 비교는 아니지만 비슷한 맥락으로 비유해 보자면 <strong>HashTable / ConcurrentHashMap</strong> 의 차이는 
<br />
테이블 락 과도 비유해 볼 수 있다. 모든 작업에 동기화를 거는건 테이블락과 비슷할 정도로 비효율 적이기 때문에</p>

<p><br />
<br /></p>

<p><strong><em>하지만?</em></strong>
<br />
<br />
우리는 <code class="language-plaintext highlighter-rouge">Thread-safe</code> 하지 않은 HashMap을 자주쓴다. 그래도 동시성 문제에서 어느정도 자유로웠을 것이다. 
<br />
이건 왜그럴까?
<br />
<br />
<code class="language-plaintext highlighter-rouge">java.util.concurrent</code> 라는 패키지가 존재한다.
<br />
<br />
<strong><em>이펙티브자바 Item80 : 스레드보다는 실행자, 태스크, 스트림을 애용하라.</em></strong>
<br />
<br />
작업 큐를 손수 만드는 일은 삼가해야 하고, 스레드를 직접 다루는것도 일반적으로 삼가하라고 한다.
<br />
즉, 실행자 프레임워크를 통해 작업하라는 말이다.
<br />
대부분 request와 response의 스레드 생명주기를 가지는 웹 어플리케이션을 개발할때 스레드풀을 사용하기 때문에 큰 신경을 쓰지 않아도 <code class="language-plaintext highlighter-rouge">thread-safe</code> 한 것이다.
<br />
물론 싱글톤 이라던가 여러 스레드가 동일한 자원에 접근하여 수정하는 작업에선 따로 처리를 해줘야겠지?</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="array">Array</h1>
<p>메모리상에 데이터를 순차적으로 배치하는 자료구조
<br />
동일한 <code class="language-plaintext highlighter-rouge">type</code>의 데이터를 여러개 나열한 선형구조이다.
<br />
<code class="language-plaintext highlighter-rouge">index</code>를 사용할 수 있으며, <code class="language-plaintext highlighter-rouge">index</code>값을 알고 접근할 경우 시간복잡도는 O(1)이다.</p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>선언할 때 지정한 크기가 고정된다.</li>
      <li>선언된 값은 다시 배열을 선언하지 않는이상 변경할 수 없다.</li>
      <li>삽입 순서대로 저장된다. (새로운 데이터는 배열 맨 끝에 들어감)</li>
      <li>중복 가능</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>처음에 선언한 배열의 크기를 수정할 수 없다.</li>
      <li>데이터의 추가 / 삭제를 할 경우 뒤에있는 데이터들을 앞으로 옮기는 작업이 추가로 필요하다.
        <ul>
          <li>원소의 개수가 1000개인 배열에서 0번 <code class="language-plaintext highlighter-rouge">index</code>를 삭제하면,  삭제를 하는 작업 외에 (1000 - 1)만큼의 원소를 이동하는 추가작업 필요</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li>순차적인 데이터를 저장할 때 유용</li>
      <li>특정요소를 빠르게 읽을 때 (<code class="language-plaintext highlighter-rouge">index</code>값이 필요함)</li>
      <li>데이터 사이즈가 바뀌지 않거나 데이터의 추가 / 삭제가 자주 일어나지 않을 때</li>
      <li>이펙티브 자바에서는 배열보다 리스트를 사용하라 라는 챕터가 있다.
        <ul>
          <li>간단하게 말해 타입실수를 컴파일 단계에서 확인할 수 있냐 없냐의 차이</li>
          <li>배열의 성능이점보다 안전함을 더 중요하게 생각하는듯 하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="list">List</h1>
<p>데이터를 순차적으로 저장하는 <code class="language-plaintext highlighter-rouge">선형구조</code>의 자료구조
<br />
데이터가 삭제되도 빈공간으로 남겨두고 <code class="language-plaintext highlighter-rouge">index</code>를 유지하는 배열과 달리 빈공간을 남겨두지 않기 때문에
<br />
낭비되는 메모리가 없고 빈틈없는 데이터 구조를 가질 수 있다.
<br />
또한 배열과 다르게 데이터를 담을 공간의 추가가 가능하다.
<br />
하지만 배열처럼 고정된 <code class="language-plaintext highlighter-rouge">index</code>를 식별자로 이용할 수 없다.
<br /></p>
<ul>
  <li><strong><em>선형구조</em></strong> : 데이터가 순차적으로 저장되고 끊어지지 않으며 빈틈없이 데이터를 적재하는,
<br />
보기에 한줄로 계속되기 때문에 마치 선과 같은 형태를 띈다 하여 선형구조라 함
<br /></li>
</ul>

<p><img src="/images/big-o/list.png" alt="이미지" /></p>

<p><br /></p>

<ul>
  <li><strong><em>ArrayList</em></strong>
    <ul>
      <li>배열을 이용해 구현된 List</li>
      <li>데이터를 추가/삭제 할때, 연속적인 물리적위치를 유지하기 위해 원소를 옮기는 추가작업이 필요하다.
        <ul>
          <li>원소의 개수가 1000개인 ArrayList에서 0번 index를 삭제하면, 
  <br />
  삭제를 하는 작업 외에 (1000 - 1)만큼의 원소를 이동하는 추가작업이 필요하다.</li>
        </ul>
      </li>
      <li>데이터 조회의 시간복잡도는 O(1)이다.</li>
      <li><strong><em>데이터 탐색에 효율적이다.</em></strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>LinkedList</em></strong>
    <ul>
      <li>연결 포인터를 이용해 구현한다.
        <ul>
          <li>기본단위는 노드이다</li>
          <li>노드 : 자료(Data) + 링크(Link)</li>
        </ul>
      </li>
      <li>각 데이터마다 다음 순서의 데이터가 뭔지 알려주는 포인터가 존재하는 구조이다.</li>
      <li>데이터를 추가/삭제 할때, 특정 노드의 링크필드(다음 노드주소)만 수정하면 된다.
  <br />
  즉, 노드의 포인트가 가리키는 것만 바꾸면 되기 때문에 시간복잡도는 O(1)이다.</li>
      <li><code class="language-plaintext highlighter-rouge">index</code>가 없기때문에 데이터 조회의 시간복잡도는 모든 노드를 순회하는 O(n)이다.</li>
      <li><strong><em>데이터의 추가/삭제에 효율적이다.</em></strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li><strong><em>ArrayList</em></strong> : 탐색에 유용
        <ul>
          <li>데이터를 중간에 추가 / 삭제하는 경우가 적다면 사용을 고려해보자.</li>
        </ul>
      </li>
      <li><strong><em>LinkedList</em></strong> : 추가/삭제에 유용
        <ul>
          <li>데이터를 중간에 추가 / 삭제하는 경우가 많다면 사용을 고려해보자.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="set">Set</h1>
<p>데이터의 집합이며 순서가 없고 집합이므로 중복된 데이터를 허용하지 않는다.
<br />
<code class="language-plaintext highlighter-rouge">index</code>가 따로 존재하지 않기 때문에 <code class="language-plaintext highlighter-rouge">Iterator</code>를 사용한다.
<br /></p>

<p><img src="/images/big-o/set.png" alt="이미지" /></p>

<p><br /></p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>순서가 없고 중복을 허용하지 않는다.</li>
      <li>자바의 Set
        <ul>
          <li>Hash알고리즘을 이용한 <code class="language-plaintext highlighter-rouge">HashSet</code></li>
          <li>이진탐색트리를 사용해 오름차순정렬을 해주는 <code class="language-plaintext highlighter-rouge">TreeSet</code></li>
          <li>순서를 부여해주는 <code class="language-plaintext highlighter-rouge">LinkedHashSet</code></li>
        </ul>
      </li>
      <li>일반적으로 <code class="language-plaintext highlighter-rouge">HashSet &gt; TreeSet &gt; LinkedHashSet</code> 순으로 빠르다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>HashSet</em></strong>
    <ul>
      <li>입력된 키를 해시알고리즘으로 해시코드로 변환한다.</li>
      <li>그 후 해시코드를 인덱스로 bucket저장소에 저장한다.</li>
      <li>값이 키와 동일하게 설정된다.</li>
      <li>순서를 보장하지 않는다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>TreeSet</em></strong>
    <ul>
      <li>이진 탐색 트리(Red-Black Tree)를 기반으로 한다.</li>
      <li>오름차순으로 데이터를 저장한다.</li>
      <li>추가 / 삭제는 LinkedHashSet보다 느리지만 검색 / 정렬은 더 효율적이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>LinkedHashSet</em></strong>
    <ul>
      <li>데이터가 들어간 순서대로 저장된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li>중복된 값을 골라낼때 유용하다.</li>
      <li>빠른 탐색에 유용하다.
        <ul>
          <li><strong><em>특정 요소의 값을 찾기보다는 요소가 집합에 존재하는지 확인할 때</em></strong></li>
          <li>List의 contains 시간복잡도는 O(n)이지만 <strong><em>Set은 O(1)</em></strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="map">Map</h1>
<p>순차적으로 메모리에 데이터를 저장하는 Array와 List와는 달리,
<br />
Key와 Value로 이루어진 자료구조이다.
<br /></p>

<p><img src="/images/big-o/map.png" alt="이미지" /></p>

<p><br /></p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>데이터의 순서가 없다.</li>
      <li>Key는 중복을 허용하지 않는다.</li>
      <li>List와 마찬가지로 인터페이스이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>Hash Table / Map</em></strong>
    <ul>
      <li><strong><em>Hash</em></strong>를 Key로 가지는 Map, 앞에서 설명했듯 가장 큰 차이점은 <code class="language-plaintext highlighter-rouge">동기화</code>와 <code class="language-plaintext highlighter-rouge">null</code>이다.
        <ul>
          <li><strong><em>HashMap</em></strong> : <code class="language-plaintext highlighter-rouge">동기화</code>를 지원하지 않고 Key 와 Value에 <code class="language-plaintext highlighter-rouge">null</code>이 허용된다.</li>
          <li><strong><em>HashTable</em></strong> : <code class="language-plaintext highlighter-rouge">동기화</code>를 지원하고 Key 와 Value에 <code class="language-plaintext highlighter-rouge">null</code>이 허용되지 않는다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>LinkedHashMap</em></strong>
    <ul>
      <li>데이터가 들어간 순서대로 저장된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>TreeMap</em></strong>
    <ul>
      <li>이진검색 트리구조, Key를 기준으로 오름차순으로 저장된다.
        <ul>
          <li>숫자 &gt; 대문자 &gt; 소문자 &gt; 한글</li>
        </ul>
      </li>
      <li>정렬된 순서로 저장하기 때문에 검색에는 빠르지만 저장 시 효율이 떨어진다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li><strong><em>저장하고 싶은 데이터가 특별한 Key 값을 가질 때</em></strong> - 검색에 유용</li>
      <li>특정 데이터를 순간마다 캐치해야 할 때</li>
      <li>특정 품목의 갯수를 카운트 해야할 때</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="stack">Stack</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="queue">Queue</h1>
<p><img src="/images/big-o/queue.png" alt="이미지" /></p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="tree">Tree</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="graph">Graph</h1>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="Data_Structure" /><category term="Data Structure" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">2 Week</title><link href="http://localhost:4000/til/2%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="2 Week" /><published>2022-12-22T00:00:00+09:00</published><updated>2022-12-22T00:00:00+09:00</updated><id>http://localhost:4000/til/2%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/2%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="enum">enum</h1>
<p>열거형이라고 부르며, 서로 연관된 상수들의 집합이다.
<br />
모든 열거형은 <code class="language-plaintext highlighter-rouge">Enum</code>클래스의 자손이며 <code class="language-plaintext highlighter-rouge">Enum</code>클래스의 멤버를 상속받는다.</p>

<p><br /></p>

<h2 id="특징과-장점">특징과 장점</h2>
<ul>
  <li>enum은 컴파일 후 <code class="language-plaintext highlighter-rouge">public static final</code> 필드이며 객체로 제공된다.</li>
  <li>상수들은 JVM 메서드 영역에 자리한다.</li>
  <li>Enum클래스는 상수와 같이 인스턴스가 단 한번만 생성된다.</li>
  <li>컴파일 시점에 타입안정성이 보장되기 때문에 <code class="language-plaintext highlighter-rouge">private</code> 생성자만을 가진다. 
<br />
즉, 인스턴스 생성을 제어하며 싱글톤을 일반화 한다. (싱글톤 구현의 방법으로도 사용됨)</li>
  <li>그렇기 때문에 주소값을 비교하는 == 연산자의 사용이 가능하다.
<br />
즉, 객체의 값을 비교하는 equals()보다 빠르고 컴파일 단계에서 검사되기 때문에 실수를 방지할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="enum-method">enum method</h2>
<ul>
  <li><strong><em>values()</em></strong> : enum클래스의 모든 상수를 배열로 반환한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// values 활용</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">LottoRank</span> <span class="nf">countOfMatchNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">countOfMatchNumber</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
			<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="nc">LottoRank</span> <span class="o">-&gt;</span> <span class="nc">LottoRank</span><span class="o">.</span><span class="na">countOfMatchNumber</span> <span class="o">==</span> <span class="n">countOfMatchNumber</span><span class="o">)</span>
			<span class="o">.</span><span class="na">findAny</span><span class="o">()</span>
			<span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="no">MISS</span><span class="o">);</span>
			<span class="c1">// 또는 orElseThrow(new IllegalArgumentException(error message))</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>valueOf()</em></strong> : <code class="language-plaintext highlighter-rouge">String</code>을 매개변수로 받아 일치하는 상수를 반환한다. (없으면 런타임 에러 발생)</li>
  <li><strong><em>ordinal()</em></strong> : 상수들의 index를 반환한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
<br />
enum자체가 가지는 비용이 적지 않다. static final 상수로도 충분하다면 enum의 사용 여부는 고려해보자</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="싱글톤패턴">싱글톤패턴</h1>
<p>객체의 인스턴스가 오직 1개만 생성되는 패턴이다.
<br />
하나의 인스턴스로 공유되며 접근, 사용할 수 있다</p>

<ul>
  <li>가장 단순한 코드레벨의 싱글톤 패턴</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동시성 이슈를 배제한 Lazy initialization 방식</span>
<span class="c1">// Thread Safety 하지 않다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>인스턴스가 하나기 때문에 매번 새로 인스턴스를 생성할 필요가 없다.</li>
      <li>싱글톤 패턴으로 만들어진 클래스는 전역 인스턴스이기 때문에 접근하기 편하다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>클라이언트가 구체클래스에 의존 -&gt; DIP OCP 위반</li>
      <li>멀티스레드 환경에서 인스턴스가 하나이기 때문에 문제가 발생할 수 있다.</li>
      <li>테스트가 어렵다. 인스턴스가 하나기 때문에 테스트를 하려면 매번 초기화를 시켜주어야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="활용">활용</h2>
<ul>
  <li>
    <p><strong><em>synchronized</em></strong> : 사용하지 말자. 락을 걸어버리는 방법으로 동기화 문제를 간단하고 확실하게 해결하지만 그렇기 때문에 멀티스레드의 이점을 모두 막아버린다.</p>
  </li>
  <li>
    <p><strong><em>Lazy initialization + Double-checked Locking</em></strong> : 이것도 좋지 않다.</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 조건문으로 먼저 인스턴스를 확인한 다음 synchronized를 동기화 시켜 인스턴스를</span>
<span class="c1">// 생성하는방법, 처음 생성이후 synchronized를 실행하지 않아서 성능저하 완화 가능</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Person</span> <span class="n">instance</span><span class="o">;</span>
	
	<span class="kd">private</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>Initialization on demand holder idiom</em></strong> : 제일 많이 사용되는 방법</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는</span>
<span class="c1">// 시점을 이용한 방법</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">LazyHorder</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Person</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nc">LazyHorder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>스프링 컨테이너를 사용하는게 가장 좋다.</em></strong>
    <ul>
      <li>상태를 유지(stateful)하면 안되고 무상태(stateless)로 설계해야 한다.</li>
      <li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다</li>
      <li>읽기만 가능해야 한다.</li>
      <li>필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.</li>
      <li><code class="language-plaintext highlighter-rouge">@Configuration</code>, <code class="language-plaintext highlighter-rouge">@Bean</code>을 같이 사용한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="인터페이스">인터페이스</h1>
<p>컴퓨터 사이언스에서 인터페이스란 서로간의 약속, 규약 등의 개념으로 사용하게 끔 오픈된 것을 말한다.
<br />
일종의 서로를 이어주는 <strong><em>메시지 창구</em></strong> 역할을 하며, 대표적인 소프트웨어 인터페이스로는 <code class="language-plaintext highlighter-rouge">API</code>가 있다.
<br />
<strong><em>자바</em></strong> 에서 인터페이스란, 다른 클래스의 기본이 되는 틀을 제공하면서
<br />
다른 클래스 사이의 중간 매개역할을 하는 일종의 추상클래스 이다.
<br />
자바8 이전에는 오로지 추상메서드와 상수만을 포함할 수 있었는데 
<br />
자바8이후 <code class="language-plaintext highlighter-rouge">default method</code>, <code class="language-plaintext highlighter-rouge">static method</code>가 추가되었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 은행시스템을 운영하려면 이 금융결제원 인터페이스에 맞게 구현해야 한다고 치자</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Bank</span> <span class="o">{</span>

	<span class="c1">// 상수 (하루 최대 인출 금액)</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="no">MAX_INTEGER</span> <span class="o">=</span> <span class="mi">10000000</span><span class="o">;</span>
	
	<span class="c1">// 추상메서드 (인출)</span>
	<span class="kt">void</span> <span class="nf">withDraw</span><span class="o">(</span><span class="kt">int</span> <span class="n">price</span><span class="o">);</span>
	
	<span class="c1">// 추상메서드 (입금)</span>
	<span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="kt">int</span> <span class="n">price</span><span class="o">);</span>
	
	<span class="c1">// defualt 메서드 (고객의 휴면계좌 찾아주는 메서드 : 필수구현은 선택사항)</span>
	<span class="k">default</span> <span class="nc">String</span> <span class="nf">findDormancyAccount</span><span class="o">(</span><span class="nc">String</span> <span class="n">custId</span><span class="o">){</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"**금융개정법안 00이후 고객의 휴면계좌 찾아주기 운동**"</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"**금융결제원에서 제공하는 로직**"</span><span class="o">);</span>
		<span class="k">return</span> <span class="s">"00은행 000-000-0000-00"</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">// 정적 메서드 (블록체인 인증)</span>
	<span class="kd">static</span> <span class="kt">void</span> <span class="nf">BCAuth</span><span class="o">(</span><span class="nc">String</span> <span class="n">bankName</span><span class="o">){</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bankName</span><span class="o">+</span><span class="s">" 에서 블록체인 인증을 요청합니다."</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"전 금융사 공통 블록체인 로직 수행"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong><em>상수</em></strong> : 컴파일 단계에서 정해지는, 인터페이스가 제공하는 변하지 않는 값
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public static final</code>을 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
    </ul>
  </li>
  <li><strong><em>정적메서드</em></strong> : 인터페이스에서 제공하는 변하지 않는 메서드
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code>을 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
    </ul>
  </li>
  <li><strong><em>추상메서드</em></strong> : 구현클래스에서 구현해야만 하고 거기서 실행된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public abstract</code>를 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
    </ul>
  </li>
  <li><strong><em>디폴트메서드</em></strong> : 인터페이스에서 제공해주지만, 구현클래스에서 재구현 할 수 있고 안써도 된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code>을 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
      <li>구현클래스에 인스턴스 메서드로 추가됨. 즉, 구현객체가 있어야 사용할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>인터페이스는 직접 인스턴스를 생성할 수는 없고 추상메서드를 구현해 줄 클래스를 작성해야 한다.</li>
      <li>자바에서 다중상속은 지원하지 않지만 다중 인터페이스는 구현할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="쓰는-이유">쓰는 이유?</h2>
<ul>
  <li>추상메서드와 상수를 통해 구현클래스에 <strong><em>동일한 동작</em></strong>을 보장한다.
    <ul>
      <li>클래스의 설계 또는 표준화를 유도할 수 있다.</li>
      <li>자바8 이후 <code class="language-plaintext highlighter-rouge">default method</code>로 유연성을 추가로 확보했다.</li>
    </ul>
  </li>
  <li><strong><em>다형성</em></strong>을 이용하여 타입변환을 한다.
    <ul>
      <li>회사에서 입출금 업무를 하는 로직이 있다면 인터페이스를 이용할 시 
<br /> 새로운 은행에 대한 코드만 작성해서 인스턴스만 바꿔 끼면 끝난다.</li>
    </ul>
  </li>
  <li>개인적으로 상속보다 좋아보인다..
    <ul>
      <li><strong><em>has-a</em></strong> : “~를 할 수 있는”</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="문제점">문제점</h2>
<ul>
  <li>수정이 어렵다.
    <ul>
      <li>자바8 이후 대대적인 개선으로 많이 좋아졌다고 생각한다. <code class="language-plaintext highlighter-rouge">(default method)</code></li>
    </ul>
  </li>
  <li><strong><em>잘사용해야한다..</em></strong> 불필요하게 어플리케이션의 복잡도만 증가시킬 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="default-method">default method</h2>
<p>이미 잘 운영중인데 휴면계좌 서비스를 점진적으로 도입하기로 정책이 바뀌었다고 치자.
<br />
추상메서드로 새로 추가하려고 하면 금융결제원의 Bank 인터페이스를 implements한 
<br />
각 은행사의 모든 클래스에서 무조건 구현을 해야한다.
<br />
은행사 마다 개발, 운영환경이 다르고 개발기간도 다르기 때문에 쉽지않다.
<br />
만약 <code class="language-plaintext highlighter-rouge">default method</code>로 정의하고 기본적인 구현부를 제공하면 각 은행에서 자신들만의 로직으로 재구현 할 수도 있고
사용을 안할 수도 있어서 점진적으로 도입하기로 한 정책을 실행할 수 있을것이다.
<br />
그대로 쓰거나, 재구현 하거나, 안쓰거나 할 수 있는것이다.
<br />
이것은 구현클래스가 자신만의 메서드를 각자 추가하는 것과는 엄연히 다르다.
<br />
<strong><em>즉, 운영중인 시스템에 효과적으로 유연함을 제공한다.</em></strong>
<br />
또한 <code class="language-plaintext highlighter-rouge">default method</code>는 <code class="language-plaintext highlighter-rouge">functional</code> 하다.
<br />
이 말은 에러에 최소화 되었다는 의미 이기도 하다.</p>

<p><br /></p>

<h2 id="함수형-인터페이스">함수형 인터페이스</h2>
<p>추상메서드가 단 하나뿐인 인터페이스 이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
어노테이션의 기능은 단일 추상메서드인지 컴파일 단계에서 확인하기 위함이다.
@FunctionalInterface 가 붙지 않아도 함수형인터페이스로 사용될 수 있으나
직관성을 위해 붙이는걸 추천한다
*/</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Calculate</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="쓰는-이유-1">쓰는 이유?</h3>
<hr />
<p>자바의 람다식은 함수형 인터페이스로만 접근할 수 있기 때문이다.
<br />
람다식과 인터페이스는 1:1로 연결될 수 있기 때문에 이 추상메서드의
<br />
매개변수의 개수와 타입, 리턴타입과 동일한 람다식을 할당해서 사용할 수 있다.
<br />
단, <code class="language-plaintext highlighter-rouge">static method</code>와 <code class="language-plaintext highlighter-rouge">default method</code>의 개수는 제약이 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FunctionalInterface</span> <span class="n">func</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FunctionalInterface</span><span class="o">()</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">};</span>
<span class="n">func</span><span class="o">.</span><span class="na">doSomething</span><span class="o">(</span><span class="s">"do something"</span><span class="o">);</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h1 id="추상클래스">추상클래스</h1>
<p>하나 이상의 추상메서드를 포함하는 클래스 이다.
<br />
추상클래스를 상속받는 클래스는 추상메서드를 반드시 재정의 해야한다.
<br />
추상클래스는 인스턴스를 생성할 수 없으며, 자식클래스가 인스턴스를 생성할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nc">Int</span> <span class="n">age</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">say</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="쓰는이유">쓰는이유?</h2>
<ul>
  <li>상속받는 클래스에게 추상메서드를 <strong><em>반드시 구현하도록 강제하기 위해</em></strong>
    <ul>
      <li>공통적인 부분에 대한 어느정도의 <strong><em>규격</em></strong>을 잡아 놓는다. (미완성 설계도)</li>
      <li>공통된 필드와 메서드를 통일할 목적 - 중복 제거</li>
      <li>다형성</li>
    </ul>
  </li>
  <li>구조를 재사용하기 위해서</li>
  <li>특정필드를 재사용하고 싶고 공개하고 싶지 않아서</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="둘의-차이">둘의 차이</h1>
<p>인터페이스는 정의된 메서드를 각 클래스의 목적에 맞게 기능 구현을 하는 느낌.
<br />
(구현 객체가 같은 동작을 한다는것을 보장하기 위해)
<br />
추상클래스는 자신의 기능들을 하위클래스로 확장시키는 느낌으로 다가가자.
<br />
(같은 부모클래스가 가진 기능들을 구현하기 위해)</p>

<ul>
  <li>상태의 차이
    <ul>
      <li><code class="language-plaintext highlighter-rouge">non-static</code> 멤버 즉, <strong><em>상태 값</em></strong> 을 가지는가에 대한 차이</li>
    </ul>
  </li>
  <li>다중 상속
    <ul>
      <li>인터페이스는 다중으로 구현이 가능하지만 추상클래스는 단일 상속만 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Enum" /><category term="Singleton" /><category term="Interface" /><category term="Abstract" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Annotation</title><link href="http://localhost:4000/til/Annotation/" rel="alternate" type="text/html" title="Annotation" /><published>2022-12-20T00:00:00+09:00</published><updated>2022-12-20T00:00:00+09:00</updated><id>http://localhost:4000/til/Annotation</id><content type="html" xml:base="http://localhost:4000/til/Annotation/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="enablescheduling">@EnableScheduling</h1>
<p>스프링의 스케쥴링을 위한 어노테이션이다.
<br />
기본적으로 스프링에 의헤 생성된 한개의 <code class="language-plaintext highlighter-rouge">Thread Pool</code>에서 작동한다. 
<br />
하나의 스케쥴이 돌고 있으면 그것이 다 끝나야 다음 스케쥴이 실행되기 때문에 설정을 통해 스케쥴에 대한 스레드풀을 생성하고 
그 스레드풀을 사용해서 병렬적으로 처리하는게 좋을 수 있다.</p>

<ul>
  <li>스프링 스케쥴링에 사용</li>
  <li>스프링 빈으로 등록해서 사용한다.</li>
  <li>Application Class에 @EnableScheduling 선언</li>
  <li>scheduler를 사용할 class에 @Component 선언, 메서드에 @Scheduled 선언
    <ul>
      <li>메서드 타입은 void</li>
      <li>메서드에 매개변수 사용 불가</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>왜 이거쓰는데?</em></strong>
<br />
  <code class="language-plaintext highlighter-rouge">Spring Quartz</code>라는 더 많은 기능을 가진 스케줄러도 존재한다.
  <br />
  하지만 의존성이 추가되어야 하고 사용법이 좀 더 복잡하기 때문에 단순한 스케쥴링 작업에는 
  <br />
  별도의 추가적인 의존성이 필요없고 사용법이 간단한 <code class="language-plaintext highlighter-rouge">Spring Scheduler</code>를 추천한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="value">@Value</h1>
<p>properties 파일의 설정정보를 key-value형태로 가져오는데 쓰인다.
<br />
단일값 주입에 권장되고 있으며 여러개의 값을 주입받아야 할 경우
<br />
<code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 사용을 권장한다.</p>

<ul>
  <li><strong><em>이거 왜쓰는데?</em></strong>
<br />
  만약 소스코드로 설정정보를 관리한다면 보안에도 좋지않고, 컴파일 된 바이트코드를 JVM에서 실행 후에 의미있는 정보가 되기때문에 서버를 내리지 않고는 변경할 수 없다.
  <br />
  하지만 properties 파일로 관리하면 key-value값만 불러서 치환하기 때문에 소스코드를 수정 할 필요가 없고 서버의 properties파일만 수정하면 되기 때문에 서버를 중단할 필요가 없다.
  <br />
  또한 각 서버환경에 따라 설정도 유연하게 관리할 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="bean">@Bean</h1>
<ul>
  <li><strong><em>@Bean</em></strong>
    <ul>
      <li>스프링에서 IoC 컨테이너가 관리하는 자바 객체</li>
      <li>기본적으로 싱글톤으로 생성하고 관리한다.</li>
    </ul>
  </li>
  <li><strong><em>@Component</em></strong>
    <ul>
      <li>개발자가 직접 작성한 클래스를 Bean으로 등록할 때 사용한다.</li>
      <li>선언 시 Component-Scan에 의해 Bean으로 등록 된다.</li>
    </ul>
  </li>
  <li><strong><em>@Configuration</em></strong>
    <ul>
      <li>외부라이브러리 또는 내장 클래스를 Bean으로 등록하고자 할 경우 사용한다.</li>
      <li>1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration를 선언한다.</li>
      <li>선언 시 Component-Scan에 의해 Bean으로 등록 된다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="async">@Async</h1>
<p>스프링에서 제공하는 <code class="language-plaintext highlighter-rouge">Thread Pool</code>을 활용하는 비동기 메서드 지원 어노테이션이다.
<br />
간단하게 사용하고 싶다면 Application 클래스에 <code class="language-plaintext highlighter-rouge">@EnableAsync</code>를 선언하고 비동기로 작동하고자 하는 메서드에 <code class="language-plaintext highlighter-rouge">@Async</code>를 선언해주면 사용할 수 있다.
<br />
하지만 이럴 경우 기본설정인 <code class="language-plaintext highlighter-rouge">SimpleAsyncTaskExecutor</code>를 사용해서 스레드를 관리하지 않는 등의 문제가 있기 때문에 <code class="language-plaintext highlighter-rouge">AsyncConfigurer</code> 인터페이스를 상속받아 구현하는게 좋을 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableAsync</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncConfig</span> <span class="kd">implements</span> <span class="nc">AsyncConfigurer</span> <span class="o">{</span>
	
	<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">getAsyncExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"async-pool"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>@Configuration</em></strong> : 빈 등록</li>
  <li><strong><em>@EnableAsync</em></strong> : 메서드에서 비동기 기능을 사용할 수 있게 한다.</li>
  <li><strong><em>CorePoolSize</em></strong> : 기본 실행 대기하는 Thread의 수</li>
  <li><strong><em>MaxPoolSize</em></strong> : 동시 동작하는 최대 Thread의 수</li>
  <li><strong><em>QueueCapacity</em></strong> : MaxPoolSize 초과 요청에서 Thread 생성 요청시,  해당 요청을 Queue에 저장하는데 이때 최대 수용 가능한 Queue의 수,   Queue에 저장되어있다가 Thread에 자리가 생기면 하나씩 빠져나가 동작</li>
  <li><strong><em>ThreadNamePrefix</em></strong> : 생성되는 Thread 접두사 지정</li>
  <li>그 후 비동기를 원하는 메서드에 <code class="language-plaintext highlighter-rouge">@Async</code> 어노테이션을 선언해 주면 된다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>주의할 점</em></strong>
    <ul>
      <li>private method에 사용 불가</li>
      <li>자가호출 불가 즉, 이너클래스에서 사용 불가</li>
      <li>QueueCapacity 초과 요청에 대한 비동기 method 호출시 방어 코드 작성</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Spring Annotation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">1 Week</title><link href="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="1 Week" /><published>2022-12-15T00:00:00+09:00</published><updated>2022-12-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="객체와-클래스-그리고-인스턴스">객체와 클래스 그리고 인스턴스</h1>
<ul>
  <li><strong><em>객체</em></strong>
    <ul>
      <li>물리적, 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.</li>
      <li>소프트웨어 에서 구현할 대상</li>
    </ul>
  </li>
  <li><strong><em>클래스</em></strong>
    <ul>
      <li>java에서 객체를 생성하기 위한 일종의 설계도</li>
      <li>속성(필드)을 가지고 있고, 행위(메소드)를 가지고있다.</li>
      <li>oop의 관점에서 클래스 타입으로 선언되었을 때 ‘객체’라고 부른다.</li>
    </ul>
  </li>
  <li><strong><em>인스턴스</em></strong>
    <ul>
      <li>클래스를 가지고 객체를 실체화 한것.</li>
      <li>메모리에 할당되어 실제로 사용되는 객체</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="절차형-객체지향-함수형-패러다임">절차형, 객체지향, 함수형 패러다임</h1>
<h2 id="절차형-프로그래밍-procedural-programming">절차형 프로그래밍 (Procedural Programming)</h2>
<p>위에서부터 아래로의 순차적인 처리를 중요시 하며 루틴, 서브루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임
	* <strong><em>장점</em></strong>
		* 컴퓨터 처리구조와 유사해 실행속도가 빠르다.
	* <strong><em>단점</em></strong>
		* 코드가 길어지면 가독성이 떨어지며 유지보수가 어렵다.
		* 정해진 순서대로 입력을 해야하므로 순서가 바뀌면 결과를 보장할 수 없다.
		* 대형 프로젝트에 적합하지 않다.</p>

<p><br /></p>

<h2 id="객체지향-프로그래밍-oop">객체지향 프로그래밍 (OOP)</h2>
<p>모든 것을 객체로 취급하고 객체가 처리요청을 받았을 때, 객체 내부의 기능을 사용해 처리하는 방법이다.
<br />
클래스 디자인과 객체들의 관계를 중심으로 설계가 이루어진다.
<br />
따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있고, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라진다.
	* <strong><em>특징</em></strong>
		* 캡슐화 - 정보를 은닉하고 노출시키지 않는다.
		* 추상화 - 공통적인 속성이나 기능을 묶는다.
		* 상속 - 아래 더 자세히..
		* 다형성 - 아래 더 자세히..
	* <strong><em>장점</em></strong>
		* 재사용에 용이하다. (확장, 유지보수)
		* 분석과 설계의 전환이 쉽다.
	* <strong><em>단점</em></strong>
		* 처리속도가 상대적으로 느리다.
		* 모든 객체의 역할과 기능을 설계해야 하기 때문에 많은 시간이 소요된다.</p>

<p><br /></p>

<h2 id="함수형-프로그래밍">함수형 프로그래밍</h2>
<p>순수함수를 사용해 상태를 제어하지 않고 빠른 처리에 집중하는 방식, 함수 자체가 일급객체가 된다. 
<br />
OOP와는 데이터(상태)를 다루는 개념과, 간결한 코드 작성에 대한 관점차이가 있다.
<br />
<br />
<strong><em>일급객체</em></strong> - 다른 요소들과 아무런 차별이 없는 객체, 함수를 변수로 사용할 수 있다는 의미도 된다.
<br /></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>함수가 하는일은 명확하기 때문에 코드의 가독성이 좋아지고 테스트가 쉬워진다.</li>
      <li>값이 한번 변수에 할당되면 이후에 변경되지 않기 때문에 부수효과가 발생하지 않으며 참조투명성을 가진다. 즉, 멀티코어 프로세스에서 교착상태에 빠지지 않는다.</li>
      <li>동시성 프로그래밍에 용이하다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>상태의 조작이 불가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <h2 id="그래서-뭐가-좋은데"><strong><em>그래서 뭐가 좋은데?</em></strong></h2>
    <p>자바8에서 함수형 프로그래밍을 도입했다. 
<br />
객체지향을 추구하는 자바진영에서 왜 함수형 프로그래밍을 도입했을까?
<br />
데이터 자체를 핸들링하는 함수형 프로그래밍은 어떤 데이터가 들어가도 로직 수행 후 의도한 데이터를 리턴한다. 
하지만 객체지향은 여기에 상태까지 관리해 줘야 하기 때문에 신경 쓸것이 많다. 
<br />
현대 어플리케이션은 함수형과 객체지향을 모두 사용한다. 
<br />
예를들면, 내가 매일 작업하는 로직들은 함수형 이지만, 디비에 접근하는 순간만큼은 함수형일 수가 없다. 
<br />
데이터를 저장해야 하고 값을 리턴받아야 하고 등의 상태값이 존재하기 때문이다. 
<br />
이외에도 여러가지가 있겠지만 자바8에 추가된 람다의 함수형 프로그래밍도 이와 같다. 
<br />
람다로 코드를 짤 경우 데이터의 무결성을 보장한다. 
<br />
왜냐하면 전통적인 for루프의 경우 객체를 작업하지만 람다의 경우 데이터 그 자체를 핸들링 하기 때문이다.
<br />
결국 시대의 흐름에 맞게 병렬 프로세싱을 잘 활용하기위해 자바 8에서 도입을 했고 
<br />
뭐가 더 좋다기 보단 둘다 적재적소에 사용하는게 중요하겠다.</p>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="자바의-type">자바의 Type</h1>
<h2 id="primitive-type원시타입">Primitive Type(원시타입)</h2>
<ul>
  <li>정수, 실수, 문자, 논리 리터럴등의 실제 데이터값을 저장하는 타입</li>
  <li>기본값이 있기때문에 Null이 존재하지 않는다. 기본형 타입에 Null을 넣고싶다면 래퍼클래스를 활용한다.</li>
  <li>제네릭 타입에서 사용할 수 없다.</li>
  <li>실제값을 저장하는 공간으로 Stack 영역에 저장된다.</li>
  <li>실제값이 Stack영역에 있으므로 참조타입보다 접근속도가</li>
</ul>

<p><br /></p>

<h2 id="reference-type참조타입">Reference Type(참조타입)</h2>
<ul>
  <li>객체의 주소를 저장하는 타입으로 메모리 번지값을 통해 객체를 참조하는 타입</li>
  <li>기본형 타입을 제외한 모든 타입은 참조형 타입이다. (문자열, 배열, 클래서, 열거, 인터페이스 등)</li>
  <li>제네릭 타입에서 사용할 수 있다.</li>
  <li>실제 객체는 Heap 영역에 저장되고 Stack영역에 객체의 주소를 저장해서 참조한다.</li>
  <li>실제값이 Heap 영역에 있고 Stack메모리에는 참조값만 있으므로 값이 필요할 때마다 최소 2번 메모리 접근을 해야하고 박싱/언박싱 과정을 거쳐야 해서 원시타입보다 접근속도가 느리다.</li>
  <li>실제 사용하는 메모리양도 원시타입보다 월등히 많다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>String?</em></strong>
    <ul>
      <li>참조타입에 속하지만 기본적인 사용은 원시타입이다.</li>
      <li>불변객체이다. 그래서 String 클래스의 값을 변경하는 메소드를 사용해도 값이 변경되는 것이 아닌 새로운 String 객체를 만든다.</li>
      <li>기본형 비교는 == 사용이지만 String 간 객체비교는 equals()메소드를 사용한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="wrapper-class">Wrapper Class</h1>
<p>원시타입을 객체로 다루기 위해 사용하는 클래스이다. 기본타입의 값을 내부에 두고 포장해서 포장객체 라고도 불리는데 래퍼클래스로 감싸고 있는 값은 외부에서 변경이 불가능하고 변경하려면 새로운 포장객체를 만들어야 한다. 자바의 모든 객체가 그러하듯 Object를 상속받는다.</p>

<p><br /></p>

<h2 id="박싱--언박싱">박싱 / 언박싱</h2>
<ul>
  <li>원시타입을 포장객체로 만드는게 박싱, 반대로 포장객체에서 원시타입을 얻는게 언박싱이다.</li>
  <li>JDK 1.5 이후로 오토 박싱/언박싱을 지원 한다.</li>
  <li>래퍼객체 내부값을 비교하려면 equals를 사용해야 한다. == 는 래퍼 객체의 참조 주소를 비교하기 때문이다.</li>
  <li>래퍼클래스와 원시타입 비교는 둘다 가능하다. JDK 1.5 이후로 오토 박싱/언박싱을 지원하기 때문이다</li>
</ul>

<p><br /></p>

<h2 id="왜-쓰는데">왜 쓰는데?</h2>
<ul>
  <li>원시타입을 클래스화 하여 클래스의 장점을 활용할 수 있다. (클래스에 지원되는 여러 메소드들)</li>
  <li>null 지원</li>
  <li>기본타입을 객체로 써야할 경우가 있음
    <ul>
      <li>ex) <strong><em>List&lt;</em></strong>Integer<strong><em>&gt;</em></strong> 에 원시타입 <strong><em>int</em></strong> 값을 넣는다던가… (오토박싱/언박싱 지원)</li>
    </ul>
  </li>
  <li>제네릭에 원시타입은 쓸수가 없음</li>
  <li><strong><em>일급콜렉션</em></strong>
    <ul>
      <li>콜렉션을 래핑할때, 그 외에 다른 멤버변수가 없는 상태를 일급콜렉션 이라한다.</li>
      <li>이렇게 되면 하나의 인스턴스에서 비즈니스 로직을 관리할 수 있게 되는 장점이 있다.
        <ul>
          <li>ex) 같은 객체를 여러개 생성해야 할때, 이 모든 인스턴스들을 담는 일급콜렉션을 만들다던가..</li>
          <li>비즈니스 로직을 도메인에서 관리 (비즈니스에 종속적인 자료구조를 만들 수 있음)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="동일성과-동등성">동일성과 동등성</h1>
<h2 id="동일성">동일성</h2>
<ul>
  <li>두 객체가 완전히 같은 경우.
<br />
주소값이 같기 때문에 하나의 객체로 봐도 무방하며 두 변수가 같은 객체를 참조한다.</li>
  <li>== 연산자를 사용해 판별할 수 있다.</li>
  <li>원시타입은 객체가 아닌 스택메모리에 직접 값이 올라가기 때문에 == 결과가 같으면 동일하다.</li>
</ul>

<p><br /></p>

<h2 id="동등성">동등성</h2>
<ul>
  <li>두 객체가 같은 정보를 가지고 있는 경우.
<br />
두 객체의 주소가 달라도 내용이 같으면 동등하다고 말할 수 있다.</li>
  <li>equals를 사용해 판별할 수 있다.</li>
  <li><strong><em>equals</em></strong>
    <ul>
      <li>equals 메소드를 재정의 하지 않으면 == 연산자와 다르지 않다.</li>
      <li>객체에서 재정의 할 경우 == 연산자를 통해 두객체가 동일하면 true를 반환하고, 다르다면 동등성을 판단한다.
  재정의 하지 않을 경우 동일성 여부만 판단하기 때문에 동등성비교가 필요하다면 꼭 재정의 해주어야 한다.</li>
    </ul>
  </li>
  <li><strong><em>hashcode?</em></strong>
    <ul>
      <li>equals를 재정의 해줄 때, hashcode도 같이 재정의하는걸 권장한다. 이유가 무엇일까?</li>
      <li>Hash Table을 사용하는 자료형일 경우 문제가 된다. 
  <br />
  동등한 객체 2개를 생성해서 Set에 담게되면 의도한 대로 담기지 않는다. 
  <br />
  Set 자료구조는 중복을 허용하지 않기 때문인데, Hash Table을 사용하는 자료형은 해싱 알고리즘을 사용한다. 해싱된 결과를 주소값으로 찾아가서 같은 자료가 있는지 확인하는데 동등한 두 객체는 다른 주소값을 가지고 있기 때문에 객체의 동등성을 위해 equals메소드와 hashcode메소드는 같이 오버라이드 되어야 지만 동등성을 보장받을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="to-do">To Do</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="자바의-접근제어자">자바의 접근제어자</h1>
<p>객체지향 패러다임에서 정보은닉이란 필요한 정보만 오픈한다는 개념이다.
<br />
자바에서는 정보은닉을 위해 접근제어자 라는 기능을 제공하여 클래스 외부에서 직접적인 접근을 허용하지 않는
변수, 메서드, 생성자를 설정할 수 있다.
<br />
<strong><em>단, 인터페이스의 접근제어자는 무조건 public 이다.</em></strong> 
<br />
인터페이스는 구현클래스가 아니라 추상클래스 이기 때문에
해당 인터페이스를 구현하는 구현클래스에서 구현이 꼭 필요하다. 그렇기 때문에 접근제어자를 생략하더라도 컴파일시 public으로 열어둔다.
<br />
또한 클래스의 접근제한은 public 과 default만 적용할 수 있다.</p>

<p><br /></p>

<ul>
  <li>
    <p><strong><em>private</em></strong>
<br />
private 으로 선언한 메서드나 변수는 해당 클래스 내에서만 접근이 가능하다.
<br />
외부에 공개되지 않으며, 외부에서는 private멤버에 직접 접근이 불가능하며 해당 객체의 public 메소드를
<br />
통해서만 접근이 가능하다.
<br />
그래서 보통 private 멤버는 클래스 내부의 세부적인 로직을 수행하는데 사용된다.
<br />
또한 생성자를 private 으로 생성하여 인스터스화를 방지할 수 있다.</p>
  </li>
  <li>
    <p><strong><em>public</em></strong>
<br />
public으로 선언된 클래스 멤버는 외부에서 접근이 가능하며, 프로그램 어디에서도 접근이 가능하다.
자바는 public메소드를 통해서만 해당 객체의 private멤버에 접근할수 있고, 따라서 public 메소드는 private 멤버와 외부사이의
인터페이스 역할을 수행한다고 할 수 있다.</p>
  </li>
  <li>
    <p><strong><em>default</em></strong>
<br />
아무것도 선언하지 않으면 default 접근자가 붙는다. 같은 패키지내에서만 접근이 가능하다.</p>
  </li>
  <li>
    <p><strong><em>protected</em></strong>
<br />
default 접근제어자 처럼 같은패키지 내에서 접근이 가능하지만, 좀더 범위가 넓다.
<br />
protected멤버는 부모 클래스에게는 public 멤버처럼 취급되며, 외부에서는 private 멤버로 취급된다.
<br />
결국 protected로 선언된 멤버는 아래와 같은 접근 영역을 가진다.</p>
    <ul>
      <li>protected를 선언한 클래스의 멤버</li>
      <li>protected를 선언한 클래스가 속한 패키지의 멤버</li>
      <li>protected를 선언한 클래스를 상속받은 자식 클래스의 멤버</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="왜-쓰는데-1">왜 쓰는데?</h2>
<ul>
  <li>클래스 내부의 데이터를 보호하기 위해</li>
  <li>객체지향에서 캡슐화 라고 부른다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="상속">상속</h1>
<p>자바의 상속(Inheritance)은 부모클래스와 자식클래스 관계에서 발생하며,
상속을 받은 자식클래스는 부모클래스의 <strong><em>private 멤버를 제외한</em></strong> 모든 멤버를 물려받아 사용할 수 있다.
<br />
만약 둘이 다른패키지에 있다면 default접근제한을 갖는 멤버도 자식클래스에서 사용이 불가능하다.
<br />
부모클래스가 변경되면 자식클래스는 영향을 받지만 반대의 경우는 영향을 주지 않는다.
<br />
또한, 자바는 다중상속을 지원하지 않으며 단일상속만 가능하다.</p>

<ul>
  <li><strong><em>Overriding</em></strong>
<br />
부모클래스의 정의된 메서드를 자식클래스에서 수정이 필요할 경우 오버라이딩을 이용한다.
<br />
오버라이딩은 <strong><em>동일한 시그니처</em></strong>를 가져야 한다.
    <ul>
      <li>동일한 시그니처 : 메서드의 이름, 매개변수, 반환타입이 같아야 하고 중괄호 안의 내용만 바뀔 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>인터페이스 상속</em></strong>
<br />
implements 키워드로 상속받을 수 있다. 일반 상속과 다르게 인터페이스는 상속은 다중상속이 가능하다.
<br />
인터페이스를 상속받은 클래스는 반드시 인터페이스의 메소드를 재정의(@Override) 해야한다.
<br />
인터페이스 상속은 보통 설계 목적으로 구현한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><strong><em>왜 쓰는데?</em></strong>
<br />
외부로부터 다형성을 보장하면서 내부구현코드를 모두 구현하지않고 공통로직을 그대로 사용할 수 있다.
<br />
이미 만들어진 클래스를 재사용할 수 있기 때문에 효율적이며, 중복코드가 많이 줄어들게 된다.
<br />
또한 부모클래스 멤버를 사용할 경우, 수정이 필요할 때 부모클래스만 수정하면 되기때문에 유지보수에 좋다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="nc">String</span> <span class="n">age</span><span class="o">;</span>
      <span class="nc">String</span> <span class="n">gender</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">studentId</span><span class="o">;</span>
  <span class="o">}</span> 
</code></pre></div>    </div>
    <p>학생과 사람의 클래스이다. 학생도 사람이기 때문에 Person클래스가 가지는 속성을 모두 가지고 있다.
<br />
공통적인 기능을 부모클래스에 정의해두면 여러개의 자식클래스에서 사용이 가능하기때문에 확장성 또한 용이하다.
<br />
학생 클래스에서 이름 나이 성별을 정의하지 않았지만 super 키워드로 부모클래스로부터 물려받은 속성에 접근할 수 있다.
<br />
이처럼, 상속을 이용할 경우 유지보수가 좋아지고 확장성이 좋아지며 중복코드를 많이 줄일 수 있게 된다.</p>
  </li>
</ul>

<p><br /></p>
<ul>
  <li><strong><em>단점</em></strong>
<br />
    <ul>
      <li>자식클래스에서도 부모클래스의 public메서드가 외부로 노출되기 때문에 이는 <strong><em>캡슐화</em></strong>를 위반할 수 있다.</li>
      <li>클래스 간의 결합도가 높아진다.</li>
      <li>부모클래스의 버그가 생길경우, 자식클래스에 어떠한 사이드이펙트가 갈지 예측하기 어렵다.</li>
      <li>상속 구조가 복잡해 질수록 상위 클래스에서 의미있던 기능이 하위클래스에서 필요없는 기능일 수 있다.</li>
      <li>상속으로 인해 결합도가 높아질 수록 하나의 기능을 추가하거나 수정하기위해 불필요하게 많은 클래스를 추가하거나 수정해야 한다.</li>
      <li>그로인해 단일상속만 지원하는 자바에서는 오히려 중복코드의 양이 늘어날 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>어떻게 쓰면 좋을까?</em></strong>
<br />
SOLID원칙의 리스코프치환 원칙에서 알 수 있다.
<br />
<strong><em>상속받은 자식클래스는 부모클래스를 대체할 수 있을 경우에만 상속을 해야한다.</em></strong>
<br />
부모클래스의 외부로 노출되는 메서드는 자식클래스 에도 같은 의미로 제공되어야 한다고 말하고 있다. 
<br />
즉, 상속은 클래스의 행동을 확장하는 것이 아닌 정제할 때 사용하는것이 좋다.
<br />
또한 재정의 되지 않길 원하는 메서드일 경우 final 메서드로 만들어 두는것도 좋은 방법이겠다.</li>
</ul>

<p><br /></p>

<h2 id="합성compotistion">합성(Compotistion)</h2>
<p>구현에 의존하지 않고, public interface에만 의존한다.객체 관계가 수평적인 관계가 된다.</p>
<ul>
  <li>두 객체 사이 의존성을 런타임에 해결한다. (상속은 컴파일단계에서 해결)</li>
  <li>코드의 재사용만 생각하면 상속보다는 합성을 사용하는게 좋을 수 있다.</li>
  <li>상속의 is-a 관계가 아닌 has-a관계
    <ul>
      <li><strong><em>is-a</em></strong>
        <ul>
          <li>A는 B이다. -&gt; 학생은 사람이다.</li>
          <li>추상화 사이의 포함관계를 의미한다.</li>
          <li>한 클래스 A가 다른 클래스 B의 파생클래스임을 나타낸다.</li>
          <li>is-a 관계를 통해 생성된 클래스는 상속관계에서 밀접하게 결합된다.</li>
          <li>결합도가 높기 때문에 계층구조에 좀 더 적합하다.</li>
        </ul>
      </li>
      <li><strong><em>has-a</em></strong>
        <ul>
          <li>구성 포함 관계를 의미한다. -&gt; 경찰은 총을 가진다 (경찰클래스 안에 권총클래스의 객체를 멤버로 가지고 있는 경우)</li>
          <li>한 오브젝트가 다른 오브젝트에 속한다 라고 말한다.</li>
          <li>다른 클래스의 기능(변수 혹은 메서드)를 받아들여 사용한다.</li>
          <li>객체의 멤버필드라고 불리는 객체를 말하며 계층구조를 형성하기위해 결합하는 경우를 말한다.</li>
          <li>has-a 관계를 통해 생성된 클래스는 느슨하게 결합된다.</li>
          <li>상속에 비해 변경이 발생하더라도 구성요소를 쉽게 변경할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="전략패턴strategy-pattern">전략패턴(Strategy Pattern)</h3>
<hr />
<p>합성을 이용한 디자인 패턴으로 프로그램 실행중에 알고리즘을 선택할 수 있게하는 패턴이다. 
<br />
즉, 특정 Context에서 알고리즘을 별도로 분리하는 설계 방법이다.
<br />
변하지 않는 부분을 Context에 두고 변하는 부분을 Strategy 인터페이스 구현체에 작성한다.
<br />
전략에 해당하는 Strategy인터페이스와 구현체에는 비즈니스 로직 이외에 아무런 로직이 없기때문에 공통 로직이 변경되어도 아무런 영향이 없다.
<br /><br />
<img src="/images/2021-05-10-first-posting/Strategy_Pattern.png" alt="이미지" />
<br />
<br /></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>런타임에 객체 내부의 알고리즘을 바꿀 수 있다.</li>
      <li>공통로직이 부모클래스에 있지 않고 Context라는 별도의 클래스에 존재하기 떄문에 구현체들에 대한 영향도가 적다.</li>
      <li>Context 가 Strategy 라는 인터페이스를 의존하고 있기 때문에 구현체를 갈아끼우기 쉽다.</li>
      <li>결국 확장에 유리하다.</li>
      <li>단일책임원칙을 지키면서 새로운 전략을 추가할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>클래스로 분리된 전략에 대해 모두 알아야 한다.</li>
      <li>알고리즘 변경이 많지 않다면, 오히려 분기를 타는것보다 코드를 복잡하게 만들 수 있다.</li>
      <li>로직이 늘어날때마다 구현클래스가 늘어난다.</li>
    </ul>

    <p><br /></p>
  </li>
  <li><strong><em>어떻게 쓰는데?</em></strong>
<br />
  과일매장은 상황에 따라 다른 가격할인정책을 적용하고 있다.
    <ul>
      <li>첫손님에게 10% 할인</li>
      <li>마지막손님은 20% 할인</li>
      <li>신선도가 떨어진 과일은 20%할인
  <br />
  <br /></li>
    </ul>

    <p>할인이라는 알고리즘을 <code class="language-plaintext highlighter-rouge">DiscountPolicy</code>라는 인터페이스로 분리해보자.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DiscountPolicy</span> <span class="o">{</span>
      <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstCustomerDiscount</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.9</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">LastCustomerDiscount</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span><span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnFreshFruitDiscount</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span><span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <p>그리고 이를 <code class="language-plaintext highlighter-rouge">Calculator</code>클래스에서 생성자를 통해 필요한 하위타입을 주입받아 사용해보자.
  <br />
  이렇게 되는 경우 외부에서 특정 경우(첫번째 손님, 마지막 손님, 싱싱하지 않은 과일)에 대한 할인정책을 생성자를 통해 전달해줄 수 있다.
  <br /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculator</span> <span class="o">{</span>
		
      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DiscountPolicy</span> <span class="n">discountPolicy</span><span class="o">;</span>
		
      <span class="kd">public</span> <span class="nf">Calculator</span><span class="o">(</span><span class="nc">DiscountPolicy</span> <span class="n">discountPolicy</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">discountPolicy</span> <span class="o">=</span> <span class="n">discountPolicy</span><span class="o">;</span>
      <span class="o">}</span>
		
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
          <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
          <span class="k">for</span> <span class="o">(</span><span class="nc">Item</span> <span class="n">item</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">sum</span> <span class="o">+=</span> <span class="n">discountPolicy</span><span class="o">.</span><span class="na">calculateWithDisCountRate</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <p>아래의 경우는 첫번째 손님 할인정책을 적용하는 코드이다. 
  <br />
  일반적으로 Controller는 사용자의 요청 등을 매핑하여 받아오기 때문에 특정 알고리즘(첫번째 손님 계산)을 선택되었다는걸 알 수 있다.
  <br />
  요청에 맞는 객체를 Calculator에 주입해주는 방식을 통해 전략패턴을 구현했다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitController</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Calculator</span> <span class="n">calculator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Calculator</span><span class="o">(</span><span class="k">new</span> <span class="nc">FirstCustomerDiscount</span><span class="o">());</span>
          <span class="n">calculator</span><span class="o">.</span><span class="na">calculate</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="mi">3000</span><span class="o">),</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">,</span> <span class="mi">3000</span><span class="o">),</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">),</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Pitch"</span><span class="o">,</span> <span class="mi">4000</span><span class="o">)</span>
          <span class="o">));</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h2 id="상속-vs-합성">상속 vs 합성?</h2>
<p>상속은 is-a, 합성은 has-a
<br />
결국, 코드의 재사용성 만을 위해 상속을 사용하는 방식은 여러 문제점을 가지고 있기 때문에 재사용성 뿐만 아니라 클래스간의 확실한 계층구조를 만들때 상속을 사용하며 그 외에는 의존성이 낮은 합성을 사용하는 것이 좋다고 생각이 든다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="다형성">다형성</h1>
<p>변화에 유연한 소프트웨어를 만들기 위한 객체지향 패러다임의 가장 중추적인 방법이다.
<br />
<code class="language-plaintext highlighter-rouge">다형성</code>이란 하나의 타입에 여러 객체를 대입할 수 있는 성질이고, 이것을 위해서 여러 객체들중 공통 특성으로
타입을 추상화하고 그것을 상속 또는 인터페이스라면 구현해야한다.
<br /></p>
<ul>
  <li><strong><em>업캐스팅</em></strong>
    <ul>
      <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 해준다.</li>
      <li>부모클래스의 인스턴스 대신 자식클래스의 인스턴스를 사용해도 메시지를 처리하는데 문제가 없으며, 컴파일러는 명시적인 타입변환 없이도 자식클래스가 부모클래스를 대체할 수 있게 허용한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>동적 바인딩</em></strong>
    <ul>
      <li>메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다.</li>
      <li>이와같이 런타임에 실행될 메서드를 결정하는 방식을 동적바인딩 혹은 지연바인딩 이라고 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><strong><em>오버로딩(Overloading)</em></strong>
  <br />
  자바 <code class="language-plaintext highlighter-rouge">PrintStream</code> 클래스에는 매개변수만 다른 <code class="language-plaintext highlighter-rouge">println</code>이라는 메서드가 여러개 정의되어 있다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintStream</span> <span class="o">{</span>
      <span class="o">...</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">()</span> <span class="o">{</span>
          <span class="n">newLine</span><span class="o">();</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
              <span class="n">newLine</span><span class="o">();</span>
          <span class="o">}</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="kt">char</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
              <span class="n">newLine</span><span class="o">();</span>
          <span class="o">}</span>
      <span class="o">}</span>
      <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>매개변수로 어떤 타입을 넣어주든, 모두 <code class="language-plaintext highlighter-rouge">println</code>이라는 메서드 시그니처를 호출하여 원하는 내용을 출력하는 기능을 수행한다.</li>
      <li>오버로딩은 여러종류의 타입을 받아 같은 기능을 하도록 만들기 위함이고 런타임 시점에 특정 메서드를 바인딩 할수 있다.</li>
      <li>즉, 다형성 이라고 할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>오버라이딩(Overriding)</em></strong>
  <br />
  앞서 상속에서도 정리했던 오버라이딩은 부모클래스의 메서드를 하위클래스에서 재정의 하는것을 의미한다.
  <br />
  <br />
  아래 <code class="language-plaintext highlighter-rouge">Figure</code>라는 추상클래스에서는 하위 클래스에서 오버라이딩 해야할 메서드를 정의해 두었다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
      <span class="kd">protected</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">;</span>
      <span class="kd">protected</span> <span class="kt">int</span> <span class="n">area</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Figure</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">dot</span> <span class="o">=</span> <span class="n">dot</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">area</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">Figure</code>를 상속받는 하위클래스 들이다.</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Triangle</span> <span class="kd">extends</span> <span class="nc">Figure</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="nf">Triangle</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">super</span><span class="o">(</span><span class="n">dot</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"넓이가 %d인 삼각형입니다."</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="nc">Figure</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="nf">Square</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">super</span><span class="o">(</span><span class="n">dot</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"넓이가 %d인 사각형입니다."</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
    <ul>
      <li>이런식으로 새로운 도형 객체가 추가될 때 <code class="language-plaintext highlighter-rouge">Figure</code>를 상속받고 메서드를 재정의 해주면 실제로 사용되는 비즈니스로직의 변경을 최소화 할 수 있다.</li>
      <li>다형성을 사용하지 않고 도형 객체를 추가하려고 하면 if-else 분기가 늘어나게 되버린다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>함수형 인터페이스(Funtional Interface)</em></strong>
  <br />
  람다식을 사용하기 위한 API로 자바에서 제공하는 인터페이스에 구현할 메서드가 하나 뿐인 인터페이스 이다.
  <br />
  <code class="language-plaintext highlighter-rouge">enum</code>과 함께 사용할 시 다형성의 장점을 경험할 수 있다.
  <br />
  <br />
  문자열 계산기 이다.
  <br />
  각각의 연산자를 <code class="language-plaintext highlighter-rouge">enum</code>으로 정의하고 연산 방식을 <code class="language-plaintext highlighter-rouge">BiFuntion</code>을 사용한 람다식으로 정의한다면 연산자를 추가 해야 할 때, <code class="language-plaintext highlighter-rouge">enum</code>에만 추가해주면 실제로 연산을 수행하는 <code class="language-plaintext highlighter-rouge">calculate</code> 메서드는 아무 수정없이 기능확장을 할 수 있다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Operator</span> <span class="o">{</span>
      <span class="no">PLUS</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">),</span>
      <span class="no">MINUS</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">),</span>
      <span class="no">MULTIPLY</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">),</span>
      <span class="no">DIVIDE</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">);</span>

      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">sign</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BiFunction</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">bi</span><span class="o">;</span>

      <span class="nc">Operator</span><span class="o">(</span><span class="nc">String</span> <span class="n">sign</span><span class="o">,</span> <span class="nc">BiFunction</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">bi</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">bi</span> <span class="o">=</span> <span class="n">bi</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">,</span> <span class="nc">String</span> <span class="n">sign</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Operator</span> <span class="n">operator</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">.</span><span class="na">sign</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">sign</span><span class="o">))</span>
                  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(</span><span class="nl">IllegalArgumentException:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>

          <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="na">bi</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="접근제어자" /><category term="상속" /><category term="다형성" /><category term="Wrapper Class" /><summary type="html"><![CDATA[]]></summary></entry></feed>