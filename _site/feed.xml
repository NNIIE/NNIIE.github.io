<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-09T02:36:52+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">4주차</title><link href="http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="4주차" /><published>2023-01-05T00:00:00+09:00</published><updated>2023-01-05T00:00:00+09:00</updated><id>http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/4%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="today-i-learned">Today I Learned</h1>

<h2 id="cqrs-pattern">CQRS Pattern</h2>
<p>(씨큐에스) : 아키텍쳐 패턴이다. 쿼리할때는 커맨드가 발생하면 안되고 어쩌고~ 커맨드부터 알아보자 하지만 간단하게 알아보자.</p>

<p><br /></p>

<h2 id="generic">Generic</h2>
<p>아주 유용한 문법이고 대부분 최신 언어에선 사용한다.
<br />
타입시스템을 더 견고하게 사용하기 위해 제네릭을 사용한다</p>

<ul>
  <li>타입시스템이란? 그리고 자바의 타입시스템</li>
  <li>타입을 재사용하고 싶어서? -&gt; 이유는 제네릭 다이아몬드 문법 안에 어쩌고?</li>
  <li>공변? 반공변?
    <ul>
      <li>무엇인지 정도만</li>
    </ul>
  </li>
  <li>자바는 공변설정이 약하다?</li>
  <li>평소 우리가 제네릭을 제일많이 쓰는곳은 Map&lt;Integer, Integer&gt; 같은거</li>
  <li>자바는 강타입 언어 자바스크립트는 약타입 언어
    <ul>
      <li>자바는 서버언어로 쓰는데 서버는 다르다… 안정성이 제일 중요하다?
        <ul>
          <li>왜냐하면 서버에서 고치는것보다 컴파일단계에서 서버에 올라가기 전에 고치는게 훨씬 좋다 -&gt; 그래서 최대한 빠른단계에서(컴파일) 실수를 잡는게 좋다. 디비에 올라간거 고치기 힘들잖아</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자바는 컴파일 통과하면 런타임에선 타입정보가 다 지워진다. 그래서 제네릭으로 파라미터를 받으면 파라미터의 타입정보가 없다?</li>
</ul>

<p><br /></p>

<h2 id="시간공간-복잡도의-상관관계">시간/공간 복잡도의 상관관계</h2>
<ul>
  <li>시간복잡도 : 특정크기의 연산에 걸리는 절대적인 시간 즉, 연산 횟수</li>
  <li>공간복잡도 : 특정크기의 연산에 드는 메모리 사용량</li>
</ul>

<p><br />
우리가 하는 거의 모든 작업들은 시간복잡도와 공간복잡도를 서로 교환 한다.
<br />
물론 이 둘이 모든 상황에서 정 반대에 있는건 아니다.</p>

<p><br /></p>

<h3 id="caching">Caching</h3>
<hr />
<ul>
  <li>시간복잡도의 리소스를 공간복잡도의 리소스로 바꾸는거다.</li>
  <li><code class="language-plaintext highlighter-rouge">redis</code>를 사용 해서 데이터를 보다 빠르게 조회할 수 있다면 그만큼 탐색범위를 줄여 시간복잡도를
<br />
줄일 수 있지만 그만큼 캐싱에 들어가는 메모리를 사용해서 공간복잡도는 올라가게 된다.</li>
</ul>

<p><br /></p>

<h3 id="hashmap">HashMap</h3>
<hr />
<ul>
  <li>해시알고리즘으로 만든 key를 메모리에 올려두고 그 key값만 찾아가면 되기때문에 데이터 크기에 상관 없이 시간복잡도가 O(1)인 대신 그만큼 key값을 저장하는 메모리 공간을 사용하기 때문에 공간복잡도는 올라간다.</li>
</ul>

<p><br /></p>

<h3 id="만약-메모리가-부족하다면">만약 메모리가 부족하다면?</h3>
<hr />
<p>메모리를 적게 써야하는 상황이라면 공간복잡도를 줄여서 시간을 많이쓰는
<br />
즉, 탐색을 더해서 시간복잡도를 올려야 한다.</p>

<p><br /></p>

<h3 id="의문점">의문점</h3>
<hr />
<p>보통 공간복잡도 보다 시간복잡도를 더 우위에 두고 작업을 하기 마련이다.
<br />
그렇다면 그 이유는 과거에 비해 하드웨어의 발전이 많이 이루어 졌기 때문이고
<br />
웹 어플리케이션의 등장으로 request / response의 단순함으로 인해 
<br />
메모리에 올려둔 객체들의 생명주기가 짧아져 가비지컬렉터에 의해 금방금방 지워지기 때문일까?</p>

<hr />

<p>틀린 접근은 아니다. 세상이 발전함에 따라 과거보다 현재 시간복잡도가 더 중요하게 되었다.</p>
<ul>
  <li>하드웨어의 폭발적인 발전</li>
  <li>멀티코어를 통한 동시성 개발</li>
  <li>request / response 사이클로 인한 짧은 객체의 생명주기</li>
</ul>

<p>하지만 우리가 접할 기회가 흔한건 아니지만
<br />
여전히 공간복잡도의 한계가 있는 경우가 있다.</p>

<ul>
  <li>빅데이터</li>
  <li>백데이터의 크기
    <ul>
      <li>ex) 구글이 검색을 제공하기 위한 백데이터의 크기</li>
    </ul>
  </li>
  <li>머신러닝이 학습하는 학습데이터는 거대한 메모리를 사용할까? 오랜 학습시간을 들일까?</li>
</ul>

<hr />

<p>명확하지 않은 결론을 내리자면,
<br />
우리는 현재는 시간복잡도를 더 우선해서 경감하는게 더 장점이 많은 시대에 살고있고 
<br />
현업에서 어떠한 규칙으로 삼아도 될 정도이지만 몇십만명이 될지도 모르는 회원정보를 
<br />
<code class="language-plaintext highlighter-rouge">redis</code>에 올리지 않는 것처럼 경우에 따라 적절하게 사용하는것이 중요하겠다.</p>

<p><br /></p>

<h1 id="to-do">To Do</h1>

<h2 id="nested-class">Nested Class</h2>
<p>중첩클래스(nested class)는 클래스 내에 정의된 클래스를 말한다. 
<br />
중첩클래스는 <code class="language-plaintext highlighter-rouge">static</code>으로 선언되지 않은 내부클래스(inner class)와
<br />
<code class="language-plaintext highlighter-rouge">static</code>으로 선언된 정적 클래스(static class)로 나뉜다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">class</span> <span class="nc">NestedClass</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="inner-class">Inner Class</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

	<span class="kd">private</span> <span class="kd">class</span> <span class="nc">InnerClass</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"OuterClass.a = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>를 인스턴스화 하려면 외부 클래스를 먼저 인스턴스화 해야 한다.
    <ul>
      <li>외부클래스와 <code class="language-plaintext highlighter-rouge">innerClass</code> 두 객체의 참조값은 서로 다르다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 자신을 둘러싼 외부 클래스의 인스턴스 변수 / 메서드에 접근할 수 있다.
    <ul>
      <li>외부클래스 인스턴스에 대한 외부참조를 가지기 때문이다.
        <ul>
          <li>따라서 가비지컬렉션이 수거하지못해 <code class="language-plaintext highlighter-rouge">memory leak</code>의 위험성이 존재한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>외부클래스에선 <code class="language-plaintext highlighter-rouge">inner class</code> 멤버를 사용할수 없다. (사용하려면 객체를 직접 발생시켜야함)</li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 외부클래스의 멤버와 동일한 이름을 사용할 경우 외부클래스 멤버에 접근하고 싶으면 
<br />
명시적으로 나타내야 한다. (OuterClass.this.a)</li>
  <li>외부클래스의 <code class="language-plaintext highlighter-rouge">private</code> 멤버에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 외부 클래스의 멤버이므로 접근제한자를 사용할 수 있다.</li>
  <li>정적 멤버선언(static)이 불가능하다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">final</code>키워드를 사용하면 가능하다.</li>
      <li>자바 16 이후부터는 <code class="language-plaintext highlighter-rouge">inner class</code>에서 정적멤버 생성이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="static-inner-class">Static Inner Class</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OuterClass</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">static</span> <span class="kd">class</span> <span class="nc">StaticInnerClass</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>같은 <code class="language-plaintext highlighter-rouge">static inner class</code>의 객체를 2개 만들어도 두 객체의 참조값은 서로 다르다.</li>
  <li>정적클래스는 외부 클래스를 인스턴스화 할 필요가 없기 때문에 외부클래스의 변수 / 메서드에 접근할 수 없다. 
<br />
(외부클래스의 static 멤버만 접근 가능)</li>
  <li>정적클래스 내부에서 <code class="language-plaintext highlighter-rouge">static</code> 멤버를 사용할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="익명클래스">익명클래스</h3>
<hr />
<p>펑션을 상속받는? 이름이 없는 로컬클래스.
<br />
이름이 없기 때문에 익명클래스는 객체를 여러번 생성할 수 없으며 생성자를 만들수도 없다.
<br />
클래스가 딱 한번만 필요할 때 유용하다.</p>

<p><br /></p>

<h3 id="lambda">Lambda</h3>
<hr />

<p><br /></p>

<h3 id="활용">활용</h3>
<hr />
<ul>
  <li><code class="language-plaintext highlighter-rouge">inner class</code>는 참조값을 담아야 하기 때문에 인스턴스 생성시 시간,공간적으로 성능이 낮아진다.</li>
  <li><code class="language-plaintext highlighter-rouge">static inner class</code>는 외부 인스턴스에 대한 참조가 존재하기 때문에, 
<br />
<strong><em>가비지 컬렉션이 인스턴스 수거를 하지 못하여 memory leak이 생길 수 있다.</em></strong></li>
  <li><code class="language-plaintext highlighter-rouge">static inner class</code>를 사용하는 것이 좋으며 <code class="language-plaintext highlighter-rouge">static</code> 키워드를 사용하고싶지 않으면 별개의 클래스로 만드는 것이 좋다.</li>
  <li>하지만 <strong><em>Lambda</em></strong> 의 경우 얘기가 조금 달라지는데…</li>
</ul>

<p><br /></p>

<h3 id="의문점-1">의문점</h3>
<hr />
<ul>
  <li><strong><em>Lambda</em></strong> 로 파라미터를 넘기면 그건 객체, 그게 바로 익명클래스라는데 알아보자</li>
  <li><strong><em>Lambda</em></strong> 는 일종의 <code class="language-plaintext highlighter-rouge">inner class</code> 인데 가비지컬렉터의 메모리 누수에는 안전하다 알아보자
    <ul>
      <li>객체는 또 다르다던데?</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="collection">Collection</h2>

<p><br /></p>

<h2 id="중복">중복</h2>
<h3 id="중복이-나쁜경우">중복이 나쁜경우</h3>
<hr />
<h3 id="중복이-차라리-나은경우">중복이 차라리 나은경우</h3>
<hr />

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Generic" /><category term="시공간복잡도" /><category term="Nested Class" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">3주차</title><link href="http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="3주차" /><published>2022-12-29T00:00:00+09:00</published><updated>2022-12-29T00:00:00+09:00</updated><id>http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/3%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="today-i-learned">Today I Learned</h1>

<h2 id="property">Property</h2>
<p>속성이란 뜻이다. 해당 <code class="language-plaintext highlighter-rouge">Object</code>의 특징.
<br />
사람을 예로들면 피부색, 키, 나이, 몸무게 등이다.
<br />
Property의 읽기와 쓰기는 일반적으로 <code class="language-plaintext highlighter-rouge">getter</code> 와 <code class="language-plaintext highlighter-rouge">setter</code> 메서드 호출로 변환된다.</p>
<ul>
  <li>자바는 property가 없고 코틀린이나 자바스크립트는 property를 사용 이건 왜그래?</li>
</ul>

<p><br /></p>

<h2 id="string">String</h2>
<p>자바에서 제일 많이 사용되는 String은 <strong>특별대우</strong>를 받는다.
<br />
Reference Type 이지만 기본적인 사용은 Primitive Type 이다.
<br />
String 객체생성은 2가지 방법이 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"kim"</span><span class="o">;</span>			<span class="c1">// 리터럴로 생성</span>
<span class="nc">String</span> <span class="n">name2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"lee"</span><span class="o">);</span>	<span class="c1">// new 연산자로 생성</span>
</code></pre></div></div>
<ul>
  <li><strong>new</strong> : 일반 객체들처럼 힙 영역에 할당된다.</li>
  <li><strong>리터럴</strong> : <code class="language-plaintext highlighter-rouge">Constant Pool</code> 영역에 할당된다.
    <ul>
      <li>String의 intern()메서드를 호출한다.
        <ul>
          <li>intern() 메서드 : <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 생성하려는 문자열이 존재할 경우 주소값을 반환하고 
  <br />
  없으면 객체 생성 후 주소값을 반환한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="constant-pool">Constant Pool</h3>
<hr />
<p>문자열 리터럴을 사용해서 생성한 String 객체가 담기는 곳이며 자바8 이후 힙 영역에 속한다.
<br />
같은 문자열을 각각 2개씩 리터럴과 new연산자로 생성했을 때, new 연산자로 생성된 문자열은 서로 다른객체를 만들고 바라보지만 리터럴로 생성해 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에 담긴 두 객체는 동일한 객체를 바라본다.</p>

<p><br /></p>

<h3 id="string은-불변immutable하고-thread-safe-하다">String은 불변(immutable)하고 thread-safe 하다.</h3>
<hr />
<p>문자열 리터럴은 불변이기 때문에 <code class="language-plaintext highlighter-rouge">Constant Pool</code>에서 문자열이 같다면 동일한 객체를 참조할 수 있다.</p>
<ul>
  <li><strong><em>static String?</em></strong>
<br />
  두개의 클래스의 각각 <code class="language-plaintext highlighter-rouge">static String abc = "abc";</code> 를 선언하고
  해시코드 값을 출력해보면 동일하다.
  <br />
  즉, <code class="language-plaintext highlighter-rouge">static</code> 으로 선언해도 동일성과 동등성이 보장된다.</li>
</ul>

<p><br /></p>

<h3 id="string-연산">String 연산</h3>
<hr />
<p><code class="language-plaintext highlighter-rouge">Constant Pool</code>의 특성 때문에 연산을 하게되서 문자열이 변경될 경우 기존 객체는 불변이기 때문에 새로운 객체를 만들고 해당 객체를 참조한다. 그리고 곧 참조가 사라진 기존 문자열은 가비지컬렉터의 수집 대상이 된다.
<br />
그렇기 때문에 문자열의 <code class="language-plaintext highlighter-rouge">+ 연산</code> 또는 <code class="language-plaintext highlighter-rouge">concat 연산</code> 은 좋지 않다.
<br />
아래 두 클래스는 내부 Buffer에 문자열을 저장해두고 그 안에서 추가,수정,삭제 등을 작업할 수 있다.</p>

<ul>
  <li><strong>StringBuffer</strong>
    <ul>
      <li>StringBuilder 보다 성능이 좋지 않다.</li>
      <li>동기화를 지원하여 thread-safe 하다.</li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuilder</strong>
    <ul>
      <li>StringBuffer 보다 성능이 좋다</li>
      <li>동기화를 지원하지 않아 thread-safe 하지 않다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="활용">활용</h4>
<hr />
<p>새로운 객체를 만들지 않고 문자열을 수정할 수 있기 때문에 참조가 끊어진 String 객체가
<br />
가비지컬렉션에 의해 메모리 해제를 기다리지 않아도 된다.
<br />
하지만 buffer의 크기를 초기에 설정해줘야 해서 생성속도가 String 객체보다 느리고 read가 느리다.
<br />
문자열 수정을 할 경우에도 Buffer의 크기를 줄이고 늘리고 명칭을 변경하는 등의 연산이 필요하다.</p>

<ul>
  <li><strong>String</strong>
    <ul>
      <li>문자열의 연산이 적을 경우</li>
      <li>빠른 조회 성능을 기대해야 할때</li>
      <li>문자열 연산이 적고 멀티스레드 환경일 경우</li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuffer</strong>
    <ul>
      <li>문자열 연산이 많을 경우</li>
      <li>thread-safe 이 필요한 경우
        <ul>
          <li>멀티스레드 환경</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li><strong>StringBuilder</strong>
    <ul>
      <li>문자열 연산이 많을 경우</li>
      <li>thread-safe 이 필요하지 않은 경우
        <ul>
          <li>단일스레드 환경</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="jdk-15-이후">JDK 1.5 이후</h4>
<hr />
<p>자바 1.5 이후  String의 <code class="language-plaintext highlighter-rouge">immutable</code>속성의 문제점을 해결하기 위해 도입되었다.
<br />
그래서 자바 1.5 이후 <code class="language-plaintext highlighter-rouge">한줄 +</code> 연산시 자동으로 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 로 자동변환되어 성능 최적화를 이뤘다.
<br />
하지만 <code class="language-plaintext highlighter-rouge">여러줄 +</code> 연산할 경우 매 연산마다 새로운 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 객체를 선언한다.
<br />
또한 for문 같은 반복문같은 경우에도 컴파일러가 최적화를 해주지 못하고 있다.
<br />
추가로 <code class="language-plaintext highlighter-rouge">concat</code> 연산은 컴파일러가 아예 최적화를 해주지 못한다.
<br />
그냥 문자열 연산에는 <code class="language-plaintext highlighter-rouge">StringBuffer / StringBuilder</code> 를 쓰도록 하자.</p>

<p><br /></p>

<h2 id="annotation">Annotation</h2>
<p><code class="language-plaintext highlighter-rouge">Annotation</code> 의 사전적인 의미로는 주석이다.
<br />
자바에서는 코드사이에 주석처럼 쓰여서 특별한 의미, 기능을 수행하도록 한다.
<br />
프로그램에게 추가정보를 제공해주는 메타데이터라고 볼 수 있다.
<br />
이 클래스에게 어떤 역할을 줄까? 이 속성을 어떤용도로 사용할까?</p>

<ul>
  <li>메타데이터 : 데이터를 위한 데이터</li>
</ul>

<p><br /></p>

<h3 id="용도">용도</h3>
<hr />
<ul>
  <li>컴파일러에게 에러를 체크하도록 정보 제공</li>
  <li>빌드나 패치 시 코드를 자동으로 생성할 수 있도록 정보 제공</li>
  <li>런타임단계에서 특정 기능을 실행하도록 정보 제공</li>
</ul>

<p><br /></p>

<h3 id="설정">설정</h3>
<hr />
<ul>
  <li><strong>@Target</strong> : 적용대상
    <ul>
      <li>어디(클래스, 필드, 메서드…)에 <code class="language-plaintext highlighter-rouge">Annotation</code> 을 적용할지</li>
    </ul>
  </li>
  <li><strong>@Retention</strong> : 정보유지되는 대상
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Annotation</code> 값들을 언제까지 유지할 것인지 (대부분 Runtime)</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="왜쓰는데">왜쓰는데?</h3>
<hr />
<p><code class="language-plaintext highlighter-rouge">Annotation</code> 을 붙일 타겟과 유지시기 등을 설정해 자신이 원하는 용도로 활용이 가능하다.
<br />
이것은 비즈니스 로직과는 별도로 시스템 설정과 관련된 부가적인 사항들을 <code class="language-plaintext highlighter-rouge">Annotation</code>
<br />
에게 위임하고 개발자는 비즈니스 로직 구현에만 집중할 수 있도록 하는 일종의 <code class="language-plaintext highlighter-rouge">AOP</code>
<br />
즉, <code class="language-plaintext highlighter-rouge">Annotation</code> 을 사용함으로써 관심사의 분리를 가능하게 한다는 의미기도 하다.</p>

<p><br /></p>

<h1 id="to-do">To Do</h1>

<p><br /></p>

<h2 id="exception">Exception</h2>
<p>예외는 기본적으로 폭탄돌리기와 같다.
<br />
처리하거나 처리 <code class="language-plaintext highlighter-rouge">try catch</code> 할 수 없다면 <code class="language-plaintext highlighter-rouge">throw</code> 즉, 던져야 한다.
<br />
예외를 처리하지 못하고 계속 던지게 되면 결국 메인메서드까지 던져지게 되고 결국 어플리케이션이 종료된다.</p>

<p><img src="/images/2021-05-10-first-posting/exception%EA%B3%84%EC%B8%B5.png" alt="이미지" /></p>

<ul>
  <li>
    <p>Throwable : 최상위 예외 이며, 객체이기 때문에 <code class="language-plaintext highlighter-rouge">Object</code>를 상속받는다.</p>
  </li>
  <li>
    <p>Error : 메모리부족, 시스템 오류같은 어플리케이션 레벨에서 복구가 불가능한 시스템 장애이다.
<br />
<code class="language-plaintext highlighter-rouge">Exception</code>과 <code class="language-plaintext highlighter-rouge">Error</code>는 다르다</p>
  </li>
  <li>
    <p><strong><em>상위 예외를 잡으면 하위 예외까지</em></strong> 잡아버리기 때문에 어플리케이션에선 <code class="language-plaintext highlighter-rouge">Exception</code> 예외부터 필요한 예외로 잡아야 한다.
<br />
또한, <code class="language-plaintext highlighter-rouge">Layer</code>에 역할에 맞는 <code class="language-plaintext highlighter-rouge">Exception</code>을 던질 필요가 있다.</p>
  </li>
</ul>

<p><br /></p>

<h3 id="checked-exception"><strong><em>Checked Exception</em></strong></h3>
<hr />
<p><code class="language-plaintext highlighter-rouge">Exception</code>을 상속받는 예외는 <code class="language-plaintext highlighter-rouge">checked exception</code>이 되며 <code class="language-plaintext highlighter-rouge">Exception</code>은 어플리케이션에서 사용할 수 있는 실질적인 최상위 예외이다. 컴파일러가 체크하며 잡아서 처리하거나, 또는 밖으로 던지도록 선언해야 한다.
<br />
예외 발생 시 트랜잭션 <code class="language-plaintext highlighter-rouge">roll-back</code> 처리를 하지 않는다. 
<br />
(복구가 가능하다는 매커니즘을 가지고 있기 때문에 복구를 하라고 하고 롤백은 처리하지 않겠다 아닐까?)
<br />
<strong><em>단, RuntimeException을 상속받는 경우 unchecked exception이 된다.</em></strong></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>예외를 처리하거나 밖으로 던지는 <code class="language-plaintext highlighter-rouge">throw</code> 를 필수로 선언해야 컴파일 오류가 발생하지 않기 때문에 
  <br />
  개발자가 실수로 누락하는 상황이 발생하지 않는다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>모든 체크예외를 반드시 잡거나 던지도록 처리해야 한다.</li>
      <li>의존관계 문제가 발생한다.
        <ul>
          <li>예를들어 <code class="language-plaintext highlighter-rouge">Controller / Service</code> 등에서 SQL예외를 던졌을때 해당 클래스에서 <code class="language-plaintext highlighter-rouge">SQLException</code>을 의존하게 된다. 이럴경우 JDBC가 아닌 JPA같은 기술로 변경할 시 모든 코드를 고쳐야한다. 
  <br />
  즉, <code class="language-plaintext highlighter-rouge">OCP / DI</code>를 위반한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong><em>활용</em></strong>
<br />
  기본적으로 <code class="language-plaintext highlighter-rouge">unecked exception</code>을 사용하자. <code class="language-plaintext highlighter-rouge">checked exception</code>은 비즈니스 로직상 반드시 처리해야 하는 경우에만 (계좌 이체 실패, 결제시 포인트 부족 등)
  <br />
  즉, 개발자가 실수로 놓치게 되면 치명적인 문제가 발생하는 경우에 컴파일러의 도움을 받기위해 사용하자.
  <br />
  또한, <code class="language-plaintext highlighter-rouge">catch</code> 절에서 딱히 할일이 없을 경우 사용하지 말고 확실히 할일이 있는 경우에 사용하자</p>
  </li>
  <li>대표적인 <code class="language-plaintext highlighter-rouge">Exception</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">IOException</code></li>
      <li><code class="language-plaintext highlighter-rouge">SQLException</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="unchecked-exception"><strong><em>UnChecked Exception</em></strong></h3>
<hr />
<p><code class="language-plaintext highlighter-rouge">RuntimeException</code>과 그걸 상속받는 예외들은 <code class="language-plaintext highlighter-rouge">unchecked exception</code>이다.
<br />
컴파일러가 체크하지 않는 예외이며 <code class="language-plaintext highlighter-rouge">throw</code>를 생략할 수 있고 이럴 경우 자동으로 예외를 던진다.
<br />
즉, 예외를 잡아서 처리하지 않아도 <code class="language-plaintext highlighter-rouge">throw</code>를 생략할 수 있다.
<br />
예외 발생 시 트랜잭션 <code class="language-plaintext highlighter-rouge">roll-back</code> 처리를 한다.</p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">throw</code> 생략으로 예외를 무시할 수 있다.</li>
      <li>시스템에서 발생하는 복구가 불가능한 예외에 대해 신경쓰지 않아도 된다.</li>
      <li>신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>컴파일 단계에서 체크가 안되기 때문에 실수할 가능성이 있다.</li>
    </ul>
  </li>
  <li>대표적인 <code class="language-plaintext highlighter-rouge">Exception</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">NullPointerException</code></li>
      <li><code class="language-plaintext highlighter-rouge">IllegalArgumentException</code></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="예외-던져도-안죽던데">예외 던져도 안죽던데?</h3>
<hr />
<p>웹 어플리케이션은 <code class="language-plaintext highlighter-rouge">servlet</code>의 오류 페이지나, 또는 <code class="language-plaintext highlighter-rouge">Spring MVC</code>가 제공하는 <code class="language-plaintext highlighter-rouge">ControllerAdvice</code> 에서 이런 예외를 공통으로 처리해 주기 때문에 예외가 메인메서드까지 가지 않는다.</p>
<ul>
  <li>하지만 이런 문제들은 클라이언트 입장에선 어떤 문제가 발생했는지 자세히 알기 어렵다.</li>
  <li><code class="language-plaintext highlighter-rouge">API</code>라면 HTTP 상태코드 <code class="language-plaintext highlighter-rouge">500</code>으로 응답을 내려준다.</li>
  <li>수정하기 전까진 해결되지 않으므로 별도의 오류 로그를 남기고 메일, 알림등을 통해 
<br />
개발자가 빨리 인지할 수 있도록 처리해두는게 좋다.</li>
</ul>

<p><br /></p>

<h3 id="자바의-checked-exception-도입">자바의 Checked Exception 도입?</h3>
<hr />
<p>자바의 <code class="language-plaintext highlighter-rouge">Checked Exception</code>은 자바만의 독특한 특징이다.
<br />
<strong><em>“강제성이 없기 때문에 실수할 여지가 있다”</em></strong> 를 해결하기위해 도입했지만
컴파일단계에서 예외를 처리하라고 
<br />
강요하는 <code class="language-plaintext highlighter-rouge">Checked Exception</code> 은 자바 이후 설계된 <code class="language-plaintext highlighter-rouge">C#</code> 이나 <code class="language-plaintext highlighter-rouge">ruby</code>등에서도 채택되지 않았다.
<br />
요즘은 극단적으로 자바의 <code class="language-plaintext highlighter-rouge">Checked Exception</code> 도입은 실패라는 주장도 심심치 않게 보인다.
<br />
<code class="language-plaintext highlighter-rouge">JDBC API</code>에서는 <code class="language-plaintext highlighter-rouge">Checked Exception</code>을 남발하고 <code class="language-plaintext highlighter-rouge">catch</code>절에서 아무것도 하지 않았고 
<br />
이런 문제점을 알고 그후에 <code class="language-plaintext highlighter-rouge">JDBC</code>를 활용한 <code class="language-plaintext highlighter-rouge">Spring-JdbcTemplet</code>, <code class="language-plaintext highlighter-rouge">Hibernate</code>, <code class="language-plaintext highlighter-rouge">JPA</code> 등에서는 
<br />
<code class="language-plaintext highlighter-rouge">Checked Exception</code>인 <code class="language-plaintext highlighter-rouge">SQLException</code>을 볼수 없게 설계되었고 이런 사례들을 보면 자바의 
<br />
<code class="language-plaintext highlighter-rouge">Checked Exception</code>은 도입은 논란의 여지가 있는듯 하다.</p>

<p><br /></p>

<h2 id="의문점">의문점</h2>
<p>가비지컬렉터는 알아서 메모리를 관리해 주는데, 결국 한계점에선 Major GC를 실행할 수 밖에 없고
<br />
이것이 실행되는 동안에는 결국 <code class="language-plaintext highlighter-rouge">stop the world</code> 즉, JVM이 멈추게 되는 현상이 발생하는데 그렇기 때문에
<br />
과거에는 GC를 튜닝해서(도메인에 따라 메모리 관리가 틀리기 때문에) 이런 현상이 최대한 적게 일어나게
<br />
하는것이 한동안 이슈였다.<br />
<br />
그렇다면 하나의 큰 JVM 말고 여러개의 소규모 컨테이너로 JVM을 실행하면? 마치 로드밸런싱과도 비슷한데..
<br />
이렇게 하면 하나의 JVM에서 Major GC가 발생해도 어플리케이션 전체가 <code class="language-plaintext highlighter-rouge">stop the world</code>에 빠지진 않는데?
<br />
하지만 이 방법은 JVM이 나뉘어 짐에 따라 스택프레임을 공유할 수 없다는 단점이 있는데
<br />
<br />
요즘은 웬만한 프로그램도 웹어플리케이션으로 패러다임이 움직임에 따라 프로그램은 
<br />
request -&gt; response 이후 스레드가 종료되는 단순한 형태로 바뀌기 시작했고
<br />
그 결과 스택프레임을 공유하는 빈도 수 가 줄면서 GC튜닝 이슈는 좀 사그라 들었다.
<br />
하지만 완벽한 해결법은 아니고 자바 11 이후 GC의 방식이 조금 바뀌었다. 하지만 이것도 장단점..</p>

<p><br /></p>

<h3 id="자바-11-이후-바뀐-가비지컬렉션에-대해-자세히-알아보자">자바 11 이후 바뀐 가비지컬렉션에 대해 자세히 알아보자</h3>
<hr />
<ul>
  <li>
    <p><strong><em>Generational GC</em></strong>
<br />
JDK 7부터 본격적으로 사용할 수 있는 G1 GC를 제외한, Oracle JVM에서 제공하는 모든 GC</p>
  </li>
  <li>
    <p><strong><em>The Serial GC</em></strong>
<br />
가장 단순한 GC이지만 사용하지 않는 것을 추천한다. 싱글 쓰레드 환경을 위해 설계 되었고 아주 작은 Heap영역을 가진다. 
<br />
Full GC가 일어나는 동안 애플리케이션 전체가 대기해야하는 현상이 발생하기 때문에 서버 애플리케이션에 적당하지 않다.</p>
  </li>
  <li>
    <p><strong><em>Parallel GC</em></strong>
<br />
Java 8의 디폴트 GC이고 병렬로 GC한다. 
<br />
메모리가 충분하고 CPU의 성능과 코어 개수가 많아 순간적으로 트래픽이 몰려도 일시 중단을 견딜 수 있고 GC에 의해 야기된 CPU 오버 헤드에 대해 최적화할 수 있는 애플리케이션에 가장 적합하다.</p>
  </li>
  <li>
    <p><strong><em>G1(Garbage First) GC</em></strong>
<br />
<strong>대용량 메모리가 있는 다중 프로세서 시스템을 대상</strong>으로 하는 서버-스타일 가비지 컬렉터이다.
<br />
GC GC는 Generational 한 알고리즘과는 다르게 백그라운드의 멀티 쓰레드를 활용해 1MB에서 32MB까지의 수 많은 리젼으로 Heap을 분할한다.
<br />
G1 GC는 위와 같이 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면
<br />
다른 영역에서 객체를 할당하고 GC를 실행한다. 
<br />
즉, 지금까지 설명한 Young의 세가지 영역에서 데이터가 Old 영역으로 이동하는 단계가 사라진 GC 방식이라고 이해하면 된다.
<br />
<br />
G1 GC의 가장 큰 장점은 성능이다. 
<br />
G1은 지연 시간을 줄이기 위해서 지금까지 설명한 어떤 GC 방식보다도 빠르다.
<br />
하지만 이와 같이 4GB 이상의 큰 Heap을 가지는 것은 요즘과 같이 마이크로 서비스 아키텍쳐에서는 논쟁 거리가 될만하다. 
<br />
지난 몇 년동안 많은 개발자들이 거대한 시스템을 작은 마이크로 단위로 옮기는 노력을 해왔기 때문이다.
<br />
이러한 Garbage Collector에 대한 변화는 Parallel GC와 같이 처리량을 극대화하는 것보다 GC의 지연 시간을 제한하는 것이 더 중요하다는 가정 하에 이루어졌다</p>
  </li>
</ul>

<p><br /></p>

<h3 id="튜닝">튜닝?</h3>
<hr />
<p>JVM을 튜닝한다는 의미는 기존 GC 에서 Old 영역으로 넘어가는 객체의 수를 최소화하는 것과 Full GC의 실행 시간을 줄이는 노력이다.
<br />
Full GC 실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 자칫 OutOfMemoryError가 발생하거나 
<br />
Full GC 횟수가 늘어난다. 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어난다. 
<br />
Old 영역의 크기를 적절하게 <strong>잘</strong> 설정해야 한다.
<br />
G1 GC를 제외한 GC에서는 JVM Heap을 무한정 늘리면 Full GC 시간 증가로 인해 오히려 성능 병목이 될 수 있다.
<br />
JVM의 Heap을 증가시키기 보다는 JVM의 인스턴스를 늘려 클러스터링이나 로드밸런서로 가용성을 확보하는 방법을 권장한다.
<br />
<br />
<br />
멀티코어상황에서 유용하다는데? 알아보자</p>

<p><br /></p>

<h3 id="스택프레임에-대해-알고있는-것보다-더-자세히-알아보자">스택프레임에 대해 알고있는 것보다 더 자세히 알아보자</h3>
<hr />

<p><br /></p>

<h3 id="하나의-jvm으로-띄우는-것과-여러개의-컨테이너로-띄우는-것의-장단점에-대해-자세히-알아보자">하나의 JVM으로 띄우는 것과 여러개의 컨테이너로 띄우는 것의 장단점에 대해 자세히 알아보자</h3>
<hr />
<p>노드js에선 쓰고있는거 같던데?</p>

<p><br /></p>

<h3 id="멀티코어에서의-jvm과-멀티스레드">멀티코어에서의 JVM과 멀티스레드</h3>
<hr />
<p>과거에는 싱글코어의 성능을 극한으로 올렸다. 하지만 전력소모, 코어의 면적을 넓히는 방식으로의 해결등이 한계에 다다르면서 코어 수를 늘려서 CPU 전체의 성능을 향상하는 쪽으로 발전했다.</p>

<ul>
  <li>멀티코어 : 2개 이상의 독립코어를 단일 직접회로로 이루어진 하나의 CPU로 통합한 것</li>
  <li>프로세서 : 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛 즉, 중앙처리장치 혹은 CPU
    <ul>
      <li>소프트웨어적으로는 데이터포맷을 변환하는 역할을 수행하는 프로세싱 시스템
        <ul>
          <li>워드프로세서, 컴파일러, 어셈블러 등</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>프로세스 : 메모리에 적재되어 프로세서에 의해 실행중이거나 대기중인 프로그램</li>
</ul>

<p><br /></p>

<ul>
  <li>멀티스레드
    <ul>
      <li>프로세스를 생성하여 자원을 할당하는 운영체제의 시스템콜이 줄어든다.</li>
      <li>프로세스간 통신보다 스레드간의 통신의 비용이 적다.</li>
      <li>힙영역을 공유하므로 동기화 문제에 안전하지 않다.</li>
      <li>하나의 스레드에 문제가 생기면 전체 프로세스 전체가 영향을 받는다.</li>
    </ul>
  </li>
  <li>멀티프로세스
    <ul>
      <li>하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않는다.</li>
    </ul>
  </li>
</ul>

<p>JVM은 하나의 프로세스에서 동작한다.
<br />
하나의 프로세스는 여러 작업단위를 가질 수 있는데 이것이 스레드 이다.
<br />
해당 JVM에서 스레드를 생성해 사용할 때는 OS의 스레드를 사용하는데 이 OS의 스레드는 다른 코어에 있고, 
<br />
결국 하나의 JVM에서 멀티코어를 사용할 수 있는것이다.
<br />
<br />
<br />
근데 이말은 무슨말인지 자세히 알아보자</p>
<ul>
  <li>프로세스는 독자적인 메모리를 할당받아서 서로 다른 프로세스끼리는 일반적으로 서로의 메모리 영역을 침범하지 못한다?</li>
</ul>

<p><br /></p>

<h3 id="로드밸런싱에-대해서-자세히-알아보자">로드밸런싱에 대해서 자세히 알아보자</h3>
<hr />

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="String" /><category term="Annotation" /><category term="Exception" /><category term="Property" /><category term="JVM" /><category term="GC" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">자료구조</title><link href="http://localhost:4000/data_structure/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/" rel="alternate" type="text/html" title="자료구조" /><published>2022-12-24T00:00:00+09:00</published><updated>2022-12-24T00:00:00+09:00</updated><id>http://localhost:4000/data_structure/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0</id><content type="html" xml:base="http://localhost:4000/data_structure/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"><![CDATA[<p><br /><br /><br /></p>

<h2 id="시간복잡도">시간복잡도</h2>
<p>알고리즘 효율성을 판단하는 지표로써,
<br />
알고리즘 수행에 걸리는 시간이 아닌
<br />
<strong><em>연산들이 몇번 이루어지는가</em></strong> 에 대한 지표이다.
<br />
메모리 사용량을 분석한 결과는 <strong><em>공간복잡도</em></strong> 이다.</p>

<ul>
  <li><strong><em>Big-O 표기법</em></strong>
    <ul>
      <li>빠른 순서</li>
      <li><strong><em>O(1)</em></strong> : 데이터의 크기에 상관없이 언제나 일정한 시간이 걸림 (<code class="language-plaintext highlighter-rouge">index</code>를 통한 접근)</li>
      <li>O(log₂ n) : 데이터가 커질수록 시간이 로그만큼 짧아짐 (이진탐색 / Tree)</li>
      <li><strong><em>O(n)</em></strong> : 데이터의 크기에 비례해 처리시간이 증가함 (선형탐색 / for문)</li>
      <li>O(n log₂ n) : 데이터가 커질수록 시간이 로그 배 만큼 늘어남 (퀵/병합/힙 정렬)</li>
      <li>O(n²): 데이터의 크기가 커질수록 처리시간이 기하급수적으로 늘어남 (이중for문 / 삽입/버블/선택 정렬)</li>
      <li>O(2ⁿ) : 데이터의 크기가 커질수록 처리시간이 기하급수적으로 늘어남 (피보나치 수열)</li>
    </ul>
  </li>
</ul>

<p><img src="/images/big-o/big-o.png" alt="이미지" /></p>

<p><br /></p>

<h2 id="hash">Hash</h2>
<p>임의의 크기를 가진 데이터를 고정된 크기의 데이터로 바꾸는 것.
<br />
단방향 암호화 기법으로 해시함수 또는 해시 알고리즘를 이용해 고정된 길이의 비트열로 변경한다.
<br />
10 X 10 = 100 이라는 것은 쉽게 알지만, 몇과 몇을 곱해야 100이 나오는지는 많은 경우의 수가 나오는데
<br />
해싱은 이런식으로 복호화가 어렵다.
<br />
하지만 동일한 내용은 <code class="language-plaintext highlighter-rouge">항상 같은 해시값이 나온다는 단점</code>이 있다.
<br />
예를들면 동일한 비밀번호는 항상 해시값이 같다.</p>

<ul>
  <li>
    <p><strong><em>HashTable</em></strong>
<br />
key와 value의 쌍으로 이루어진 데이터 구조이다.
<br />
해시충돌이 일어나지 않는 가정 하에 평균 시간복잡도 O(1)로 효율적이다. 
<br />
이는 배열에서 <code class="language-plaintext highlighter-rouge">index</code>를 알고 접근하는 것과 동일한 시간복잡도를 보인다.</p>
  </li>
  <li><strong><em>key</em></strong> : 해시함수의 input이 되는 고유 값, 키는 해시함수를 통해 해시로 변경되고 <code class="language-plaintext highlighter-rouge">index</code> 역할을 하게된다.</li>
  <li><strong><em>value</em></strong> : 저장소(버킷, 슬롯)에 최종적으로 저장되는 값.</li>
  <li><strong><em>Hash</em></strong> : 임의의 값을 가지는 key값을 고정된 길이로 변환하는 것</li>
  <li><strong><em>Hash Function</em></strong> : 임의의 값을 고정된 크기의 값으로 변환하는 함수.  key -&gt; hash</li>
  <li><strong><em>저장소(Bucket, Slot)</em></strong> : Hash Table 에서 하나의 데이터가 저장되는 공간</li>
  <li>
    <p><strong><em>해시충돌</em></strong> : 서로 다른 key가 같은 hash값이 되는 경우</p>

    <ul>
      <li>
        <p><strong><em>데이터 저장</em></strong>
  <br />
  해시함수를 이용해 키값을 해시로 변경한 후 미리 준비해둔 저장소(버킷, 슬롯)중 
  <br />
  알맞는 해시값을 찾아 value를 저장한다.
  <br />
  이 과정의 시간복잡도는 O(1) 이다.</p>
      </li>
      <li>
        <p><strong><em>데이터 삭제</em></strong>
  <br />
  버킷에서 삭제하려고 하는 key와 매핑되는 value값을 찾아서 삭제한다
  <br />
  이 과정의 시간복잡도는 O(1) 이다.</p>
      </li>
      <li>
        <p><strong><em>데이터 검색</em></strong>
  <br />
  key를 이용해 value를 찾아내는 과정.
  <br />
  먼저 key값과 해시함수를 이용해 hash를 찾아내고 해당 hash로 value를 찾는다.
  <br />
  이 과정의 시간복잡도는 O(1) 이다.</p>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>자바의 Hash?</em></strong>
    <ul>
      <li>자바에서는 <code class="language-plaintext highlighter-rouge">Object</code>클래스의 hashCode() 메서드로 모든 객체의 해시코드를 쉽게 구할 수 있다</li>
      <li>자바는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에 모든 객체에 대해 중복되지 않는 값을 제공한다.</li>
      <li>String의 경우 <code class="language-plaintext highlighter-rouge">Object</code>로부터 상속받은 hashCode()를 오버라이딩 하여 문자열의 내용으로 해시코드를 만들어 낸다. 그렇기 때문에 다른 인스턴스의 String이어도 문자열이 같다면 같은 해시코드값을 가진다.</li>
      <li>HashMap도 같은 방법으로 객체를 구별하기 때문에 이미 존재하는 키와 동일한 값을 저장하면 기존의 값을 덮어쓰게 된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>HashTable과 HashMap</em></strong>
  <br />
  둘의 차이는 <code class="language-plaintext highlighter-rouge">Thread-Safe</code> 의 차이이다. 
  <br />
  HashTable은 동기화가 걸려있어 안전하지만 느리고 HashMap은 동기화가 없어서 불안전하지만 빠르다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>정렬이나 순차적인 데이터 저장에 적합하지 않다</li>
      <li>데이터가 저장되기 전에 저장공간을 확보해야 하기 때문에 공간효율성이 떨어진다.</li>
      <li>Hash Function이 복잡할수록 연산속도가 증가한다.</li>
      <li>해시충돌이 발생할 경우 최악의 경우 시간복잡도가 O(N) 에 점점 수렴함</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="array">Array</h2>
<p>메모리상에 데이터를 순차적으로 배치하는 자료구조
<br />
동일한 <code class="language-plaintext highlighter-rouge">type</code>의 데이터를 여러개 나열한 선형구조이다.
<br />
<code class="language-plaintext highlighter-rouge">index</code>를 사용할 수 있으며, <code class="language-plaintext highlighter-rouge">index</code>값을 알고 접근할 경우 시간복잡도는 O(1)이다.</p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>선언할 때 지정한 크기가 고정된다.</li>
      <li>선언된 값은 다시 배열을 선언하지 않는이상 변경할 수 없다.</li>
      <li>삽입 순서대로 저장된다. (새로운 데이터는 배열 맨 끝에 들어감)</li>
      <li>중복 가능</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>처음에 선언한 배열의 크기를 수정할 수 없다.</li>
      <li>데이터의 추가 / 삭제를 할 경우 뒤에있는 데이터들을 앞으로 옮기는 작업이 추가로 필요하다.
        <ul>
          <li>원소의 개수가 1000개인 배열에서 0번 <code class="language-plaintext highlighter-rouge">index</code>를 삭제하면,  삭제를 하는 작업 외에 (1000 - 1)만큼의 원소를 이동하는 추가작업 필요</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li>순차적인 데이터를 저장할 때 유용</li>
      <li>특정요소를 빠르게 읽을 때 (<code class="language-plaintext highlighter-rouge">index</code>값이 필요함)</li>
      <li>데이터 사이즈가 바뀌지 않거나 데이터의 추가 / 삭제가 자주 일어나지 않을 때</li>
      <li>이펙티브 자바에서는 배열보다 리스트를 사용하라 라는 챕터가 있다.
        <ul>
          <li>간단하게 말해 타입실수를 컴파일 단계에서 확인할 수 있냐 없냐의 차이</li>
          <li>배열의 성능이점보다 안전함을 더 중요하게 생각하는듯 하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="list">List</h2>
<p>데이터를 순차적으로 저장하는 <code class="language-plaintext highlighter-rouge">선형구조</code>의 자료구조
<br />
데이터가 삭제되도 빈공간으로 남겨두고 <code class="language-plaintext highlighter-rouge">index</code>를 유지하는 배열과 달리 빈공간을 남겨두지 않기 때문에
<br />
낭비되는 메모리가 없고 빈틈없는 데이터 구조를 가질 수 있다.
<br />
또한 배열과 다르게 데이터를 담을 공간의 추가가 가능하다.
<br />
하지만 배열처럼 고정된 <code class="language-plaintext highlighter-rouge">index</code>를 식별자로 이용할 수 없다.
<br /></p>
<ul>
  <li><strong><em>선형구조</em></strong> : 데이터가 순차적으로 저장되고 끊어지지 않으며 빈틈없이 데이터를 적재하는,
<br />
보기에 한줄로 계속되기 때문에 마치 선과 같은 형태를 띈다 하여 선형구조라 함
<br /></li>
</ul>

<p><img src="/images/big-o/list.png" alt="이미지" /></p>

<p><br /></p>

<ul>
  <li><strong><em>ArrayList</em></strong>
    <ul>
      <li>배열을 이용해 구현된 List</li>
      <li>데이터를 추가/삭제 할때, 연속적인 물리적위치를 유지하기 위해 원소를 옮기는 추가작업이 필요하다.
        <ul>
          <li>원소의 개수가 1000개인 ArrayList에서 0번 index를 삭제하면, 
  <br />
  삭제를 하는 작업 외에 (1000 - 1)만큼의 원소를 이동하는 추가작업이 필요하다.</li>
        </ul>
      </li>
      <li>데이터 조회의 시간복잡도는 O(1)이다.</li>
      <li><strong><em>데이터 탐색에 효율적이다.</em></strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>LinkedList</em></strong>
    <ul>
      <li>연결 포인터를 이용해 구현한다.
        <ul>
          <li>기본단위는 노드이다</li>
          <li>노드 : 자료(Data) + 링크(Link)</li>
        </ul>
      </li>
      <li>각 데이터마다 다음 순서의 데이터가 뭔지 알려주는 포인터가 존재하는 구조이다.</li>
      <li>데이터를 추가/삭제 할때, 특정 노드의 링크필드(다음 노드주소)만 수정하면 된다.
  <br />
  즉, 노드의 포인트가 가리키는 것만 바꾸면 되기 때문에 시간복잡도는 O(1)이다.</li>
      <li><code class="language-plaintext highlighter-rouge">index</code>가 없기때문에 데이터 조회의 시간복잡도는 모든 노드를 순회하는 O(n)이다.</li>
      <li><strong><em>데이터의 추가/삭제에 효율적이다.</em></strong></li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li><strong><em>ArrayList</em></strong> : 탐색에 유용
        <ul>
          <li>데이터를 중간에 추가 / 삭제하는 경우가 적다면 사용을 고려해보자.</li>
        </ul>
      </li>
      <li><strong><em>LinkedList</em></strong> : 추가/삭제에 유용
        <ul>
          <li>데이터를 중간에 추가 / 삭제하는 경우가 많다면 사용을 고려해보자.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="set">Set</h2>
<p>데이터의 집합이며 순서가 없고 집합이므로 중복된 데이터를 허용하지 않는다.
<br />
<code class="language-plaintext highlighter-rouge">index</code>가 따로 존재하지 않기 때문에 <code class="language-plaintext highlighter-rouge">Iterator</code>를 사용한다.
<br /></p>

<p><img src="/images/big-o/set.png" alt="이미지" /></p>

<p><br /></p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>순서가 없고 중복을 허용하지 않는다.</li>
      <li>자바의 Set
        <ul>
          <li>Hash알고리즘을 이용한 <code class="language-plaintext highlighter-rouge">HashSet</code></li>
          <li>이진탐색트리를 사용해 오름차순정렬을 해주는 <code class="language-plaintext highlighter-rouge">TreeSet</code></li>
          <li>순서를 부여해주는 <code class="language-plaintext highlighter-rouge">LinkedHashSet</code></li>
        </ul>
      </li>
      <li>일반적으로 <code class="language-plaintext highlighter-rouge">HashSet &gt; TreeSet &gt; LinkedHashSet</code> 순으로 빠르다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>HashSet</em></strong>
    <ul>
      <li>입력된 키를 해시알고리즘으로 해시코드로 변환한다.</li>
      <li>그 후 해시코드를 인덱스로 bucket저장소에 저장한다.</li>
      <li>값이 키와 동일하게 설정된다.</li>
      <li>순서를 보장하지 않는다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>TreeSet</em></strong>
    <ul>
      <li>이진 탐색 트리(Red-Black Tree)를 기반으로 한다.</li>
      <li>오름차순으로 데이터를 저장한다.</li>
      <li>추가 / 삭제는 LinkedHashSet보다 느리지만 검색 / 정렬은 더 효율적이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>LinkedHashSet</em></strong>
    <ul>
      <li>데이터가 들어간 순서대로 저장된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li>중복된 값을 골라낼때 유용하다.</li>
      <li>빠른 탐색에 유용하다.
        <ul>
          <li><strong><em>특정 요소의 값을 찾기보다는 요소가 집합에 존재하는지 확인할 때</em></strong></li>
          <li>List의 contains 시간복잡도는 O(n)이지만 <strong><em>Set은 O(1)</em></strong></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="map">Map</h2>
<p>순차적으로 메모리에 데이터를 저장하는 Array와 List와는 달리,
<br />
Key와 Value로 이루어진 자료구조이다.
<br /></p>

<p><img src="/images/big-o/map.png" alt="이미지" /></p>

<p><br /></p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>데이터의 순서가 없다.</li>
      <li>Key는 중복을 허용하지 않는다.</li>
      <li>List와 마찬가지로 인터페이스이다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>Hash Table / Map</em></strong>
    <ul>
      <li><strong><em>Hash</em></strong>를 Key로 가지는 Map, 앞에서 설명했듯 가장 큰 차이점은 <code class="language-plaintext highlighter-rouge">동기화</code>와 <code class="language-plaintext highlighter-rouge">null</code>이다.
        <ul>
          <li><strong><em>HashMap</em></strong> : <code class="language-plaintext highlighter-rouge">동기화</code>를 지원하지 않고 Key 와 Value에 <code class="language-plaintext highlighter-rouge">null</code>이 허용된다.</li>
          <li><strong><em>HashTable</em></strong> : <code class="language-plaintext highlighter-rouge">동기화</code>를 지원하고 Key 와 Value에 <code class="language-plaintext highlighter-rouge">null</code>이 허용되지 않는다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>LinkedHashMap</em></strong>
    <ul>
      <li>데이터가 들어간 순서대로 저장된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>TreeMap</em></strong>
    <ul>
      <li>이진검색 트리구조, Key를 기준으로 오름차순으로 저장된다.
        <ul>
          <li>숫자 &gt; 대문자 &gt; 소문자 &gt; 한글</li>
        </ul>
      </li>
      <li>정렬된 순서로 저장하기 때문에 검색에는 빠르지만 저장 시 효율이 떨어진다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>활용?</em></strong>
    <ul>
      <li><strong><em>저장하고 싶은 데이터가 특별한 Key 값을 가질 때</em></strong> - 검색에 유용</li>
      <li>특정 데이터를 순간마다 캐치해야 할 때</li>
      <li>특정 품목의 갯수를 카운트 해야할 때</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="stack">Stack</h2>

<p><br /></p>

<h2 id="queue">Queue</h2>
<p><img src="/images/big-o/queue.png" alt="이미지" /></p>

<p><br /></p>

<h2 id="tree">Tree</h2>

<p><br /></p>

<h2 id="graph">Graph</h2>]]></content><author><name>NNIIE</name></author><category term="Data_Structure" /><category term="Data Structure" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">2주차</title><link href="http://localhost:4000/til/2%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="2주차" /><published>2022-12-22T00:00:00+09:00</published><updated>2022-12-22T00:00:00+09:00</updated><id>http://localhost:4000/til/2%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/2%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="today-i-learned">Today I Learned</h1>

<h2 id="enum">enum</h2>
<p>열거형이라고 부르며, 서로 연관된 상수들의 집합이다.
<br />
모든 열거형은 <code class="language-plaintext highlighter-rouge">Enum</code>클래스의 자손이며 <code class="language-plaintext highlighter-rouge">Enum</code>클래스의 멤버를 상속받는다.</p>

<ul>
  <li><strong><em>특징과 장점</em></strong>
    <ul>
      <li>enum은 컴파일 후 <code class="language-plaintext highlighter-rouge">public static final</code> 필드이며 객체로 제공된다.</li>
      <li>상수들은 JVM 메서드 영역에 자리한다.</li>
      <li>Enum클래스는 상수와 같이 인스턴스가 단 한번만 생성된다.</li>
      <li>컴파일 시점에 타입안정성이 보장되기 때문에 <code class="language-plaintext highlighter-rouge">private</code> 생성자만을 가진다. 
  <br />
  즉, 인스턴스 생성을 제어하며 싱글톤을 일반화 한다. (싱글톤 구현의 방법으로도 사용됨)</li>
      <li>그렇기 때문에 주소값을 비교하는 == 연산자의 사용이 가능하다.
  <br />
  즉, 객체의 값을 비교하는 equals()보다 빠르고 컴파일 단계에서 검사되기 때문에 실수를 방지할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="enum-method">enum method</h3>
<hr />
<ul>
  <li><strong><em>values()</em></strong> : enum클래스의 모든 상수를 배열로 반환한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// values 활용</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">LottoRank</span> <span class="nf">countOfMatchNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">countOfMatchNumber</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
			<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="nc">LottoRank</span> <span class="o">-&gt;</span> <span class="nc">LottoRank</span><span class="o">.</span><span class="na">countOfMatchNumber</span> <span class="o">==</span> <span class="n">countOfMatchNumber</span><span class="o">)</span>
			<span class="o">.</span><span class="na">findAny</span><span class="o">()</span>
			<span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="no">MISS</span><span class="o">);</span>
			<span class="c1">// 또는 orElseThrow(new IllegalArgumentException(error message))</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>valueOf()</em></strong> : <code class="language-plaintext highlighter-rouge">String</code>을 매개변수로 받아 일치하는 상수를 반환한다. (없으면 런타임 에러 발생)</li>
  <li><strong><em>ordinal()</em></strong> : 상수들의 index를 반환한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
<br />
enum자체가 가지는 비용이 적지 않다. static final 상수로도 충분하다면 enum의 사용 여부는 고려해보자</li>
</ul>

<p><br /></p>

<h2 id="싱글톤패턴">싱글톤패턴</h2>
<p>객체의 인스턴스가 오직 1개만 생성되는 패턴이다.
<br />
하나의 인스턴스로 공유되며 접근, 사용할 수 있다</p>

<ul>
  <li>가장 단순한 코드레벨의 싱글톤 패턴</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 동시성 이슈를 배제한 Lazy initialization 방식</span>
<span class="c1">// Thread Safety 하지 않다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>인스턴스가 하나기 때문에 매번 새로 인스턴스를 생성할 필요가 없다.</li>
      <li>싱글톤 패턴으로 만들어진 클래스는 전역 인스턴스이기 때문에 접근하기 편하다.</li>
    </ul>
  </li>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>클라이언트가 구체클래스에 의존 -&gt; DIP OCP 위반</li>
      <li>멀티스레드 환경에서 인스턴스가 하나이기 때문에 문제가 발생할 수 있다.</li>
      <li>테스트가 어렵다. 인스턴스가 하나기 때문에 테스트를 하려면 매번 초기화를 시켜주어야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="활용">활용</h3>
<hr />
<ul>
  <li>
    <p><strong><em>synchronized</em></strong> : 사용하지 말자. 락을 걸어버리는 방법으로 동기화 문제를 간단하고 확실하게 해결하지만 그렇기 때문에 멀티스레드의 이점을 모두 막아버린다.</p>
  </li>
  <li>
    <p><strong><em>Lazy initialization + Double-checked Locking</em></strong> : 이것도 좋지 않다.</p>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 조건문으로 먼저 인스턴스를 확인한 다음 synchronized를 동기화 시켜 인스턴스를</span>
<span class="c1">// 생성하는방법, 처음 생성이후 synchronized를 실행하지 않아서 성능저하 완화 가능</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Person</span> <span class="n">instance</span><span class="o">;</span>
	
	<span class="kd">private</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>Initialization on demand holder idiom</em></strong> : 제일 많이 사용되는 방법</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는</span>
<span class="c1">// 시점을 이용한 방법</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
	<span class="o">}</span>
	
	<span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">LazyHorder</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Person</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="nc">LazyHorder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>스프링 컨테이너를 사용하는게 가장 좋다.</em></strong>
    <ul>
      <li>상태를 유지(stateful)하면 안되고 무상태(stateless)로 설계해야 한다.</li>
      <li>특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다</li>
      <li>읽기만 가능해야 한다.</li>
      <li>필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.</li>
      <li><code class="language-plaintext highlighter-rouge">@Configuration</code>, <code class="language-plaintext highlighter-rouge">@Bean</code>을 같이 사용한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="인터페이스">인터페이스</h2>
<p>컴퓨터 사이언스에서 인터페이스란 서로간의 약속, 규약 등의 개념으로 사용하게 끔 오픈된 것을 말한다.
<br />
일종의 서로를 이어주는 <strong><em>메시지 창구</em></strong> 역할을 하며, 대표적인 소프트웨어 인터페이스로는 <code class="language-plaintext highlighter-rouge">API</code>가 있다.
<br />
<strong><em>자바</em></strong> 에서 인터페이스란, 다른 클래스의 기본이 되는 틀을 제공하면서
<br />
다른 클래스 사이의 중간 매개역할을 하는 일종의 추상클래스 이다.
<br />
자바8 이전에는 오로지 추상메서드와 상수만을 포함할 수 있었는데 
<br />
자바8이후 <code class="language-plaintext highlighter-rouge">default method</code>, <code class="language-plaintext highlighter-rouge">static method</code>가 추가되었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 은행시스템을 운영하려면 이 금융결제원 인터페이스에 맞게 구현해야 한다고 치자</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Bank</span> <span class="o">{</span>

	<span class="c1">// 상수 (하루 최대 인출 금액)</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="no">MAX_INTEGER</span> <span class="o">=</span> <span class="mi">10000000</span><span class="o">;</span>
	
	<span class="c1">// 추상메서드 (인출)</span>
	<span class="kt">void</span> <span class="nf">withDraw</span><span class="o">(</span><span class="kt">int</span> <span class="n">price</span><span class="o">);</span>
	
	<span class="c1">// 추상메서드 (입금)</span>
	<span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="kt">int</span> <span class="n">price</span><span class="o">);</span>
	
	<span class="c1">// defualt 메서드 (고객의 휴면계좌 찾아주는 메서드 : 필수구현은 선택사항)</span>
	<span class="k">default</span> <span class="nc">String</span> <span class="nf">findDormancyAccount</span><span class="o">(</span><span class="nc">String</span> <span class="n">custId</span><span class="o">){</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"**금융개정법안 00이후 고객의 휴면계좌 찾아주기 운동**"</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"**금융결제원에서 제공하는 로직**"</span><span class="o">);</span>
		<span class="k">return</span> <span class="s">"00은행 000-000-0000-00"</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">// 정적 메서드 (블록체인 인증)</span>
	<span class="kd">static</span> <span class="kt">void</span> <span class="nf">BCAuth</span><span class="o">(</span><span class="nc">String</span> <span class="n">bankName</span><span class="o">){</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bankName</span><span class="o">+</span><span class="s">" 에서 블록체인 인증을 요청합니다."</span><span class="o">);</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"전 금융사 공통 블록체인 로직 수행"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><strong><em>상수</em></strong> : 컴파일 단계에서 정해지는, 인터페이스가 제공하는 변하지 않는 값
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public static final</code>을 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
    </ul>
  </li>
  <li><strong><em>정적메서드</em></strong> : 인터페이스에서 제공하는 변하지 않는 메서드
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code>을 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
    </ul>
  </li>
  <li><strong><em>추상메서드</em></strong> : 구현클래스에서 구현해야만 하고 거기서 실행된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public abstract</code>를 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
    </ul>
  </li>
  <li><strong><em>디폴트메서드</em></strong> : 인터페이스에서 제공해주지만, 구현클래스에서 재구현 할 수 있고 안써도 된다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">public</code>을 명시하지 않아도 컴파일 단계에서 자동 선언 된다.</li>
      <li>구현클래스에 인스턴스 메서드로 추가됨. 즉, 구현객체가 있어야 사용할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>특징</em></strong>
    <ul>
      <li>인터페이스는 직접 인스턴스를 생성할 수는 없고 추상메서드를 구현해 줄 클래스를 작성해야 한다.</li>
      <li>자바에서 다중상속은 지원하지 않지만 다중 인터페이스는 구현할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="쓰는-이유">쓰는 이유?</h3>
<hr />
<ul>
  <li>추상메서드와 상수를 통해 구현클래스에 <strong><em>동일한 동작</em></strong>을 보장한다.
    <ul>
      <li>클래스의 설계 또는 표준화를 유도할 수 있다.</li>
      <li>자바8 이후 <code class="language-plaintext highlighter-rouge">default method</code>로 유연성을 추가로 확보했다.</li>
    </ul>
  </li>
  <li><strong><em>다형성</em></strong>을 이용하여 타입변환을 한다.
    <ul>
      <li>회사에서 입출금 업무를 하는 로직이 있다면 인터페이스를 이용할 시 
<br /> 새로운 은행에 대한 코드만 작성해서 인스턴스만 바꿔 끼면 끝난다.</li>
    </ul>
  </li>
  <li>개인적으로 상속보다 좋아보인다..
    <ul>
      <li><strong><em>has-a</em></strong> : “~를 할 수 있는”</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="문제점">문제점</h3>
<hr />
<ul>
  <li>수정이 어렵다.
    <ul>
      <li>자바8 이후 대대적인 개선으로 많이 좋아졌다고 생각한다. <code class="language-plaintext highlighter-rouge">(default method)</code></li>
    </ul>
  </li>
  <li><strong><em>잘사용해야한다..</em></strong> 불필요하게 어플리케이션의 복잡도만 증가시킬 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="default-method">default method</h3>
<hr />
<p>이미 잘 운영중인데 휴면계좌 서비스를 점진적으로 도입하기로 정책이 바뀌었다고 치자.
<br />
추상메서드로 새로 추가하려고 하면 금융결제원의 Bank 인터페이스를 implements한 
<br />
각 은행사의 모든 클래스에서 무조건 구현을 해야한다.
<br />
은행사 마다 개발, 운영환경이 다르고 개발기간도 다르기 때문에 쉽지않다.
<br />
만약 <code class="language-plaintext highlighter-rouge">default method</code>로 정의하고 기본적인 구현부를 제공하면 각 은행에서 자신들만의 로직으로 재구현 할 수도 있고
사용을 안할 수도 있어서 점진적으로 도입하기로 한 정책을 실행할 수 있을것이다.
<br />
그대로 쓰거나, 재구현 하거나, 안쓰거나 할 수 있는것이다.
<br />
이것은 구현클래스가 자신만의 메서드를 각자 추가하는 것과는 엄연히 다르다.
<br />
<strong><em>즉, 운영중인 시스템에 효과적으로 유연함을 제공한다.</em></strong>
<br />
또한 <code class="language-plaintext highlighter-rouge">default method</code>는 <code class="language-plaintext highlighter-rouge">functional</code> 하다.
<br />
이 말은 에러에 최소화 되었다는 의미 이기도 하다.</p>

<p><br /></p>

<h3 id="함수형-인터페이스">함수형 인터페이스</h3>
<hr />
<p>추상메서드가 단 하나뿐인 인터페이스 이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 
어노테이션의 기능은 단일 추상메서드인지 컴파일 단계에서 확인하기 위함이다.
@FunctionalInterface 가 붙지 않아도 함수형인터페이스로 사용될 수 있으나
직관성을 위해 붙이는걸 추천한다
*/</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Calculate</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="nf">cal</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="쓰는-이유-1">쓰는 이유?</h4>
<hr />
<p>자바의 람다식은 함수형 인터페이스로만 접근할 수 있기 때문이다.
<br />
람다식과 인터페이스는 1:1로 연결될 수 있기 때문에 이 추상메서드의
<br />
매개변수의 개수와 타입, 리턴타입과 동일한 람다식을 할당해서 사용할 수 있다.
<br />
단, <code class="language-plaintext highlighter-rouge">static method</code>와 <code class="language-plaintext highlighter-rouge">default method</code>의 개수는 제약이 없다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FunctionalInterface</span> <span class="n">func</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FunctionalInterface</span><span class="o">()</span> <span class="o">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">};</span>
<span class="n">func</span><span class="o">.</span><span class="na">doSomething</span><span class="o">(</span><span class="s">"do something"</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="추상클래스">추상클래스</h2>
<p>하나 이상의 추상메서드를 포함하는 클래스 이다.
<br />
추상클래스를 상속받는 클래스는 추상메서드를 반드시 재정의 해야한다.
<br />
추상클래스는 인스턴스를 생성할 수 없으며, 자식클래스가 인스턴스를 생성할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nc">Int</span> <span class="n">age</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">say</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="쓰는이유">쓰는이유?</h3>
<hr />
<ul>
  <li>상속받는 클래스에게 추상메서드를 <strong><em>반드시 구현하도록 강제하기 위해</em></strong>
    <ul>
      <li>공통적인 부분에 대한 어느정도의 <strong><em>규격</em></strong>을 잡아 놓는다. (미완성 설계도)</li>
      <li>공통된 필드와 메서드를 통일할 목적 - 중복 제거</li>
      <li>다형성</li>
    </ul>
  </li>
  <li>구조를 재사용하기 위해서</li>
  <li>특정필드를 재사용하고 싶고 공개하고 싶지 않아서</li>
</ul>

<p><br /></p>

<h2 id="둘의-차이">둘의 차이</h2>
<p>인터페이스는 정의된 메서드를 각 클래스의 목적에 맞게 기능 구현을 하는 느낌.
<br />
(구현 객체가 같은 동작을 한다는것을 보장하기 위해)
<br />
추상클래스는 자신의 기능들을 하위클래스로 확장시키는 느낌으로 다가가자.
<br />
(같은 부모클래스가 가진 기능들을 구현하기 위해)</p>

<ul>
  <li>상태의 차이
    <ul>
      <li><code class="language-plaintext highlighter-rouge">non-static</code> 멤버 즉, <strong><em>상태 값</em></strong> 을 가지는가에 대한 차이</li>
    </ul>
  </li>
  <li>다중 상속
    <ul>
      <li>인터페이스는 다중으로 구현이 가능하지만 추상클래스는 단일 상속만 가능하다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Enum" /><category term="Singleton" /><category term="Interface" /><category term="Abstract" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Annotation</title><link href="http://localhost:4000/til/Annotation/" rel="alternate" type="text/html" title="Annotation" /><published>2022-12-20T00:00:00+09:00</published><updated>2022-12-20T00:00:00+09:00</updated><id>http://localhost:4000/til/Annotation</id><content type="html" xml:base="http://localhost:4000/til/Annotation/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="enablescheduling">@EnableScheduling</h1>
<hr />
<p>스프링의 스케쥴링을 위한 어노테이션이다.
<br />
기본적으로 스프링에 의헤 생성된 한개의 <code class="language-plaintext highlighter-rouge">Thread Pool</code>에서 작동한다. 
<br />
하나의 스케쥴이 돌고 있으면 그것이 다 끝나야 다음 스케쥴이 실행되기 때문에 설정을 통해 스케쥴에 대한 스레드풀을 생성하고 
그 스레드풀을 사용해서 병렬적으로 처리하는게 좋을 수 있다.</p>

<ul>
  <li>스프링 스케쥴링에 사용</li>
  <li>스프링 빈으로 등록해서 사용한다.</li>
  <li>Application Class에 @EnableScheduling 선언</li>
  <li>scheduler를 사용할 class에 @Component 선언, 메서드에 @Scheduled 선언
    <ul>
      <li>메서드 타입은 void</li>
      <li>메서드에 매개변수 사용 불가</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>왜 이거쓰는데?</em></strong>
<br />
  <code class="language-plaintext highlighter-rouge">Spring Quartz</code>라는 더 많은 기능을 가진 스케줄러도 존재한다.
  <br />
  하지만 의존성이 추가되어야 하고 사용법이 좀 더 복잡하기 때문에 단순한 스케쥴링 작업에는 
  <br />
  별도의 추가적인 의존성이 필요없고 사용법이 간단한 <code class="language-plaintext highlighter-rouge">Spring Scheduler</code>를 추천한다.</li>
</ul>

<p><br /></p>

<h1 id="value">@Value</h1>
<hr />
<p>properties 파일의 설정정보를 key-value형태로 가져오는데 쓰인다.
<br />
단일값 주입에 권장되고 있으며 여러개의 값을 주입받아야 할 경우
<br />
<code class="language-plaintext highlighter-rouge">@ConfigurationProperties</code> 사용을 권장한다.</p>

<ul>
  <li><strong><em>이거 왜쓰는데?</em></strong>
<br />
  만약 소스코드로 설정정보를 관리한다면 보안에도 좋지않고, 컴파일 된 바이트코드를 JVM에서 실행 후에 의미있는 정보가 되기때문에 서버를 내리지 않고는 변경할 수 없다.
  <br />
  하지만 properties 파일로 관리하면 key-value값만 불러서 치환하기 때문에 소스코드를 수정 할 필요가 없고 서버의 properties파일만 수정하면 되기 때문에 서버를 중단할 필요가 없다.
  <br />
  또한 각 서버환경에 따라 설정도 유연하게 관리할 수 있다.</li>
</ul>

<p><br /></p>

<h1 id="bean">@Bean</h1>
<hr />
<ul>
  <li><strong><em>@Bean</em></strong>
    <ul>
      <li>스프링에서 IoC 컨테이너가 관리하는 자바 객체</li>
      <li>기본적으로 싱글톤으로 생성하고 관리한다.</li>
    </ul>
  </li>
  <li><strong><em>@Component</em></strong>
    <ul>
      <li>개발자가 직접 작성한 클래스를 Bean으로 등록할 때 사용한다.</li>
      <li>선언 시 Component-Scan에 의해 Bean으로 등록 된다.</li>
    </ul>
  </li>
  <li><strong><em>@Configuration</em></strong>
    <ul>
      <li>외부라이브러리 또는 내장 클래스를 Bean으로 등록하고자 할 경우 사용한다.</li>
      <li>1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration를 선언한다.</li>
      <li>선언 시 Component-Scan에 의해 Bean으로 등록 된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="async">@Async</h1>
<hr />
<p>스프링에서 제공하는 <code class="language-plaintext highlighter-rouge">Thread Pool</code>을 활용하는 비동기 메서드 지원 어노테이션이다.
<br />
간단하게 사용하고 싶다면 Application 클래스에 <code class="language-plaintext highlighter-rouge">@EnableAsync</code>를 선언하고 비동기로 작동하고자 하는 메서드에 <code class="language-plaintext highlighter-rouge">@Async</code>를 선언해주면 사용할 수 있다.
<br />
하지만 이럴 경우 기본설정인 <code class="language-plaintext highlighter-rouge">SimpleAsyncTaskExecutor</code>를 사용해서 스레드를 관리하지 않는 등의 문제가 있기 때문에 <code class="language-plaintext highlighter-rouge">AsyncConfigurer</code> 인터페이스를 상속받아 구현하는게 좋을 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableAsync</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsyncConfig</span> <span class="kd">implements</span> <span class="nc">AsyncConfigurer</span> <span class="o">{</span>
	
	<span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Executor</span> <span class="nf">getAsyncExecutor</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ThreadPoolTaskExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolTaskExecutor</span><span class="o">();</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setCorePoolSize</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setMaxPoolSize</span><span class="o">(</span><span class="mi">30</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setQueueCapacity</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">setThreadNamePrefix</span><span class="o">(</span><span class="s">"async-pool"</span><span class="o">);</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">executor</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong><em>@Configuration</em></strong> : 빈 등록</li>
  <li><strong><em>@EnableAsync</em></strong> : 메서드에서 비동기 기능을 사용할 수 있게 한다.</li>
  <li><strong><em>CorePoolSize</em></strong> : 기본 실행 대기하는 Thread의 수</li>
  <li><strong><em>MaxPoolSize</em></strong> : 동시 동작하는 최대 Thread의 수</li>
  <li><strong><em>QueueCapacity</em></strong> : MaxPoolSize 초과 요청에서 Thread 생성 요청시,  해당 요청을 Queue에 저장하는데 이때 최대 수용 가능한 Queue의 수,   Queue에 저장되어있다가 Thread에 자리가 생기면 하나씩 빠져나가 동작</li>
  <li><strong><em>ThreadNamePrefix</em></strong> : 생성되는 Thread 접두사 지정</li>
  <li>그 후 비동기를 원하는 메서드에 <code class="language-plaintext highlighter-rouge">@Async</code> 어노테이션을 선언해 주면 된다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>주의할 점</em></strong>
    <ul>
      <li>private method에 사용 불가</li>
      <li>자가호출 불가 즉, 이너클래스에서 사용 불가</li>
      <li>QueueCapacity 초과 요청에 대한 비동기 method 호출시 방어 코드 작성</li>
    </ul>
  </li>
</ul>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Spring Annotation" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">1주차</title><link href="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/" rel="alternate" type="text/html" title="1주차" /><published>2022-12-15T00:00:00+09:00</published><updated>2022-12-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/til/1%EC%A3%BC%EC%B0%A8/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="today-i-learned">Today I Learned</h1>

<h2 id="객체와-클래스-그리고-인스턴스">객체와 클래스 그리고 인스턴스</h2>
<ul>
  <li><strong><em>객체</em></strong>
    <ul>
      <li>물리적, 추상적으로 생각할 수 있는것 중에서 자신의 속성을 가지고 있고 다른것과 식별 가능한 것.</li>
      <li>소프트웨어 에서 구현할 대상</li>
    </ul>
  </li>
  <li><strong><em>클래스</em></strong>
    <ul>
      <li>java에서 객체를 생성하기 위한 일종의 설계도</li>
      <li>속성(필드)을 가지고 있고, 행위(메소드)를 가지고있다.</li>
      <li>oop의 관점에서 클래스 타입으로 선언되었을 때 ‘객체’라고 부른다.</li>
    </ul>
  </li>
  <li><strong><em>인스턴스</em></strong>
    <ul>
      <li>클래스를 가지고 객체를 실체화 한것.</li>
      <li>메모리에 할당되어 실제로 사용되는 객체</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="절차형-객체지향-함수형-패러다임">절차형, 객체지향, 함수형 패러다임</h2>
<ul>
  <li>
    <h2 id="절차형-프로그래밍-procedural-programming"><strong><em>절차형 프로그래밍 (Procedural Programming)</em></strong></h2>
    <p>위에서부터 아래로의 순차적인 처리를 중요시 하며 루틴, 서브루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임</p>
    <ul>
      <li><strong><em>장점</em></strong>
        <ul>
          <li>컴퓨터 처리구조와 유사해 실행속도가 빠르다.</li>
        </ul>
      </li>
      <li><strong><em>단점</em></strong>
        <ul>
          <li>코드가 길어지면 가독성이 떨어지며 유지보수가 어렵다.</li>
          <li>정해진 순서대로 입력을 해야하므로 순서가 바뀌면 결과를 보장할 수 없다.</li>
          <li>대형 프로젝트에 적합하지 않다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <h2 id="객체지향-프로그래밍-oop"><strong><em>객체지향 프로그래밍 (OOP)</em></strong></h2>
    <p>모든 것을 객체로 취급하고 객체가 처리요청을 받았을 때, 객체 내부의 기능을 사용해 처리하는 방법이다.
<br />
클래스 디자인과 객체들의 관계를 중심으로 설계가 이루어진다.
<br />
따라서, 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있고, 멤버변수가 어떤 상태를 가지고 있는가에 따라 결과가 달라진다.</p>
    <ul>
      <li><strong><em>특징</em></strong>
        <ul>
          <li>캡슐화 - 정보를 은닉하고 노출시키지 않는다.</li>
          <li>추상화 - 공통적인 속성이나 기능을 묶는다.</li>
          <li>상속 - 아래 더 자세히..</li>
          <li>다형성 - 아래 더 자세히..</li>
        </ul>
      </li>
      <li><strong><em>장점</em></strong>
        <ul>
          <li>재사용에 용이하다. (확장, 유지보수)</li>
          <li>분석과 설계의 전환이 쉽다.</li>
        </ul>
      </li>
      <li><strong><em>단점</em></strong>
        <ul>
          <li>처리속도가 상대적으로 느리다.</li>
          <li>모든 객체의 역할과 기능을 설계해야 하기 때문에 많은 시간이 소요된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <h2 id="함수형-프로그래밍"><strong><em>함수형 프로그래밍</em></strong></h2>
    <p>순수함수를 사용해 상태를 제어하지 않고 빠른 처리에 집중하는 방식, 함수 자체가 일급객체가 된다. 
<br />
OOP와는 데이터(상태)를 다루는 개념과, 간결한 코드 작성에 대한 관점차이가 있다.
<br />
<br />
<strong><em>일급객체</em></strong> - 다른 요소들과 아무런 차별이 없는 객체, 함수를 변수로 사용할 수 있다는 의미도 된다.
<br /></p>

    <ul>
      <li><strong><em>장점</em></strong>
        <ul>
          <li>함수가 하는일은 명확하기 때문에 코드의 가독성이 좋아지고 테스트가 쉬워진다.</li>
          <li>값이 한번 변수에 할당되면 이후에 변경되지 않기 때문에 부수효과가 발생하지 않으며 참조투명성을 가진다. 즉, 멀티코어 프로세스에서 교착상태에 빠지지 않는다.</li>
          <li>동시성 프로그래밍에 용이하다.</li>
        </ul>
      </li>
      <li><strong><em>단점</em></strong>
        <ul>
          <li>상태의 조작이 불가능하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <h2 id="그래서-뭐가-좋은데"><strong><em>그래서 뭐가 좋은데?</em></strong></h2>
    <p>자바8에서 함수형 프로그래밍을 도입했다. 
<br />
객체지향을 추구하는 자바진영에서 왜 함수형 프로그래밍을 도입했을까?
<br />
데이터 자체를 핸들링하는 함수형 프로그래밍은 어떤 데이터가 들어가도 로직 수행 후 의도한 데이터를 리턴한다. 
하지만 객체지향은 여기에 상태까지 관리해 줘야 하기 때문에 신경 쓸것이 많다. 
<br />
현대 어플리케이션은 함수형과 객체지향을 모두 사용한다. 
<br />
예를들면, 내가 매일 작업하는 로직들은 함수형 이지만, 디비에 접근하는 순간만큼은 함수형일 수가 없다. 
<br />
데이터를 저장해야 하고 값을 리턴받아야 하고 등의 상태값이 존재하기 때문이다. 
<br />
이외에도 여러가지가 있겠지만 자바8에 추가된 람다의 함수형 프로그래밍도 이와 같다. 
<br />
람다로 코드를 짤 경우 데이터의 무결성을 보장한다. 
<br />
왜냐하면 전통적인 for루프의 경우 객체를 작업하지만 람다의 경우 데이터 그 자체를 핸들링 하기 때문이다.
<br />
결국 시대의 흐름에 맞게 병렬 프로세싱을 잘 활용하기위해 자바 8에서 도입을 했고 
<br />
뭐가 더 좋다기 보단 둘다 적재적소에 사용하는게 중요하겠다.</p>
  </li>
</ul>

<p><br /></p>

<h2 id="자바의-type">자바의 Type</h2>
<h3 id="primitive-type원시타입">Primitive Type(원시타입)</h3>
<hr />
<ul>
  <li>정수, 실수, 문자, 논리 리터럴등의 실제 데이터값을 저장하는 타입</li>
  <li>기본값이 있기때문에 Null이 존재하지 않는다. 기본형 타입에 Null을 넣고싶다면 래퍼클래스를 활용한다.</li>
  <li>제네릭 타입에서 사용할 수 없다.</li>
  <li>실제값을 저장하는 공간으로 Stack 영역에 저장된다.</li>
  <li>실제값이 Stack영역에 있으므로 참조타입보다 접근속도가</li>
</ul>

<p><br /></p>

<h3 id="reference-type참조타입">Reference Type(참조타입)</h3>
<hr />
<ul>
  <li>객체의 주소를 저장하는 타입으로 메모리 번지값을 통해 객체를 참조하는 타입</li>
  <li>기본형 타입을 제외한 모든 타입은 참조형 타입이다. (문자열, 배열, 클래서, 열거, 인터페이스 등)</li>
  <li>제네릭 타입에서 사용할 수 있다.</li>
  <li>실제 객체는 Heap 영역에 저장되고 Stack영역에 객체의 주소를 저장해서 참조한다.</li>
  <li>실제값이 Heap 영역에 있고 Stack메모리에는 참조값만 있으므로 값이 필요할 때마다 최소 2번 메모리 접근을 해야하고 박싱/언박싱 과정을 거쳐야 해서 원시타입보다 접근속도가 느리다.</li>
  <li>실제 사용하는 메모리양도 원시타입보다 월등히 많다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>String?</em></strong>
    <ul>
      <li>참조타입에 속하지만 기본적인 사용은 원시타입이다.</li>
      <li>불변객체이다. 그래서 String 클래스의 값을 변경하는 메소드를 사용해도 값이 변경되는 것이 아닌 새로운 String 객체를 만든다.</li>
      <li>기본형 비교는 == 사용이지만 String 간 객체비교는 equals()메소드를 사용한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="wrapper-class">wrapper Class</h2>
<p>원시타입을 객체로 다루기 위해 사용하는 클래스이다. 기본타입의 값을 내부에 두고 포장해서 포장객체 라고도 불리는데 래퍼클래스로 감싸고 있는 값은 외부에서 변경이 불가능하고 변경하려면 새로운 포장객체를 만들어야 한다. 자바의 모든 객체가 그러하듯 Object를 상속받는다.</p>

<p><br /></p>

<h3 id="박싱--언박싱">박싱 / 언박싱</h3>
<hr />
<ul>
  <li>원시타입을 포장객체로 만드는게 박싱, 반대로 포장객체에서 원시타입을 얻는게 언박싱이다.</li>
  <li>JDK 1.5 이후로 오토 박싱/언박싱을 지원 한다.</li>
  <li>래퍼객체 내부값을 비교하려면 equals를 사용해야 한다. == 는 래퍼 객체의 참조 주소를 비교하기 때문이다.</li>
  <li>래퍼클래스와 원시타입 비교는 둘다 가능하다. JDK 1.5 이후로 오토 박싱/언박싱을 지원하기 때문이다</li>
</ul>

<p><br /></p>

<h3 id="왜-쓰는데">왜 쓰는데?</h3>
<hr />
<ul>
  <li>원시타입을 클래스화 하여 클래스의 장점을 활용할 수 있다. (클래스에 지원되는 여러 메소드들)</li>
  <li>null 지원</li>
  <li>기본타입을 객체로 써야할 경우가 있음
    <ul>
      <li>ex) <strong><em>List&lt;</em></strong>Integer<strong><em>&gt;</em></strong> 에 원시타입 <strong><em>int</em></strong> 값을 넣는다던가… (오토박싱/언박싱 지원)</li>
    </ul>
  </li>
  <li>제네릭에 원시타입은 쓸수가 없음</li>
  <li><strong><em>일급콜렉션</em></strong>
    <ul>
      <li>콜렉션을 래핑할때, 그 외에 다른 멤버변수가 없는 상태를 일급콜렉션 이라한다.</li>
      <li>이렇게 되면 하나의 인스턴스에서 비즈니스 로직을 관리할 수 있게 되는 장점이 있다.
        <ul>
          <li>ex) 같은 객체를 여러개 생성해야 할때, 이 모든 인스턴스들을 담는 일급콜렉션을 만들다던가..</li>
          <li>비즈니스 로직을 도메인에서 관리 (비즈니스에 종속적인 자료구조를 만들 수 있음)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="동일성과-동등성">동일성과 동등성</h2>
<h3 id="동일성">동일성</h3>
<hr />
<ul>
  <li>두 객체가 완전히 같은 경우.
<br />
주소값이 같기 때문에 하나의 객체로 봐도 무방하며 두 변수가 같은 객체를 참조한다.</li>
  <li>== 연산자를 사용해 판별할 수 있다.</li>
  <li>원시타입은 객체가 아닌 스택메모리에 직접 값이 올라가기 때문에 == 결과가 같으면 동일하다.</li>
</ul>

<p><br /></p>

<h3 id="동등성">동등성</h3>
<hr />
<ul>
  <li>두 객체가 같은 정보를 가지고 있는 경우.
<br />
두 객체의 주소가 달라도 내용이 같으면 동등하다고 말할 수 있다.</li>
  <li>equals를 사용해 판별할 수 있다.</li>
  <li><strong><em>equals</em></strong>
    <ul>
      <li>equals 메소드를 재정의 하지 않으면 == 연산자와 다르지 않다.</li>
      <li>객체에서 재정의 할 경우 == 연산자를 통해 두객체가 동일하면 true를 반환하고, 다르다면 동등성을 판단한다.
  재정의 하지 않을 경우 동일성 여부만 판단하기 때문에 동등성비교가 필요하다면 꼭 재정의 해주어야 한다.</li>
    </ul>
  </li>
  <li><strong><em>hashcode?</em></strong>
    <ul>
      <li>equals를 재정의 해줄 때, hashcode도 같이 재정의하는걸 권장한다. 이유가 무엇일까?</li>
      <li>Hash Table을 사용하는 자료형일 경우 문제가 된다. 
  <br />
  동등한 객체 2개를 생성해서 Set에 담게되면 의도한 대로 담기지 않는다. 
  <br />
  Set 자료구조는 중복을 허용하지 않기 때문인데, Hash Table을 사용하는 자료형은 해싱 알고리즘을 사용한다. 해싱된 결과를 주소값으로 찾아가서 같은 자료가 있는지 확인하는데 동등한 두 객체는 다른 주소값을 가지고 있기 때문에 객체의 동등성을 위해 equals메소드와 hashcode메소드는 같이 오버라이드 되어야 지만 동등성을 보장받을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h1 id="to-do">To Do</h1>

<p><br /></p>

<h2 id="자바의-접근제어자">자바의 접근제어자</h2>
<p>객체지향 패러다임에서 정보은닉이란 필요한 정보만 오픈한다는 개념이다.
<br />
자바에서는 정보은닉을 위해 접근제어자 라는 기능을 제공하여 클래스 외부에서 직접적인 접근을 허용하지 않는
변수, 메서드, 생성자를 설정할 수 있다.
<br />
<strong><em>단, 인터페이스의 접근제어자는 무조건 public 이다.</em></strong> 
<br />
인터페이스는 구현클래스가 아니라 추상클래스 이기 때문에
해당 인터페이스를 구현하는 구현클래스에서 구현이 꼭 필요하다. 그렇기 때문에 접근제어자를 생략하더라도 컴파일시 public으로 열어둔다.
<br />
또한 클래스의 접근제한은 public 과 default만 적용할 수 있다.</p>

<p><br /></p>

<ul>
  <li>
    <p><strong><em>private</em></strong>
<br />
private 으로 선언한 메서드나 변수는 해당 클래스 내에서만 접근이 가능하다.
<br />
외부에 공개되지 않으며, 외부에서는 private멤버에 직접 접근이 불가능하며 해당 객체의 public 메소드를
<br />
통해서만 접근이 가능하다.
<br />
그래서 보통 private 멤버는 클래스 내부의 세부적인 로직을 수행하는데 사용된다.
<br />
또한 생성자를 private 으로 생성하여 인스터스화를 방지할 수 있다.</p>
  </li>
  <li>
    <p><strong><em>public</em></strong>
<br />
public으로 선언된 클래스 멤버는 외부에서 접근이 가능하며, 프로그램 어디에서도 접근이 가능하다.
자바는 public메소드를 통해서만 해당 객체의 private멤버에 접근할수 있고, 따라서 public 메소드는 private 멤버와 외부사이의
인터페이스 역할을 수행한다고 할 수 있다.</p>
  </li>
  <li>
    <p><strong><em>default</em></strong>
<br />
아무것도 선언하지 않으면 default 접근자가 붙는다. 같은 패키지내에서만 접근이 가능하다.</p>
  </li>
  <li>
    <p><strong><em>protected</em></strong>
<br />
default 접근제어자 처럼 같은패키지 내에서 접근이 가능하지만, 좀더 범위가 넓다.
<br />
protected멤버는 부모 클래스에게는 public 멤버처럼 취급되며, 외부에서는 private 멤버로 취급된다.
<br />
결국 protected로 선언된 멤버는 아래와 같은 접근 영역을 가진다.</p>
    <ul>
      <li>protected를 선언한 클래스의 멤버</li>
      <li>protected를 선언한 클래스가 속한 패키지의 멤버</li>
      <li>protected를 선언한 클래스를 상속받은 자식 클래스의 멤버</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="왜-쓰는데-1">왜 쓰는데?</h3>
<hr />
<ul>
  <li>클래스 내부의 데이터를 보호하기 위해</li>
  <li>객체지향에서 캡슐화 라고 부른다.</li>
</ul>

<p><br /></p>

<h2 id="상속">상속</h2>
<p>자바의 상속(Inheritance)은 부모클래스와 자식클래스 관계에서 발생하며,
상속을 받은 자식클래스는 부모클래스의 <strong><em>private 멤버를 제외한</em></strong> 모든 멤버를 물려받아 사용할 수 있다.
<br />
만약 둘이 다른패키지에 있다면 default접근제한을 갖는 멤버도 자식클래스에서 사용이 불가능하다.
<br />
부모클래스가 변경되면 자식클래스는 영향을 받지만 반대의 경우는 영향을 주지 않는다.
<br />
또한, 자바는 다중상속을 지원하지 않으며 단일상속만 가능하다.</p>

<ul>
  <li><strong><em>Overriding</em></strong>
<br />
부모클래스의 정의된 메서드를 자식클래스에서 수정이 필요할 경우 오버라이딩을 이용한다.
<br />
오버라이딩은 <strong><em>동일한 시그니처</em></strong>를 가져야 한다.
    <ul>
      <li>동일한 시그니처 : 메서드의 이름, 매개변수, 반환타입이 같아야 하고 중괄호 안의 내용만 바뀔 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>인터페이스 상속</em></strong>
<br />
implements 키워드로 상속받을 수 있다. 일반 상속과 다르게 인터페이스는 상속은 다중상속이 가능하다.
<br />
인터페이스를 상속받은 클래스는 반드시 인터페이스의 메소드를 재정의(@Override) 해야한다.
<br />
인터페이스 상속은 보통 설계 목적으로 구현한다.</li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><strong><em>왜 쓰는데?</em></strong>
<br />
외부로부터 다형성을 보장하면서 내부구현코드를 모두 구현하지않고 공통로직을 그대로 사용할 수 있다.
<br />
이미 만들어진 클래스를 재사용할 수 있기 때문에 효율적이며, 중복코드가 많이 줄어들게 된다.
<br />
또한 부모클래스 멤버를 사용할 경우, 수정이 필요할 때 부모클래스만 수정하면 되기때문에 유지보수에 좋다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
      <span class="nc">String</span> <span class="n">age</span><span class="o">;</span>
      <span class="nc">String</span> <span class="n">gender</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">gender</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">gender</span> <span class="o">=</span> <span class="n">gender</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">studentId</span><span class="o">;</span>
  <span class="o">}</span> 
</code></pre></div>    </div>
    <p>학생과 사람의 클래스이다. 학생도 사람이기 때문에 Person클래스가 가지는 속성을 모두 가지고 있다.
<br />
공통적인 기능을 부모클래스에 정의해두면 여러개의 자식클래스에서 사용이 가능하기때문에 확장성 또한 용이하다.
<br />
학생 클래스에서 이름 나이 성별을 정의하지 않았지만 super 키워드로 부모클래스로부터 물려받은 속성에 접근할 수 있다.
<br />
이처럼, 상속을 이용할 경우 유지보수가 좋아지고 확장성이 좋아지며 중복코드를 많이 줄일 수 있게 된다.</p>
  </li>
</ul>

<p><br /></p>
<ul>
  <li><strong><em>단점</em></strong>
<br />
    <ul>
      <li>자식클래스에서도 부모클래스의 public메서드가 외부로 노출되기 때문에 이는 <strong><em>캡슐화</em></strong>를 위반할 수 있다.</li>
      <li>클래스 간의 결합도가 높아진다.</li>
      <li>부모클래스의 버그가 생길경우, 자식클래스에 어떠한 사이드이펙트가 갈지 예측하기 어렵다.</li>
      <li>상속 구조가 복잡해 질수록 상위 클래스에서 의미있던 기능이 하위클래스에서 필요없는 기능일 수 있다.</li>
      <li>상속으로 인해 결합도가 높아질 수록 하나의 기능을 추가하거나 수정하기위해 불필요하게 많은 클래스를 추가하거나 수정해야 한다.</li>
      <li>그로인해 단일상속만 지원하는 자바에서는 오히려 중복코드의 양이 늘어날 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>어떻게 쓰면 좋을까?</em></strong>
<br />
SOLID원칙의 리스코프치환 원칙에서 알 수 있다.
<br />
<strong><em>상속받은 자식클래스는 부모클래스를 대체할 수 있을 경우에만 상속을 해야한다.</em></strong>
<br />
부모클래스의 외부로 노출되는 메서드는 자식클래스 에도 같은 의미로 제공되어야 한다고 말하고 있다. 
<br />
즉, 상속은 클래스의 행동을 확장하는 것이 아닌 정제할 때 사용하는것이 좋다.
<br />
또한 재정의 되지 않길 원하는 메서드일 경우 final 메서드로 만들어 두는것도 좋은 방법이겠다.</li>
</ul>

<p><br /></p>

<h3 id="합성compotistion">합성(Compotistion)</h3>
<hr />
<p>구현에 의존하지 않고, public interface에만 의존한다.객체 관계가 수평적인 관계가 된다.</p>
<ul>
  <li>두 객체 사이 의존성을 런타임에 해결한다. (상속은 컴파일단계에서 해결)</li>
  <li>코드의 재사용만 생각하면 상속보다는 합성을 사용하는게 좋을 수 있다.</li>
  <li>상속의 is-a 관계가 아닌 has-a관계
    <ul>
      <li><strong><em>is-a</em></strong>
        <ul>
          <li>A는 B이다. -&gt; 학생은 사람이다.</li>
          <li>추상화 사이의 포함관계를 의미한다.</li>
          <li>한 클래스 A가 다른 클래스 B의 파생클래스임을 나타낸다.</li>
          <li>is-a 관계를 통해 생성된 클래스는 상속관계에서 밀접하게 결합된다.</li>
          <li>결합도가 높기 때문에 계층구조에 좀 더 적합하다.</li>
        </ul>
      </li>
      <li><strong><em>has-a</em></strong>
        <ul>
          <li>구성 포함 관계를 의미한다. -&gt; 경찰은 총을 가진다 (경찰클래스 안에 권총클래스의 객체를 멤버로 가지고 있는 경우)</li>
          <li>한 오브젝트가 다른 오브젝트에 속한다 라고 말한다.</li>
          <li>다른 클래스의 기능(변수 혹은 메서드)를 받아들여 사용한다.</li>
          <li>객체의 멤버필드라고 불리는 객체를 말하며 계층구조를 형성하기위해 결합하는 경우를 말한다.</li>
          <li>has-a 관계를 통해 생성된 클래스는 느슨하게 결합된다.</li>
          <li>상속에 비해 변경이 발생하더라도 구성요소를 쉽게 변경할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h4 id="전략패턴strategy-pattern">전략패턴(Strategy Pattern)</h4>
<hr />
<p>합성을 이용한 디자인 패턴으로 프로그램 실행중에 알고리즘을 선택할 수 있게하는 패턴이다. 
<br />
즉, 특정 Context에서 알고리즘을 별도로 분리하는 설계 방법이다.
<br />
변하지 않는 부분을 Context에 두고 변하는 부분을 Strategy 인터페이스 구현체에 작성한다.
<br />
전략에 해당하는 Strategy인터페이스와 구현체에는 비즈니스 로직 이외에 아무런 로직이 없기때문에 공통 로직이 변경되어도 아무런 영향이 없다.
<br /><br />
<img src="/images/2021-05-10-first-posting/Strategy_Pattern.png" alt="이미지" />
<br />
<br /></p>

<ul>
  <li><strong><em>장점</em></strong>
    <ul>
      <li>런타임에 객체 내부의 알고리즘을 바꿀 수 있다.</li>
      <li>공통로직이 부모클래스에 있지 않고 Context라는 별도의 클래스에 존재하기 떄문에 구현체들에 대한 영향도가 적다.</li>
      <li>Context 가 Strategy 라는 인터페이스를 의존하고 있기 때문에 구현체를 갈아끼우기 쉽다.</li>
      <li>결국 확장에 유리하다.</li>
      <li>단일책임원칙을 지키면서 새로운 전략을 추가할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>단점</em></strong>
    <ul>
      <li>클래스로 분리된 전략에 대해 모두 알아야 한다.</li>
      <li>알고리즘 변경이 많지 않다면, 오히려 분기를 타는것보다 코드를 복잡하게 만들 수 있다.</li>
      <li>로직이 늘어날때마다 구현클래스가 늘어난다.</li>
    </ul>

    <p><br /></p>
  </li>
  <li><strong><em>어떻게 쓰는데?</em></strong>
<br />
  과일매장은 상황에 따라 다른 가격할인정책을 적용하고 있다.
    <ul>
      <li>첫손님에게 10% 할인</li>
      <li>마지막손님은 20% 할인</li>
      <li>신선도가 떨어진 과일은 20%할인
  <br />
  <br /></li>
    </ul>

    <p>할인이라는 알고리즘을 <code class="language-plaintext highlighter-rouge">DiscountPolicy</code>라는 인터페이스로 분리해보자.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">DiscountPolicy</span> <span class="o">{</span>
      <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">FirstCustomerDiscount</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.9</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">LastCustomerDiscount</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span><span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnFreshFruitDiscount</span> <span class="kd">implements</span> <span class="nc">DiscountPolicy</span><span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateWithDisCountRate</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.8</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <p>그리고 이를 <code class="language-plaintext highlighter-rouge">Calculator</code>클래스에서 생성자를 통해 필요한 하위타입을 주입받아 사용해보자.
  <br />
  이렇게 되는 경우 외부에서 특정 경우(첫번째 손님, 마지막 손님, 싱싱하지 않은 과일)에 대한 할인정책을 생성자를 통해 전달해줄 수 있다.
  <br /></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculator</span> <span class="o">{</span>
		
      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">DiscountPolicy</span> <span class="n">discountPolicy</span><span class="o">;</span>
		
      <span class="kd">public</span> <span class="nf">Calculator</span><span class="o">(</span><span class="nc">DiscountPolicy</span> <span class="n">discountPolicy</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">discountPolicy</span> <span class="o">=</span> <span class="n">discountPolicy</span><span class="o">;</span>
      <span class="o">}</span>
		
      <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
          <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
          <span class="k">for</span> <span class="o">(</span><span class="nc">Item</span> <span class="n">item</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">sum</span> <span class="o">+=</span> <span class="n">discountPolicy</span><span class="o">.</span><span class="na">calculateWithDisCountRate</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
          <span class="o">}</span>
          <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <p>아래의 경우는 첫번째 손님 할인정책을 적용하는 코드이다. 
  <br />
  일반적으로 Controller는 사용자의 요청 등을 매핑하여 받아오기 때문에 특정 알고리즘(첫번째 손님 계산)을 선택되었다는걸 알 수 있다.
  <br />
  요청에 맞는 객체를 Calculator에 주입해주는 방식을 통해 전략패턴을 구현했다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">FruitController</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Calculator</span> <span class="n">calculator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Calculator</span><span class="o">(</span><span class="k">new</span> <span class="nc">FirstCustomerDiscount</span><span class="o">());</span>
          <span class="n">calculator</span><span class="o">.</span><span class="na">calculate</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="mi">3000</span><span class="o">),</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Banana"</span><span class="o">,</span> <span class="mi">3000</span><span class="o">),</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">),</span>
              <span class="k">new</span> <span class="nf">Item</span><span class="o">(</span><span class="s">"Pitch"</span><span class="o">,</span> <span class="mi">4000</span><span class="o">)</span>
          <span class="o">));</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><br /></p>

<h3 id="상속-vs-합성">상속 vs 합성?</h3>
<hr />
<p>상속은 is-a, 합성은 has-a
<br />
결국, 코드의 재사용성 만을 위해 상속을 사용하는 방식은 여러 문제점을 가지고 있기 때문에 재사용성 뿐만 아니라 클래스간의 확실한 계층구조를 만들때 상속을 사용하며 그 외에는 의존성이 낮은 합성을 사용하는 것이 좋다고 생각이 든다.</p>

<p><br /></p>

<h2 id="다형성">다형성</h2>
<p>변화에 유연한 소프트웨어를 만들기 위한 객체지향 패러다임의 가장 중추적인 방법이다.
<br />
<code class="language-plaintext highlighter-rouge">다형성</code>이란 하나의 타입에 여러 객체를 대입할 수 있는 성질이고, 이것을 위해서 여러 객체들중 공통 특성으로
타입을 추상화하고 그것을 상속 또는 인터페이스라면 구현해야한다.
<br /></p>
<ul>
  <li><strong><em>업캐스팅</em></strong>
    <ul>
      <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 해준다.</li>
      <li>부모클래스의 인스턴스 대신 자식클래스의 인스턴스를 사용해도 메시지를 처리하는데 문제가 없으며, 컴파일러는 명시적인 타입변환 없이도 자식클래스가 부모클래스를 대체할 수 있게 허용한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>동적 바인딩</em></strong>
    <ul>
      <li>메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다.</li>
      <li>이와같이 런타임에 실행될 메서드를 결정하는 방식을 동적바인딩 혹은 지연바인딩 이라고 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li>
    <p><strong><em>오버로딩(Overloading)</em></strong>
  <br />
  자바 <code class="language-plaintext highlighter-rouge">PrintStream</code> 클래스에는 매개변수만 다른 <code class="language-plaintext highlighter-rouge">println</code>이라는 메서드가 여러개 정의되어 있다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintStream</span> <span class="o">{</span>
      <span class="o">...</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">()</span> <span class="o">{</span>
          <span class="n">newLine</span><span class="o">();</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
              <span class="n">newLine</span><span class="o">();</span>
          <span class="o">}</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="kt">char</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
              <span class="n">print</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
              <span class="n">newLine</span><span class="o">();</span>
          <span class="o">}</span>
      <span class="o">}</span>
      <span class="o">...</span>
  <span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>매개변수로 어떤 타입을 넣어주든, 모두 <code class="language-plaintext highlighter-rouge">println</code>이라는 메서드 시그니처를 호출하여 원하는 내용을 출력하는 기능을 수행한다.</li>
      <li>오버로딩은 여러종류의 타입을 받아 같은 기능을 하도록 만들기 위함이고 런타임 시점에 특정 메서드를 바인딩 할수 있다.</li>
      <li>즉, 다형성 이라고 할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>오버라이딩(Overriding)</em></strong>
  <br />
  앞서 상속에서도 정리했던 오버라이딩은 부모클래스의 메서드를 하위클래스에서 재정의 하는것을 의미한다.
  <br />
  <br />
  아래 <code class="language-plaintext highlighter-rouge">Figure</code>라는 추상클래스에서는 하위 클래스에서 오버라이딩 해야할 메서드를 정의해 두었다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Figure</span> <span class="o">{</span>
      <span class="kd">protected</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">;</span>
      <span class="kd">protected</span> <span class="kt">int</span> <span class="n">area</span><span class="o">;</span>

      <span class="kd">public</span> <span class="nf">Figure</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">dot</span> <span class="o">=</span> <span class="n">dot</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">area</span> <span class="o">=</span> <span class="n">area</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">();</span>
  <span class="o">}</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">Figure</code>를 상속받는 하위클래스 들이다.</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Triangle</span> <span class="kd">extends</span> <span class="nc">Figure</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="nf">Triangle</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">super</span><span class="o">(</span><span class="n">dot</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"넓이가 %d인 삼각형입니다."</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Square</span> <span class="kd">extends</span> <span class="nc">Figure</span> <span class="o">{</span>
      <span class="kd">public</span> <span class="nf">Square</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">dot</span><span class="o">,</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">area</span><span class="o">)</span> <span class="o">{</span>
          <span class="kd">super</span><span class="o">(</span><span class="n">dot</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>

      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"넓이가 %d인 사각형입니다."</span><span class="o">,</span> <span class="n">area</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
    <ul>
      <li>이런식으로 새로운 도형 객체가 추가될 때 <code class="language-plaintext highlighter-rouge">Figure</code>를 상속받고 메서드를 재정의 해주면 실제로 사용되는 비즈니스로직의 변경을 최소화 할 수 있다.</li>
      <li>다형성을 사용하지 않고 도형 객체를 추가하려고 하면 if-else 분기가 늘어나게 되버린다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong><em>함수형 인터페이스(Funtional Interface)</em></strong>
  <br />
  람다식을 사용하기 위한 API로 자바에서 제공하는 인터페이스에 구현할 메서드가 하나 뿐인 인터페이스 이다.
  <br />
  <code class="language-plaintext highlighter-rouge">enum</code>과 함께 사용할 시 다형성의 장점을 경험할 수 있다.
  <br />
  <br />
  문자열 계산기 이다.
  <br />
  각각의 연산자를 <code class="language-plaintext highlighter-rouge">enum</code>으로 정의하고 연산 방식을 <code class="language-plaintext highlighter-rouge">BiFuntion</code>을 사용한 람다식으로 정의한다면 연산자를 추가 해야 할 때, <code class="language-plaintext highlighter-rouge">enum</code>에만 추가해주면 실제로 연산을 수행하는 <code class="language-plaintext highlighter-rouge">calculate</code> 메서드는 아무 수정없이 기능확장을 할 수 있다.
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Operator</span> <span class="o">{</span>
      <span class="no">PLUS</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">),</span>
      <span class="no">MINUS</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">),</span>
      <span class="no">MULTIPLY</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="o">),</span>
      <span class="no">DIVIDE</span><span class="o">(</span><span class="s">"/"</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="o">);</span>

      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">sign</span><span class="o">;</span>
      <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BiFunction</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">bi</span><span class="o">;</span>

      <span class="nc">Operator</span><span class="o">(</span><span class="nc">String</span> <span class="n">sign</span><span class="o">,</span> <span class="nc">BiFunction</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">bi</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">this</span><span class="o">.</span><span class="na">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="o">;</span>
          <span class="k">this</span><span class="o">.</span><span class="na">bi</span> <span class="o">=</span> <span class="n">bi</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">long</span> <span class="n">a</span><span class="o">,</span> <span class="kt">long</span> <span class="n">b</span><span class="o">,</span> <span class="nc">String</span> <span class="n">sign</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Operator</span> <span class="n">operator</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">values</span><span class="o">())</span>
                  <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">v</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">.</span><span class="na">sign</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">sign</span><span class="o">))</span>
                  <span class="o">.</span><span class="na">findFirst</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(</span><span class="nl">IllegalArgumentException:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>

          <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="na">bi</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="접근제어자" /><category term="상속" /><category term="다형성" /><category term="Wrapper Class" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">22.12</title><link href="http://localhost:4000/til/1-TIL/" rel="alternate" type="text/html" title="22.12" /><published>2022-12-04T00:00:00+09:00</published><updated>2022-12-04T00:00:00+09:00</updated><id>http://localhost:4000/til/1-TIL</id><content type="html" xml:base="http://localhost:4000/til/1-TIL/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="lombok">lombok</h1>
<h2 id="getter---prefix">@getter - prefix</h2>
<p>lombok은 boolean 타입일 때 변수의 prefix가 is인 경우 getIsXXX 대신 isXXX 으로 get메서드를 만들어준다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">lombok.Getter</span><span class="o">;</span>

<span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이때 @Getter 로 만들어진 메서드는 getIsMan() 가 아니고 isMan() 가 된다.
<br />
결국 이 DTO 를 받을 경우 아래와 같다.</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="nl">"man"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p><strong><em>해결방법 1. boolean -&gt; Boolean</em></strong>
<br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>원시타입 대신 래퍼타입을 사용한다.
<br />
하지만 래퍼타입이라 null값이 들어가게 되므로 지양하자
<br />
<br />
<strong><em>해결방법 2. get 메서드 직접 작성</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">getIsMan</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">isMan</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="builder">@Builder</h2>
<p>생성자 대신 builder 패턴 적용</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="nd">@Builder</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 사용</span>
    <span class="nc">Person</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">name</span><span class="o">(</span><span class="s">"이름"</span><span class="o">).</span><span class="na">age</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
같은 이름과 같은 매게변수를 가진 메서드가 있으면 @Getter는 메서드를 생성하지 않는다.</p>

<h2 id="noargsconstructor">@NoArgsConstructor</h2>
<p>파라미터 없는 기본생성자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 기본생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="allargsconstructor">@AllArgsConstructor</h2>
<p>모든 필드값을 파라미터로 받는 생성자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 모든 필드를 가진 생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="requireargsconstructor">@RequireArgsConstructor</h2>
<p>final이나 @NonNull인 필드 값만 파라미터로 받는 생성자 생성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequireArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span> 
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// final이나 @NonNull인 필드를 가진 생성자 생성</span>
<span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="data">@Data</h2>
<p>@Getter @Setter @ToString @EqualsAndHashCode @RequiredArgsConstructor 자동생성
<br />
최대한 지양하자</p>
<ul>
  <li>무분별한 getter / setter 남용</li>
  <li>ToString으로 인한 양방향 연관관계시 순환 참조 문제</li>
</ul>

<p><br /></p>

<h1 id="maven--gradle">maven / gradle</h1>
<p>빌드관리도구
<br /></p>
<ul>
  <li>소스코드에서 어플리케이션 생성을 하면서 여러가지 여부 라이브러리를 사용하는데, 빌드 관리 도구는 사용자가 직접 관리할 필요 없이 필요한 라이브러리들을 자동으로 관리한다.</li>
</ul>

<h2 id="maven">maven</h2>
<ul>
  <li>java용 프로젝트 관리 도구로 Apache 의 Ant 대안으로 만들어졌다.</li>
  <li>빌드중인 프로젝트, 빌드순서, 외부라이브러리 종속성 관계를 pom.xml파일에 명시</li>
  <li>멀티프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 <strong><em>상속</em></strong>방식 사용</li>
</ul>

<h2 id="gradle">gradle</h2>
<ul>
  <li>JVM의 스크립트 언어인 groovy로 만들어졌다.</li>
  <li>멀티프로젝트에서 특정 설정을 다른 모듈에서 사용하려면 <strong><em>설정주입</em></strong>방식 사용</li>
</ul>

<h2 id="maven-vs-gradle">maven vs gradle</h2>
<ul>
  <li>gradle 은 빌드시 <strong><em>변경된 파일만 작업</em></strong>하기 때문에 maven 보다 빠름 (10~100배)</li>
  <li>gradle 은 스크립트 언어로 프로젝트가 커질수록 가독성이 maven 보다 좋음</li>
  <li>gradle 이 멀티 프로젝트에 maven보다 적합하다.</li>
</ul>

<p><br /></p>

<h1 id="oom-java-out-of-memory">OOM (java Out Of Memory)</h1>
<h2 id="자바의-메모리">자바의 메모리</h2>
<p>자바는 가비지컬렉터로 메모리 관리를 한다.
<br />
덕분에 개발자는 메모리에 큰 신경을 쓰지 않고 코드를 작성할수 있다
<br />
하지만 가비지컬렉터가 정리해야 할 메모리가 정리되지 못하고 계속 메모리에 남아있게 되는걸 Memory Leak(메모리 누수)
라고 한다. 
<br />
메모리 릭이 계속 될 경우 결국 JVM이 종료되고 만다. 
<br />
메모리 릭의 양이 아주 작고 메모리는 많은 경우에는 주기적으로 JVM을 재시작 하면서 크게 신경안써도 될 경우도 있지만, 메모리릭이 빠르게 증가하는 경우에는 반드시 해결해줘야 한다</p>

<h2 id="왜-발생">왜 발생?</h2>
<p>메모리가 부족하기 때문이다. 한정된 서버 자원에 여러 어플리케이션을 띄운다던가
<br />
static같은 정적 메모리를 남발하여 지워지지 않고 계속 쌓일경우 이다.</p>

<h2 id="어떻게-찾을까">어떻게 찾을까?</h2>
<ol>
  <li>JVM이 oom 에러로 정지된걸 확인</li>
  <li>정지된 JVM 메모리영역을 확인했더니 특정 영역이 Full로 가득차있고, GC후 메모리할당에 실패하는걸 확인</li>
  <li>코드레벨 (대게 싱글톤이나 static 잘못사용)</li>
  <li>쓰레드생성이나 JNI에서 oom이 일어날 경우 OS의 자원소진일 수 있다. 이경우 외부자원을 조심스럽게 쓰던지 외부자원량을 늘림</li>
  <li>외부 라이브러리가 많을 경우 문제해결이 쉽지않다. JVM옵션과 tool의 도움을 받자</li>
  <li>옵션 추가
    <ul>
      <li>JVM 시작시 -verbose:gc옵션을 추가 - 가비지콜렉션 로그를 자세히 볼수있음</li>
      <li>JVM 시작시에 -XX:+HeapDumpOnOutOfMemoryError 추가 - JVM 정지시에 힙덤프를 받아놓을수 있음</li>
      <li>JVM 시작시에  –verbose:class옵션을 추가 - 클래스 로드, 언로드 상황을 볼수 있음</li>
    </ul>
  </li>
  <li>힙덤프 내역을 분석</li>
</ol>

<h2 id="함수형">함수형</h2>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Lombok" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">이펙티브 자바 - 객체 생성과 파괴</title><link href="http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/" rel="alternate" type="text/html" title="이펙티브 자바 - 객체 생성과 파괴" /><published>2022-11-30T00:00:00+09:00</published><updated>2022-11-30T00:00:00+09:00</updated><id>http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94</id><content type="html" xml:base="http://localhost:4000/effective_java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="정적-팩토리-메소드">정적 팩토리 메소드</h1>
<p><br />
<strong><em>생성자 대신 정적 팩토리 메서드를 고려하라</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정적 팩토리 메소드 ex</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Person</span> <span class="nf">of</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자 이다.
<br />
하지만 클래스는 public 생성자와 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다.
<br /></p>

<h2 id="장점">장점</h2>
<h3 id="1-이름을-가질-수-있다">1. 이름을 가질 수 있다.</h3>

<p>생성자에 넘기는 매개변수와 생성자 만으로는 반환될 객체의 특성을 제대로 파악하기 힘들다.
<br />
그러나 정적 팩터리는 네이밍이 가능함으로 반환될 객체의 특성을 쉽게 파악할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">brand</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">String</span> <span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">brand</span> <span class="o">=</span> <span class="n">brand</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Car</span> <span class="nf">brandFrom</span><span class="o">(</span><span class="nc">String</span> <span class="n">brand</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Car</span><span class="o">(</span><span class="n">brand</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="2-호출될-때마다-인스턴스를-새로-생성하지-않을-수-있다">2. 호출될 때마다 인스턴스를 새로 생성하지 않을 수 있다.</h3>
<p>불변클래스는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 
<br />
불필요한 객체 생성을 피할 수 있다.
<br />
enum과 같이 자주 사용되는 요소의 개수가 정해져있다면 해당 개수만큼 미리 생성해놓고 
<br />
조회(캐싱)할 수 있는 구조로 만들수 있다.
<br />
정적 팩터리 메서드와 캐싱구조를 함께 사용하면 매번 새로운 객체를 생성할 필요가 없어진다.
<br />
즉, 객체 생성 비용이 큰 객체가 자주 생성된다면 성능상 이점을 볼 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LottoNumber</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_LOTTO_NUMBER</span> <span class="o">=</span> <span class="mi">45</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">LottoNumber</span><span class="o">&gt;</span> <span class="n">lottoNumberCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="no">MIN_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="no">MAX_LOTTO_NUMBER</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lottoNumberCache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LottoNumber</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">LottoNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">LottoNumber</span> <span class="nf">from</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lottoNumberCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="3-하위-객체를-반환할-수-있다">3. 하위 객체를 반환할 수 있다.</h3>
<p>상속을 사용할 때 확인할 수 있다.
<br />
클라이언트에게 구현체를 노출하지 않고 반환할 수 있고 결국 API의 개념적 무게가 가벼워 진다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">Grade</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">score</span> <span class="o">&lt;</span> <span class="mi">70</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Fail</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Pass</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Fail</span> <span class="kd">extends</span> <span class="nc">Grade</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Pass</span> <span class="kd">extends</span> <span class="nc">Grade</span> <span class="o">{}</span>
</code></pre></div></div>

<h2 id="단점">단점</h2>
<h3 id="1-상속문제">1. 상속문제</h3>
<p>인스턴스 통제 클래스를 구현하기 위해서는 new 키워드를 사용하여 임의로 객체를 생성함을 막아야한다. 
<br />
이를 위해 생성자의 접근 제어자를 private 로 설정해야하는데, 생성자가 private 인 클래스는 상속을 할 수 없다. 
<br />
즉, 부모 클래스가 될 수 없다.
<br />
이 제약은 컴포지션을 사용하도록 유도하고 불변타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로
받아들여 진다는데, 
<br />
이해가 가지 않는다. 이펙티브 자바를 조금더 공부해 보자</p>

<h3 id="2-정적-팩터리-메서드는-프로그래머가-찾기-어렵다">2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.</h3>

<h2 id="네이밍-컨벤션">네이밍 컨벤션</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">from</code> : 하나의 매개 변수를 받아서 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">of</code> : 여러개의 매개 변수를 받아서 객체를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">getInstance</code> &amp; <code class="language-plaintext highlighter-rouge">instance</code> : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">newInstance</code> &amp; <code class="language-plaintext highlighter-rouge">create</code> : 새로운 인스턴스를 생성</li>
  <li><code class="language-plaintext highlighter-rouge">get[OtherType]</code> : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.</li>
  <li><code class="language-plaintext highlighter-rouge">new[OtherType]</code> : 다른 타입의 새로운 인스턴스를 생성.</li>
</ul>]]></content><author><name>NNIIE</name></author><category term="Effective_Java" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">22.11</title><link href="http://localhost:4000/til/TIL/" rel="alternate" type="text/html" title="22.11" /><published>2022-11-24T00:00:00+09:00</published><updated>2022-11-24T00:00:00+09:00</updated><id>http://localhost:4000/til/TIL</id><content type="html" xml:base="http://localhost:4000/til/TIL/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="equals--hashcode">equals &amp; hashcode</h1>
<p>Object 클래스의 메소드이다.
<br />
모든 클래스가 Object를 상속받기 때문에
<br />
어떤 객체라도 Object의 메소드인 equals와 hashcode를 사용할 수 있다.
<br /></p>

<h2 id="equals">equals</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Object의 equals()</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>equals()는 오로지 참조값(객체의 주소값)이 같은지 즉, 동일 객체인지 확인하는 기능이다.
<br />
equals 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 반환한다.
<br />
논리적으로 동등하다는 것은 둘의 참조값이 다르더라도 객체 내부의 value는 같다는걸 의미한다.
<br /></p>
<ul>
  <li><strong><em>동일성</em></strong> : ==비교. 객체 인스턴스 주소 값을 비교</li>
  <li><strong><em>동등성</em></strong> : equals() 메소드를 사용해 객체 내부의 값을 비교한다.</li>
</ul>

<h2 id="hashcode">hashcode</h2>
<p>객체 해시코드란 객체를 식별하는 하나의 정수값을 말한다. 
<br />
Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다.
<br /><br />
<strong><em>hashcode 를 재정의 하지 않으면</em></strong></p>
<ul>
  <li>같은 값을 가진 객체가 서로 다른 해시값을 갖게 될 수 있다.</li>
  <li>특히 HashMap의 key 값으로 해당 객체를 사용할 경우 문제가 발생한다.</li>
</ul>

<h3 id="hashtable">HashTable</h3>
<p>HashTable은 &lt;key,value&gt; 형태로 데이터를 저장한다. 이 때 해시 함수(Hash Function)을 이용하여 key값을 기준으로 고유한 식별값인 해시값을 만든다. (hashcode가 해시값을 만드는 역할을 한다.) 
<br />
이 해시값을 버킷(Bucket)에 저장한다.
<br />
하지만 HashTable 크기는 한정적이기 때문에 같은 서로 다른 객체라 하더라도 같은 해시값을 갖게 될 수도 있다.
<br />
이것을 <strong>해시 충돌(Hash Collisions)</strong>이라고 한다.
<br />
이런 경우 아래와 같이 해당 버킷(Bucket)에 LinkedList 형태로 객체를 추가한다.
<br /><br />
이처럼 같은 해시값의 버킷 안에 다른 객체가 있는 경우 equals 메서드가 사용된다.
<br /><br />
HashTable에 put 메서드로 객체를 추가하는 경우
<br /></p>
<ul>
  <li>값이 같은 객체가 이미 있다면(equals()가 true) 기존 객체를 덮어쓴다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) 해당 entry를 LinkedList에 추가한다.
<br /><br /></li>
</ul>

<p>HashTable에 get 메서드로 객체를 조회하는 경우</p>

<ul>
  <li>값이 같은 객체가 있다면 (equals()가 true) 그 객체를 리턴한다.</li>
  <li>값이 같은 객체가 없다면(equals()가 false) null을 리턴한다.</li>
</ul>

<h2 id="equals-와-hashcode를-같이-재정의-하는-이유">equals() 와 hashcode()를 같이 재정의 하는 이유</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">LottoNumber</span> <span class="n">that</span> <span class="o">=</span> <span class="o">(</span><span class="nc">LottoNumber</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">(),</span> <span class="n">that</span><span class="o">.</span><span class="na">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">getLottoNumbers</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>만약 equals()와 hashcode() 중 하나만 재정의 하면 어떻게 될까?
<br /> 
위 예에서도 봤듯이 hashcode()를 재정의 하지 않으면 같은 값 객체라도 해시값이 다를 수 있다. 따라서 HashTable에서 해당 객체가 저장된 버킷을 찾을 수 없다.
<br />
반대로 equals()를 재정의하지 않으면 hashcode()가 만든 해시값을 이용해 객체가 저장된 버킷을 찾을 수는 있지만 해당 객체가 자신과 같은 객체인지 값을 비교할 수 없기 때문에 null을 리턴하게 된다. 
<br />
따라서 역시 원하는 객체를 찾을 수 없다.
<br />
이러한 이유로 객체의 정확한 동등 비교를 위해서는 (특히 Hash 관련 컬렉션 프레임워크를 사용할때!) Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.</p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Java" /><summary type="html"><![CDATA[]]></summary></entry></feed>