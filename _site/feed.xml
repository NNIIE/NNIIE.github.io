<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-16T02:37:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NNIIE</title><subtitle>nniie의 블로그 입니다</subtitle><author><name>NNIIE</name></author><entry><title type="html">토비의 스프링 1</title><link href="http://localhost:4000/til/%ED%86%A0%EB%B9%84%EC%9D%98%EC%8A%A4%ED%94%84%EB%A7%811/" rel="alternate" type="text/html" title="토비의 스프링 1" /><published>2023-03-16T00:00:00+09:00</published><updated>2023-03-16T00:00:00+09:00</updated><id>http://localhost:4000/til/%ED%86%A0%EB%B9%84%EC%9D%98%EC%8A%A4%ED%94%84%EB%A7%811</id><content type="html" xml:base="http://localhost:4000/til/%ED%86%A0%EB%B9%84%EC%9D%98%EC%8A%A4%ED%94%84%EB%A7%811/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="1장">1장</h1>
<h2 id="11--15">1.1 ~ 1.5</h2>
<p>DAO 예제를 차차 리팩토링 해나가는 과정이다.
<br />
SOLID 원칙, 디자인패턴, 인터페이스, IoC
<br /></p>

<ol>
  <li>메서드로 DB Connection 에 대한 관심사의 분리</li>
  <li>팩토리 메서드 적용</li>
  <li>인터페이스 도입</li>
  <li>스프링 적용</li>
</ol>

<p><br /></p>

<h2 id="16-싱글톤">1.6 싱글톤</h2>
<ul>
  <li><strong>Application Context 는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이기도 하다.</strong></li>
  <li><strong>스프링은 빈 오브젝트를 기본값으로 모두 싱글톤으로 생성 (디자인패턴의 싱글톤 패턴과는 구현방법이 다름)</strong>
    <ul>
      <li>스프링은 엔터프라이즈 서버환경에서 주로 사용</li>
      <li>클라이언트 요청이 올때마다 각각의 오브젝트를 새로 생성하는건 매우 비효율적</li>
    </ul>
  </li>
  <li><strong>싱글톤 패턴의 한계</strong>
    <ul>
      <li>private 생성자로 인한 상속 불가능</li>
      <li>테스트 하기 어려움</li>
      <li>멀티 JVM 환경에서 유일한 인스턴스가 보장되지 않음</li>
    </ul>
  </li>
  <li><strong>싱글톤 레지스트리</strong>
    <ul>
      <li>생명주기, 관계설정, 사용등의 제어권을 컨테이너에게 넘김</li>
      <li>덕분에 public 생성자를 가질 수 있음</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="17-di">1.7 DI</h2>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="toby-spring" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Spring MVC</title><link href="http://localhost:4000/til/Spring_MVC/" rel="alternate" type="text/html" title="Spring MVC" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><id>http://localhost:4000/til/Spring_MVC</id><content type="html" xml:base="http://localhost:4000/til/Spring_MVC/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="서블릿">서블릿</h1>
<ul>
  <li>HTTP 요청에 대한 동적인 처리를 담당</li>
  <li>서블릿 컨테이너를 통해 실행</li>
  <li>멀티스레드 환경에서 안전하게 동작</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="서블릿-리스너--필터">서블릿 리스너 / 필터</h1>
<p><br />
<strong>리스너</strong>
<br />
<br />
웹 어플리케이션이 시작 / 종료 될 때 이벤트를 처리하는 인터페이스
<br />
web.xml 파일에서 설정할 수 있으며, 해당 이벤트가 발생할 때마다 서블릿 리스너가 호출된다</p>
<ul>
  <li><strong>웹 어플리케이션 시작 / 종료 때의 이벤트</strong>
    <ul>
      <li>시작할 때 초기화 작업등의 수행</li>
      <li>종료될 때 자원정리 작업등의 수행</li>
    </ul>
  </li>
  <li><strong>세션이 생성 / 종료 될 때의 이벤트</strong>
    <ul>
      <li>세션 생성 / 종료 시 로그 작성등의 추가작업 수행</li>
    </ul>
  </li>
  <li><strong>요청이 들어올 때의 이벤트</strong>
    <ul>
      <li>요청 전 / 후 로깅, 보안 작업등의 추가작업 수행</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>필터</strong>
<br />
<br />
웹 애플리케이션에서 HTTP 요청을 가로채고, 이를 처리하는 기능을 제공하는 컴포넌트
<br />
web.xml 파일에서 설정할 수 있으며, 필터 체인에서 여러 필터를 연결하여 처리할 수 있.
<br />
필터 체인에서는 필터의 순서가 중요하며, 설정된 순서대로 필터가 처리된다.</p>
<ul>
  <li>init(): 필터 초기화 작업 수행</li>
  <li>doFilter(): 요청을 가로채고 처리하는 작업 수행</li>
  <li>
    <p>destroy(): 필터 종료 작업 수행</p>
  </li>
  <li>인증 및 권한 부여</li>
  <li>요청 / 응답 데이터 변환 및 암호화</li>
  <li>캐싱 및 압축</li>
  <li>로깅</li>
  <li>예외 처리</li>
</ul>

<p><br /></p>

<p><strong>둘의 차이</strong>
<br />
<br />
리스너는 어플리케이션이 시작 / 종료 될 때 발생하는 이벤트를 처리하고
<br />
필터는 HTTP 요청을 가로채고 처리하는 기능을 제공한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스프링-ioc-컨테이너-연동">스프링 IoC 컨테이너 연동</h1>
<ul>
  <li><strong>스프링 컨텍스트 로더 설정</strong>
    <ul>
      <li>web.xml 파일에 ContextLoaderListener를 설정하여 스프링 IoC 컨테이너를 로딩하고, 스프링 IoC 컨테이너에서 생성한 객체를 사용할 수 있다.</li>
    </ul>
  </li>
  <li><strong>어노테이션 연동</strong>
    <ul>
      <li>컨트롤러나 서비스 클래스 등에서 @Autowired 어노테이션을 이용하여 스프링 IoC 컨테이너에서 생성한 객체를 주입받아 사용할 수 있다.</li>
    </ul>
  </li>
  <li><strong>스프링 MVC 프레임워크</strong>
    <ul>
      <li>DispatcherServlet이 스프링 IoC 컨테이너를 로딩하고, 요청 처리를 위해 컨트롤러와 서비스 클래스를 스프링 IoC 컨테이너에서 생성한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스프링-mvc-연동">스프링 MVC 연동</h1>
<ul>
  <li><strong>DispatcherServlet 설정</strong>
    <ul>
      <li>클라이언트로부터 들어오는 모든 요청을 받아서 처리하는 핵심 컨트롤러</li>
      <li>web.xml 파일에 DispatcherServlet을 등록하고, 스프링 MVC 설정 파일을 지정</li>
    </ul>
  </li>
  <li><strong>Handler Mapping 설정</strong>
    <ul>
      <li>요청 URL과 컨트롤러 클래스를 매핑하는 역할을 한다.</li>
      <li>설정파일에서 지정</li>
    </ul>
  </li>
  <li><strong>View Resolver 설정</strong>
    <ul>
      <li>논리적인 View 이름을 실제 View객체와 매핑하는 역할을 한다.</li>
      <li>설정파일에서 지정</li>
    </ul>
  </li>
  <li><strong>컨트롤러 클래스 작성</strong>
    <ul>
      <li>클라이언트의 요청을 처리하는 역할을 한다.</li>
      <li>Controller는 사용자 입력값을 받아서 처리한 후 반환된 모델 객체를 DispatcherServlet에 반환</li>
      <li>@Controller 어노테이션을 사용하여 정의</li>
      <li>@RequestMapping 어노테이션을 사용하여 URL 매핑을 설정</li>
    </ul>
  </li>
  <li><strong>뷰 작성</strong>
    <ul>
      <li>JSP, Thymeleaf 등 다양한 형태로 작성 가능</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="dispatcherservlet">DispatcherServlet</h1>
<p>스프링 MVC에서 클라이언트로부터 들어오는 모든 요청을 받아서 처리하는 핵심 컨트롤러이다.</p>
<ul>
  <li><strong>요청 분배</strong>
    <ul>
      <li>요청 URL과 HandlerMapping을 비교하여 요청을 처리할 컨트롤러 객체를 찾는다.</li>
      <li>이후, 해당 컨트롤러 객체를 실행하고, 컨트롤러에서 반환된 모델 데이터를 View 객체로 변환하여 응답</li>
    </ul>
  </li>
  <li><strong>요청 처리</strong>
    <ul>
      <li>HandlerAdapter를 사용하여 요청 처리를 위한 메서드를 호출</li>
      <li>메서드는 컨트롤러 객체에서 정의한 로직을 수행하고, 반환된 모델 데이터를 DispatcherServlet에 반환</li>
    </ul>
  </li>
  <li><strong>예외 처리</strong>
    <ul>
      <li>요청 처리 중 발생한 예외를 처리하기 위해 ExceptionResolver를 사용</li>
      <li>ExceptionResolver는 예외를 처리하고, 예외 발생 시 처리할 View 객체를 반환</li>
    </ul>
  </li>
  <li><strong>View 처리</strong>
    <ul>
      <li>반환된 모델 데이터를 View 객체로 변환하여 응답</li>
      <li>View 객체는 ViewResolver를 사용하여 논리적인 View 이름을 실제 View 객체와 매핑하여 반환</li>
    </ul>
  </li>
  <li><strong>다국어 처리</strong>
    <ul>
      <li>LocaleResolver를 사용하여 클라이언트의 언어 설정을 확인하고, 이를 기반으로 다국어 처리를 수행</li>
    </ul>
  </li>
  <li>이외에도 인터셉터를 이용하여 요청 전/후 추가작업을 실행하는 등의 다양한 기능을 제공한다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스프링-mvc-구성요소">스프링 MVC 구성요소</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스프링-mvc-동작-원리">스프링 MVC 동작 원리</h1>

<ul>
  <li><strong>DispatcherServlet</strong>
    <ul>
      <li>클라이언트로부터 요청이 들어오면, DispatcherServlet이 해당 요청을 받는다.</li>
      <li>DispatcherServlet은 요청을 처리하기 위해 다양한 컴포넌트들과 상호작용하며, 요청과 응답을 처리하는데 필요한 기능들을 제공</li>
    </ul>
  </li>
  <li><strong>HandlerMapping</strong>
    <ul>
      <li>HandlerMapping을 통해 요청 URL에 해당하는 Controller를 찾는다.</li>
      <li>HandlerMapping은 요청 URL을 컨트롤러 객체와 매핑시켜주는 역할을 함</li>
    </ul>
  </li>
  <li><strong>Controller</strong>
    <ul>
      <li>요청에 대한 작업을 수행하고, Model 객체에 결과 데이터를 담아 DispatcherServlet으로 반환</li>
      <li>@RestController 어노테이션을 사용하면 RESTful API 를 만들 수 있다.</li>
    </ul>
  </li>
  <li><strong>Model and View</strong>
    <ul>
      <li>Controller에서 반환된 Model 객체는 ViewResolver를 통해 요청 URL에 매핑되는 View로 전달</li>
      <li>View는 JSP, Thymeleaf, Freemarker 등 다양한 템플릿 엔진을 사용할 수 있다.</li>
    </ul>
  </li>
  <li><strong>Interceptor</strong>
    <ul>
      <li>DispatcherServlet과 Controller 사이에서 요청 전/후에 추가적인 로직을 수행할 수 있는 기능
        <ul>
          <li>인증, 로깅, 캐싱 등 다양한 기능을 구현 가능</li>
        </ul>
      </li>
      <li>스프링에서는 HandlerInterceptor 인터페이스를 구현하여 Interceptor를 만들 수 있다.</li>
    </ul>
  </li>
  <li><strong>Exception Handling</strong>
    <ul>
      <li>예외가 발생하면, DispatcherServlet은 등록된 ExceptionHandlerExceptionResolver를 통해 예외를 처리할 수 있는 HandlerExceptionResolver를 찾는다.</li>
      <li>HandlerExceptionResolver는 예외 처리를 위한 컨트롤러를 찾아 예외를 처리하고, ViewResolver를 통해 예외에 대한 적절한 View를 선택한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스프링-mvc-빈-설정">스프링 MVC 빈 설정</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="enablewebmvc">@EnableWebMVC</h1>
<p>스프링에서 사용하는 스프링부트의 @SpringBootApplication 같은 기능
<br />
<br />
<br />
<br /></p>

<h1 id="도메인-클래스-컨버터">도메인 클래스 컨버터</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="핸들러-인터셉터">핸들러 인터셉터</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="리소스-핸들러">리소스 핸들러</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="http-메시지-컨버터">HTTP 메시지 컨버터</h1>
<ul>
  <li>HTTP 메시지 컨버터 JSON</li>
  <li>HTTP 메시지 컨버터 XML</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="webmvc-configurer">WebMVC Configurer</h1>
<p>스프링 MVC를 사용하는 웹 어플리케이션에서 웹 기능을 구성하는 데 사용되는 인터페이스</p>
<ul>
  <li><strong>Interceptor 등록</strong>
    <ul>
      <li>WebMvcConfigurer를 사용하여 스프링 MVC Interceptor를 등록할 수 있다.</li>
      <li>이를 통해 요청 전/후에 추가적인 작업을 수행 가능</li>
    </ul>
  </li>
  <li><strong>View Controller 등록</strong>
    <ul>
      <li>View Controller는 특정 URL을 특정 View에 매핑할 수 있다.</li>
      <li>WebMvcConfigurer를 사용하여 View Controller를 등록 가능</li>
    </ul>
  </li>
  <li><strong>Resource Handler 등록</strong>
    <ul>
      <li>Resource Handler는 정적 자원 (이미지, CSS, 자바스크립트 등)에 대한 요청을 처리.</li>
      <li>WebMvcConfigurer를 사용하여 Resource Handler를 등록 가능</li>
    </ul>
  </li>
  <li><strong>Formatter 등록</strong>
    <ul>
      <li>Formatter는 특정 타입의 값을 원하는 형식으로 변환하는 데 사용</li>
      <li>WebMvcConfigurer를 사용하여 Formatter를 등록 가능</li>
    </ul>
  </li>
  <li><strong>Message Converter 등록</strong>
    <ul>
      <li>Message Converter는 요청 및 응답 본문에 대한 자동 변환을 처리</li>
      <li>WebMvcConfigurer를 사용하여 Message Converter를 등록 가능</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="스프링-mvc-활용">스프링 MVC 활용</h1>
<ul>
  <li>HTTP 메서드</li>
  <li>URI 패턴</li>
  <li>미디어 타입</li>
  <li>헤더 / 매개변수</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="핸들러메서드">핸들러메서드</h1>
<ul>
  <li>아규먼트 / 리턴타입</li>
  <li>URI 패턴</li>
  <li>요청 매개변수</li>
  <li>폼 서브밋</li>
  <li>@ModelAttribute</li>
  <li>@Validated</li>
  <li>@SessionAttributes</li>
  <li>@ResponseBody &amp; @HttpEntity</li>
  <li>@ResponseBody &amp; ResponseEntity</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="modelattribute">@ModelAttribute</h1>

<p><br />
<br />
<br />
<br /></p>

<h1 id="initbinder">@initBinder</h1>
<p>컨트롤러에서 사용하는 매개변수를 변환할 때 사용되는 메소드를 정의하는 데 사용되는 어노테이션</p>
<ul>
  <li>메서드 / 클래스 레벨에서 사용 가능</li>
  <li>컨트롤러 내에 선언된 메서드를 통해 요청 매개변수를 객체로 변환하는 로직을 구현할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyController</span> <span class="o">{</span>

    <span class="nd">@InitBinder</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initBinder</span><span class="o">(</span><span class="nc">WebDataBinder</span> <span class="n">binder</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SimpleDateFormat</span> <span class="n">dateFormat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd"</span><span class="o">);</span>
        <span class="n">dateFormat</span><span class="o">.</span><span class="na">setLenient</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="n">binder</span><span class="o">.</span><span class="na">registerCustomEditor</span><span class="o">(</span><span class="nc">Date</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="nc">CustomDateEditor</span><span class="o">(</span><span class="n">dateFormat</span><span class="o">,</span> <span class="kc">false</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/example"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">example</span><span class="o">(</span><span class="nc">Date</span> <span class="n">date</span><span class="o">)</span> <span class="o">{</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h1 id="exceptionhandler">@ExceptionHandler</h1>
<p>예외 처리를 위해 사용되는 어노테이션
<br />
컨트롤러에서 예외가 발생했을 때, 예외 처리를 담당하는 메소드를 정의할 수 있다.
<br />
@ControllerAdvice 과 함께 사용되며, @ControllerAdvice rk 적용된 클래스 내에 @ExceptionHandler 를 사용하여
<br />
예외 처리 메소드를 정의한다. 예외 처리 메소드는 예외 객체를 매개변수로 받아 처리한다.</p>
<ul>
  <li>ExceptionHandler 을 사용하면, 예외 처리를 전체적으로 일괄 처리할 수 있다.</li>
  <li>또한, 예외 처리 로직을 별도의 클래스로 분리하여 관리할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ControllerAdvice</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GlobalExceptionHandler</span> <span class="o">{</span>

    <span class="nd">@ExceptionHandler</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ModelAndView</span> <span class="nf">handleIllegalArgumentException</span><span class="o">(</span><span class="nc">IllegalArgumentException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ModelAndView</span> <span class="n">mav</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ModelAndView</span><span class="o">();</span>
        <span class="n">mav</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="s">"errorMessage"</span><span class="o">,</span> <span class="s">"잘못된 입력입니다."</span><span class="o">);</span>
        <span class="n">mav</span><span class="o">.</span><span class="na">setViewName</span><span class="o">(</span><span class="s">"error"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">mav</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h1 id="controlleradvice">@ControllerAdvice</h1>
<p>스프링 MVC에서 예외 처리와 같은 공통 로직을 처리하는 데 사용되는 어노테이션</p>
<ul>
  <li>@ControllerAdvice 을 사용하면, 여러 컨트롤러에서 발생하는 예외를 중앙에서 처리할 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Spring Basic</title><link href="http://localhost:4000/til/Spring_Basic/" rel="alternate" type="text/html" title="Spring Basic" /><published>2023-03-04T00:00:00+09:00</published><updated>2023-03-04T00:00:00+09:00</updated><id>http://localhost:4000/til/Spring_Basic</id><content type="html" xml:base="http://localhost:4000/til/Spring_Basic/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="ioc-컨테이너">IoC 컨테이너</h1>
<p><strong>IoC</strong> 는 객체간의 의존성 관리를 프레임워크가 대신 수행하는 디자인 패턴이다.
<br />
<strong>IoC 컨테이너</strong> 는 스프링 프레임워크의 핵심 기능 중 하나이다.
<br />
객체를 직접 생성하는 대신 객체를 생성하고 관리하는 책임을 프레임워크에게 위임하는걸 의미한다.</p>
<ul>
  <li>객체의 라이프사이클 및 관리의 간소화
    <ul>
      <li>개발자가 아닌 프레임워크가 수행</li>
    </ul>
  </li>
  <li>객체간의 결합도 감소
    <ul>
      <li>IoC 가 의존성을 자동으로 주입</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="autowire">@Autowire</h1>
<p>의존성 주입을 자동으로 처리하기 위한 어노테이션
<br />
적용된 필드, 생성자, 메서드 파라미터에 해당하는 객체를 스프링이 자동으로 생성하고
<br />
필요한 의존성을 주입하여 객체간의 결합도를 줄인다.
<br />
기본적으로 타입을 이용한 의존성 주입을 수행한다.</p>

<p><br /></p>

<p><strong>동작방식</strong></p>
<ul>
  <li>스프링이 <strong>@Autowired</strong> 가 선언된 곳의 클래스의 빈 객체를 생성</li>
  <li>스프링은 생성된 빈 객체를 검색해 @Autowired 어노테이션이 선언된 필드, 생성자 등을 탐색</li>
  <li><strong>@Autowired</strong> 어노테이션이 적용된 위치에서 필요한 의존성을 주입
    <ul>
      <li>의존성은 자동으로 생성된 빈 객체 중 해당 타입과 일치하는 객체를 찾아서 주입</li>
    </ul>
  </li>
  <li>의존성 주입이 완료된 빈 객체가 스프링 컨테이너에 등록되어 관리됨</li>
  <li>컴파일 타임에 의존성이 결정된다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="component">@Component</h1>
<p>해당 클래스가 스프링 빈으로 등록되어야 함을 나타낸다.
<br />
스프링 컨테이너는 <strong>@Component</strong> 가 선언된 클래스를 스캔해 해당 클래스를 스프링
<br />
빈으로 등록한다. 이를 통해 객체의 라이프사이클에 대한 코드를 작성하지 않아도 된다.</p>

<p><br /></p>

<h1 id="componentscan">@ComponentScan</h1>
<p>스프링 컨테이너는 <strong>@ComponentScan</strong> 가 선언된 패키지를 스캔하여 해당 패키지에
속한 클래스 중 <strong>@Component</strong> 가 선언된 클래스를 찾아 빈으로 등록한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="빈-스코프">빈 스코프</h1>
<p>빈의 라이프사이클 범위이다.</p>

<ul>
  <li><strong>Singleton</strong>
    <ul>
      <li>스프링에서 기본적으로 제공하는 스코프로, 애플리케이션 전체에서 하나의 인스턴스만 생성, 스프링 컨테이너가 생성하고 초기화한 후, 컨테이너가 종료될 때까지 유지된다.
        <ul>
          <li>하나의 인스턴스만 생성되기 때문에 메모리, 성능에 효율적이다.</li>
          <li>빈 상태를 공유할 수 있으므로 멀티스레드 환경에서 주의가 필요하다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Prototype</strong>
    <ul>
      <li>각각의 요청마다 새로운 인스턴스를 생성, 해당 요청이 끝날 때까지 유지되며, 이후에는 소멸
        <ul>
          <li>각각의 요청마다 새로운 인스턴스를 생성하기 때문에 상태를 공유하지 않는다.</li>
          <li>메모리 사용량, 객체 생성 비용이 높아질 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Request</strong>
    <ul>
      <li>웹 애플리케이션에서 HTTP 요청마다 새로운 인스턴스를 생성, 해당 요청이 처리될 때까지 유지되며, 이후에는 소멸
        <ul>
          <li>각각의 요청마다 새로운 인스턴스를 생성하기 때문에 상태를 공유하지 않는다.</li>
          <li>메모리 사용량, 객체 생성 비용이 높아질 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Session</strong>
    <ul>
      <li>웹 애플리케이션에서 HTTP 세션마다 새로운 인스턴스를 생성, 해당 세션이 유지되는 동안에만 유지되며, 이후에는 소멸
        <ul>
          <li>각각의 HTTP 세션 마다 새로운 인스턴스를 생성하기 때문에 상태를 공유하지 않는다.</li>
          <li>메모리 사용량, 객체 생성 비용이 높아질 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Global session</strong>
    <ul>
      <li>전역 세션마다 새로운 인스턴스를 생성, 해당 전역 세션이 유지되는 동안에만 유지되며, 이후에는 소멸된다.
        <ul>
          <li>ServletContext 마다 새로운 인스턴스를 생성하기 때문에 상태를 공유하지 않는다.</li>
          <li>메모리 사용량, 객체 생성 비용이 높아질 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>Application</strong>
    <ul>
      <li>웹 애플리케이션에서 ServletContext마다 새로운 인스턴스를 생성, 웹 애플리케이션이 유지되는 동안에만 유지되며, 이후에는 소멸
        <ul>
          <li>각각의 요청마다 새로운 인스턴스를 생성하기 때문에 상태를 공유하지 않는다.</li>
          <li>메모리 사용량, 객체 생성 비용이 높아질 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>WebSocket</strong>
    <ul>
      <li>WebSocket 세션이 시작될 때마다 새로운 인스턴스를 생성, WebSocket 세션이 유지되는 동안에만 유지되며, 이후에는 소멸</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="environment">Environment</h1>
<p>스프링 어플리케이션에서 사용되는 환경변수들을 캡슐화한 인터페이스
<br />
어플리케이션의 구성정보들을 다양한 환경에 맞춰 쉽게 관리할 수 있다.</p>
<ul>
  <li><strong>Profile</strong>
    <ul>
      <li>@Profile 어노테이션으로 설정하거나 .properties 파일을 사용해</li>
      <li>프로파일이 지정된 빈은 해당 프로파일이 활성화 된 경우에만 사용 가능</li>
    </ul>
  </li>
  <li><strong>Property</strong>
    <ul>
      <li>설정 정보를 담은 키-값</li>
      <li>.properties / .yml 파일에 설정</li>
      <li>@Value 어노테이션을 사용해 프로퍼티를 주입받음</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="messagesource">MessageSource</h1>
<p>스프링 어플리케이션에서 다국어 지원을 위한 인터페이스</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="applicationeventpublisher">ApplicationEventPublisher</h1>
<p>이벤트를 발생시키는 인터페이스
<br />
ApplicationEventPublisher 를 주입받아 publishEvent() 메서드로 이벤트를 발생시키고
<br />
@EventListener 어노테이션으로 이벤트 발생시 해당 메서드가 자동으로 호출되게 한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="resourceloader">ResourceLoader</h1>
<p>어플리케이션에서 리소스를 로드하는 인터페이스</p>
<ul>
  <li><strong>Resource</strong>
    <ul>
      <li>파일시스템, 클래스패스, URL 등 의 리소스를 추상화한 인터페이스</li>
      <li>리소스를 추상화 하여 일관된 방식으로 처리할 수 있다.</li>
    </ul>
  </li>
  <li><strong>Validation</strong>
    <ul>
      <li>유효성 검사를 위한 인터페이스</li>
      <li>실패 시 에러메시지 전달</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="데이터바인딩-추상화---propertyeditor--converter-와-fomatter">데이터바인딩 추상화 - PropertyEditor / Converter 와 Fomatter</h1>
<p>웹 요청 파라미터를 자바 객체에 바인딩 하는 인터페이스</p>
<ul>
  <li><strong>PropertyEditor</strong>
    <ul>
      <li>문자열과 객체간의 변환을 수행하는 인터페이스</li>
      <li>문자열 값을 읽어와 자바 객체로 변환하거나, 자바객체를 문자열로 변환하여 저장</li>
      <li><strong>Converter</strong>
        <ul>
          <li>문자열과 객체간의 일반적인 변환을 처리</li>
        </ul>
      </li>
      <li><strong>Fomatter</strong>
        <ul>
          <li>특정 타입의 변환을 처리</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="spel-스프링-expression-language">spEL (스프링 Expression Language)</h1>
<p>문자열 템플릿을 사용해 런타임에 객체 그래프를 조작하는 기능을 제공하는 표현 언어
<br />
스프링 빈 구성, XML 구성 파일, 애노테이션 구성 등에서 사용할 수 있는 다양한 형태의 표현식을
<br />
사용할 수 있고 이를 통해 스프링 애플리케이션을 보다 유연하고 동적으로 만들 수 있다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"myBean"</span> <span class="na">class=</span><span class="s">"com.example.MyBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"message"</span> <span class="na">value=</span><span class="s">"#{'Hello, ' + systemProperties['user.name']}"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyBean</span> <span class="o">{</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"#{systemProperties['user.name']}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h1 id="null---safety">Null - Safety</h1>
<p>스프링은 <strong>Null - Safety</strong> 를 지원하는 프레임워크 이다.</p>
<ul>
  <li><strong>Optional</strong>
    <ul>
      <li>null을 반환할 가능성이 있는 메서드를 호출할 때 null 체크 없이 처리 가능</li>
    </ul>
  </li>
  <li><strong>@NonNull</strong>
    <ul>
      <li>어노테이션 사용으로 매개변수, 필드, 반환값 등에 null 이 들어오지 않게 강제</li>
    </ul>
  </li>
  <li><strong>Assert</strong>
    <ul>
      <li>런타임중에 조건을 검사해 예외를 발생시킴</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Performance Test</title><link href="http://localhost:4000/til/PerformanceTest/" rel="alternate" type="text/html" title="Performance Test" /><published>2023-03-02T00:00:00+09:00</published><updated>2023-03-02T00:00:00+09:00</updated><id>http://localhost:4000/til/PerformanceTest</id><content type="html" xml:base="http://localhost:4000/til/PerformanceTest/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="jmh">JMH</h1>
<p>이런저런 요구사항에서 내가 작성한 코드가 효율적일까? 라는 의문이 생기기 마련이다.
<br />
작성한 로직을 요구사항에 맞춰 <code class="language-plaintext highlighter-rouge">Big-O</code> 표기법으로 계산해 시간복잡도를 계산할 수도 있고,
<br />
운영환경에서 <code class="language-plaintext highlighter-rouge">Stress Test</code> 를 진행하여 성능을 측정할 수도 있지만 작은 규모의 코드조각에
<br />
대한 측정을 더 빠르고 간단하게 사용할 수 있는 방법은 <code class="language-plaintext highlighter-rouge">JMH</code> 를 사용하는 것이다.
<br />
<br />
<code class="language-plaintext highlighter-rouge">JMH</code> 는 <code class="language-plaintext highlighter-rouge">JVM</code> 상에서 실행되는 코드의 성능을 측정하기 위한 벤치마크 도구로써, 성능측정은 일반적으로
<br />
코드실행시간, 메모리사용량, GC활동 등을 측정하여 수행하고 실행 결과에 대한 통계 및 분석을 제공한다.</p>

<p><br />
<br /></p>

<p><strong>의존성 추가</strong></p>

<hr />
<p>사용하기 위한 간단한 방법은 Gradle, Maven 등의 빌드시스템에 의존성을 추가하면 된다.</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span> <span class="s1">'org.openjdk.jmh:jmh-core:{version}'</span>
    <span class="n">compile</span> <span class="s1">'org.openjdk.jmh:jmh-generator-annprocess:{version}'</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependencies&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>jmh-core<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>${jmh.version}<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>jmh-generator-annprocess<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>${jmh.version}<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div></div>

<hr />
<p><br /></p>

<p><strong>@Benchmark</strong>
<br /></p>

<ul>
  <li><strong>Mode.Throughput</strong> : 시간당 처리량 측정</li>
  <li><strong>Mode.AverageTime</strong> : 평균 실행 시간 측정</li>
  <li><strong>Mode.SampleTime</strong> : 실행 시간 샘플링 측정</li>
  <li><strong>Mode.SingleShotTime</strong> : 단일 실행 시간 측정</li>
  <li><strong>Mode.All</strong> : 모든 시간 측정</li>
</ul>

<hr />
<p><br /></p>

<p><strong>@OutputTimeUnit</strong>
<br /></p>

<ul>
  <li><strong>TimeUnit.NANOSECONDS</strong> : 나노</li>
  <li><strong>TimeUnit.MICROSECONDS</strong> : 마이크로</li>
  <li><strong>TimeUnit.MILLISECONDS</strong> : 밀리</li>
  <li><strong>TimeUnit.SECONDS</strong> : 초</li>
  <li><strong>TimeUnit.MINUTES</strong> : 분</li>
  <li><strong>TimeUnit.HOURS</strong> : 시간</li>
  <li><strong>TimeUnit.DAYS</strong> : 일</li>
</ul>

<hr />
<p><br /></p>

<p><strong>@State</strong>
<br /></p>

<ul>
  <li><strong>Scope.Benchmark</strong> : 벤치마크 전체에서 공유</li>
  <li><strong>Scope.Thread</strong> : 각 스레드마다 별도로 생성. 멀티스레드 환경에서 안전</li>
  <li><strong>Scope.Group</strong> : 벤치마크 실행 그룹에서 공유</li>
</ul>

<hr />
<p><br /></p>

<p><strong>@Setup</strong>
<br /></p>

<ul>
  <li><strong>Level.Trial</strong> : 벤치마크 전체에서 한 번만 실행</li>
  <li><strong>Level.Iteration</strong> : 벤치마크 반복마다 실행</li>
  <li><strong>Level.Invocation</strong> : 각 메서드 호출마다 실행</li>
</ul>

<hr />
<p><br /></p>

<p><strong>@TearDown</strong>
<br /></p>

<ul>
  <li><strong>Scope.Benchmark</strong> : 벤치마크 전체에서 공유</li>
  <li><strong>Scope.Thread</strong> : 각 스레드마다 별도로 생성. 멀티스레드 환경에서 안전</li>
  <li><strong>Scope.Group</strong> : 벤치마크 실행 그룹에서 공유</li>
</ul>

<hr />
<p><br /></p>

<p><strong>예제</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jmh-core<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.19<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.openjdk.jmh<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jmh-generator-annprocess<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.19<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@State</span><span class="o">(</span><span class="nc">Scope</span><span class="o">.</span><span class="na">Benchmark</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StreamBenchmark</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">ForkJoinPool</span> <span class="n">forkJoinPool</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ForkJoinPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

    <span class="kd">final</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">PersonDTO</span><span class="o">&gt;</span> <span class="n">personSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kd">final</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">PersonSession</span><span class="o">&gt;</span> <span class="n">streamSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
    <span class="kd">final</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">PersonSession</span><span class="o">&gt;</span> <span class="n">parallelStreamSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Options</span> <span class="n">opt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OptionsBuilder</span><span class="o">()</span>
            <span class="o">.</span><span class="na">include</span><span class="o">(</span><span class="nc">StreamBenchmark</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">())</span>
            <span class="o">.</span><span class="na">warmupIterations</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>            <span class="c1">// JVM warm-up 반복 횟수</span>
            <span class="o">.</span><span class="na">measurementIterations</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>      <span class="c1">// warm-up 이후 실제 실행 횟수</span>
            <span class="o">.</span><span class="na">fork</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>                        <span class="c1">// 하나의 JVM 에서 실행 횟수</span>
            <span class="o">.</span><span class="na">thread</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>                      <span class="c1">// 사용할 스레드 수</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>
        <span class="k">new</span> <span class="nf">Runner</span><span class="o">(</span><span class="n">opt</span><span class="o">).</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="nc">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
    <span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">streamTest</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">personSet</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">PersonSession:</span><span class="o">:</span><span class="n">from</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="nl">HashSet:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="nc">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
    <span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">parallelStreamTest1</span><span class="o">(){</span>
        <span class="n">forkJoinPool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">personSet</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">PersonSession:</span><span class="o">:</span><span class="n">from</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="nl">HashSet:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
        <span class="o">});</span>
    <span class="o">}</span>

    <span class="nd">@Benchmark</span>
    <span class="nd">@BenchmarkMode</span><span class="o">(</span><span class="nc">Mode</span><span class="o">.</span><span class="na">AverageTime</span><span class="o">)</span>
    <span class="nd">@OutputTimeUnit</span><span class="o">(</span><span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">parallelStreamTest2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">personSet</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">PersonSession:</span><span class="o">:</span><span class="n">from</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="nl">HashSet:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="c1">// 사전 셋업</span>
    <span class="nd">@Setup</span><span class="o">(</span><span class="nc">Level</span><span class="o">.</span><span class="na">Trial</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2001</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">PersonDTO</span> <span class="n">personDTO</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PersonDTO</span><span class="o">();</span>
            <span class="n">personDTO</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
            <span class="n">personDTO</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">personSet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">personDTO</span><span class="o">);</span>
        <span class="o">});</span>
    <span class="o">}</span>

    <span class="c1">// pool 종료</span>
    <span class="nd">@TearDown</span><span class="o">(</span><span class="nc">Level</span><span class="o">.</span><span class="na">Trial</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">tearDown</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">forkJoinPool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Getter</span>
    <span class="nd">@Setter</span>
    <span class="nd">@EqualsAndHashCode</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">PersonDTO</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>
<p><br />
<strong>결과</strong>
<br /></p>

<p><img src="/images/2021-05-10-first-posting/JMH.png" alt="이미지" /></p>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="JMH" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Test</title><link href="http://localhost:4000/til/Test1/" rel="alternate" type="text/html" title="Test" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/til/Test1</id><content type="html" xml:base="http://localhost:4000/til/Test1/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="테스트-피라미드">테스트 피라미드</h1>
<p>마틴파울러의 테스트피라미드는 어플리케이션을 테스트 하는 방법 중 하나로 다양한 종류의 
<br />
테스트를 적절하게 조합하여 효율적인 테스트를 수행할 수 있도록 도와준다.</p>

<p><br /></p>

<h2 id="단위-테스트">단위 테스트</h2>
<ul>
  <li>가장 작은 단위인 모듈을 테스트 하는 단계</li>
  <li>빠르고 자주 실행할 수 있으며, 주로 개발자들이 로직, 함수등을 검증한다.</li>
  <li>어플리케이션의 다른부분과 <strong>독립적으로</strong> 수행할 수 있어야 한다.</li>
  <li>마틴 파울러는 단위 테스트가 테스트 피라미드 중 가장많은 부분을 차지해야 한다고 말한다.</li>
  <li>대표적인 도구로 <code class="language-plaintext highlighter-rouge">JUnit, Mockito</code> 등이 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>코드 품질 개선</strong>
    <ul>
      <li>작은 단위의 코드블록에 대한 테스트로 버그를 미리 발견할 수 있다.</li>
      <li>단위테스트 작성 시 코드를 더 객체지향적으로 작성할 수 있다.</li>
    </ul>
  </li>
  <li><strong>리팩토링의 안전망</strong>
    <ul>
      <li>리팩토링을 안전하게 수행할 때 중요한 역할을 한다.</li>
    </ul>
  </li>
  <li><strong>개발시간 단축</strong>
    <ul>
      <li>빠른 실행 시간으로 버그를 빠르게 발견하고 수정할 수 있다.</li>
    </ul>
  </li>
  <li><strong>팀 혐업 개선</strong>
    <ul>
      <li>팀원들간의 코드통합을 용이하게 만든다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="통합-테스트">통합 테스트</h2>
<ul>
  <li>여러 모듈이 상호작용하는 시스템을 테스트 하는 단계</li>
  <li>단위 테스트보다 더 많은 리소스가 소요된다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>여러 모듈들 간의 상호작용 확인</strong>
    <ul>
      <li>단위테스트가 개별적인 코드블록을 검증한다면, 통합테스트는 이들의 결합을 테스트한다.</li>
    </ul>
  </li>
  <li><strong>문제발견 가능성 증가</strong>
    <ul>
      <li>단위테스트에서 발견하지 못한 결합되었을 때의 문제를 발견할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="인수-테스트">인수 테스트</h2>
<ul>
  <li>시스템 전체가 의도한 대로 동작하는지 테스트 하는 단계</li>
  <li>사용자 관점에서 기능 및 비기능적 요구사항(성능, 보안)을 검증한다.</li>
  <li>테스트 피라미드의 단계 중 가장 많은 리소스가 들어간다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>사용자 관점에서의 검증</strong>
    <ul>
      <li>사용자가 경험하는것과 동일한 환경에서 검증할 수 있다.</li>
    </ul>
  </li>
  <li><strong>요구사항 충족여부 확인</strong>
    <ul>
      <li>개발된 기능이 요구사항을 충족하는지 확인한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="테스트피라미드" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Stream</title><link href="http://localhost:4000/til/Stream1/" rel="alternate" type="text/html" title="Stream" /><published>2023-02-23T00:00:00+09:00</published><updated>2023-02-23T00:00:00+09:00</updated><id>http://localhost:4000/til/Stream1</id><content type="html" xml:base="http://localhost:4000/til/Stream1/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="stream">Stream</h1>
<p><strong>Collection, Array</strong> 등의 데이터 소스를 함수형 프로그래밍의 <strong>Stream</strong> 형태로 다룰 수 있도록 지원하는 <strong>API</strong>
<br />
Stream 은 대표적으로 Collection 데이터를 처리하거나 I/O 처리에 스트리밍 방식을 사용한다.
<br />
데이터의 필터링, 매핑, 정렬, 집계 등과 <strong>대량의 데이터를 처리할 때 효과적으로 사용할 수 있다.</strong></p>

<ul>
  <li><strong>Stream의 스트리밍 방식</strong>
    <ul>
      <li>데이터를 작은 블록 단위로 분할하여 처리하는 방식 - 대용량 데이터 처리에 효율적
        <ul>
          <li>멀티코어 CPU 에서 데이터를 빠른속도로 병렬처리 하는데 용이</li>
          <li>네트워크 통신에서도 분할하여 전송하고 동시에 처리하기 때문에 용이</li>
          <li>데이터를 끊어서 전송할 수 있어서, 데이터 전송이 중단되거나 끊어졌을 경우 용이</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>지연처리</strong>
    <ul>
      <li>데이터소스에서 <strong>Stream</strong> 을 생성하면, 중간 연산들은 데이터 처리가 시작되기 전까지 수행되지 않는다.</li>
      <li>불필요한 데이터 처리를 줄이고, 성능향상에 도움이 될 수 있다.</li>
    </ul>
  </li>
  <li><strong>병렬처리</strong>
    <ul>
      <li>데이터 처리과정에서 데이터를 분할하여 병렬로 처리할 수 있어 대용량 데이터 처리에 적합</li>
      <li>데이터가 분할되어 처리되기 때문에, 순서가 보장되지 않는다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>순서</strong></p>

<hr />
<ol>
  <li><strong>Stream 생성</strong>
    <ul>
      <li>Collection, Array 등의 다양한 데이터 소스를 이용해 <strong>Stream</strong> 을 생성한다.
        <ul>
          <li>Collection.stream(), Arrays.stream() 등</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>중간 연산</strong>
    <ul>
      <li><strong>Stream</strong> 의 요소를 변환하거나 필터링하는 등의 작업을 수행
        <ul>
          <li>filter, map, flatMap, distinct, sorted, limit, skip 등</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>최종 연산</strong>
    <ul>
      <li><strong>Stream</strong> 의 요소를 처리하고 결과를 반환합니다.
        <ul>
          <li>forEach, toArray, reduce, collect, min, max, count 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>원본데이터가 변경되지 않는 <strong>불변성</strong></li>
  <li>내부적으로 <strong>병렬 처리</strong> 가 가능하도록 구현되어 있어, <strong>멀티코어 CPU에서 빠른 속도로 데이터 처리 가능</strong></li>
  <li>중간연산과 최종연산의 분리</li>
  <li>데이터를 한 번에 다 읽어들이는 것이 아니라, 필요한 데이터만 읽어들이므로 <strong>메모리 사용량 최적화</strong></li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li><strong>상태</strong> 가 없는 연산만을 지원</li>
  <li>데이터를 스트리밍 방식으로 처리하기 때문에, <strong>작은 데이터셋에선 for / while 문보다 비효율적이다.</strong></li>
  <li>제네릭 타입을 사용하여 데이터를 처리하기 때문에, 타입추론이 어려울 수 있다.</li>
  <li>내부적으로 복잡한 작업을 처리하기 위해 많은 객체를 생성하므로, <strong>런타임 오버헤드</strong> 가 발생할 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="parallel-stream">Parallel Stream</h1>
<p>데이터요소를 처리할때 필요한 작업을 병렬적으로 처리할 수 있는 기능
<br />
Stream 자체가 thread-safe 하게 구현되었기 때문에 가능하다.
<br />
Stream 인터페이스의 병렬처리를 위해서는 <strong>parallel()</strong> 메서드를 호출하면 된다.
<br />
<strong>parallel()</strong> 메서드는 요소를 병렬처리하고, 병렬로 실행할 스레드풀을 생성한다.
<br />
<strong>즉, parallel() 메서드를 호출하면 Stream 연산이 멀티스레드에서 수행되게 된다.</strong></p>

<p><br /></p>

<p><strong>고려사항</strong></p>

<hr />
<p><strong>비용</strong></p>
<ul>
  <li>대용량 데이터를 처리할 때만 사용하는 것이 좋다.</li>
  <li>보통 연산의 복잡도가 높을수록 효율이 올라간다</li>
  <li>데이터셋이 작을경우 병렬화 비용이 더 커서 오히려 성능이 저하된다.</li>
  <li>CPU 코어 수를 고려해 사용 전후 처리시간을 비교해서 사용여부 결정필요</li>
</ul>

<p><br />
<strong>thread-safe</strong></p>
<ul>
  <li>병렬처리 시 스레드 풀내에서 별도의 스레드에서 처리될 수 있다.</li>
  <li>Stream의 각 요소는 불변성을 유지해야 한다.</li>
  <li>Stream의 상태를 공유하지 않아야 한다.</li>
</ul>

<p><br />
<strong>순서</strong></p>
<ul>
  <li>병렬처리로 작업의 순서가 보장되지 않기 때문에 순서에 의존하는 연산에서 문제가 발생한다.
    <ul>
      <li>ex) 순서에 의존하는 sorted 연산에서 문제가 발생할 수 있다.</li>
      <li>sequential() 메서드 등의 순차처리를 지정하거나 다른방법을 사용해야 함</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>ForkJoinPool</strong></p>
<ul>
  <li>parallelStream은 내부적으로 ForkJoinPool 을 사용해 데이터를 병렬처리 한다.
    <ul>
      <li>스레드 풀을 관리하고, 각 스레드에 작업을 분배하는 기능을 수행한다.</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>병목현상</strong></p>
<ul>
  <li>병목현상에 주의하자.</li>
</ul>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><strong>장점</strong></p>
<ul>
  <li>여러 코어를 사용해 빠른 처리속도</li>
  <li>병렬처리를 위해 스레드를 직접 구현할 필요없이 간단하게 구현가능</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>데이터셋이 작을경우 오히려 병렬화 비용이 더 높아서 오버헤드 발생</li>
  <li>작업의 순서가 보장되지 않음</li>
  <li>분산환경에선 작동하지 않음</li>
  <li>내부적으로 중간데이터를 저장하는데 사용하는 메모리 사용량 증가</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="Stream" /><category term="Parallel Stream" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Spring</title><link href="http://localhost:4000/til/Spring1/" rel="alternate" type="text/html" title="Spring" /><published>2023-02-21T00:00:00+09:00</published><updated>2023-02-21T00:00:00+09:00</updated><id>http://localhost:4000/til/Spring1</id><content type="html" xml:base="http://localhost:4000/til/Spring1/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="ioc-컨테이너">IoC 컨테이너</h1>
<p><strong>IoC(제어의 역전)</strong> - 객체간의 결합도를 줄이기 위한 디자인 패턴중의 하나이다.
<br />
<br />
IoC 컨테이너는 객체들의 생명주기와 객체간의 의존성을 관리한다.
<br />
IoC 컨테이너는 <strong>BeanFactory</strong> 인터페이스를 구현한 <strong>ApplicationContext</strong> 를 통해 사용된다.
<br />
<strong>ApplicationContext</strong> 는 <strong>빈</strong> 이라고 불리는 객체들의 라이프사이클, 빈 간의 의존성 등을 
<br />
관리하며 필요한 시점에 빈을 제공해준다.
<br />
<br />
<strong>한마디로 객체의 생성과 관리를 전적으로 스프링 프레임워크에 맡기는 것이다.</strong></p>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>객체들 간의 결합도를 낮출수 있다.
    <ul>
      <li>유지보수성, 확장성 향상</li>
    </ul>
  </li>
  <li>겍체간의 의존성을 쉽게 변경할 수 있어 테스트에 용이하다.</li>
  <li>객체들의 라이프사이클을 맡기고 비즈니스 로직에 집중할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>스프링 프레임워크에 대한 러닝커브</li>
  <li>직접 객체의 라이프사이클을 관리할 수 없다.</li>
</ul>

<p><br /></p>

<p><strong>@Autowire</strong></p>

<p><br /></p>

<p><strong>@Component, @ComponentScan</strong></p>

<p><br /></p>

<p><strong>@Environment</strong></p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="bean">Bean</h1>
<p>IoC 컨테이너에 의해 생성되고 관리되는 객체를 의미한다. 일반적으로 스프링의 모든 객체를 의미한다.
<br />
<strong>XML, 어노테이션, Configuration</strong> 파일등을 통해 정의되고 
<br />
<strong>ApplicationContext</strong> 에 의해 생성되고 빈 간의 의존성을 처리한다.
<br />
기본적으로 싱글톤 스코프를 가지고 다음과 같은 다양한 스코프를 지원한다.</p>
<ul>
  <li><strong>Singleton</strong> : 하나의 Bean 인스턴스만 생성되며, 모든 요청에 대해 같은 인스턴스가 반환</li>
  <li><strong>Prototype</strong> : 요청마다 새로운 Bean 인스턴스가 생성</li>
  <li><strong>Request</strong> : 각 HTTP 요청마다 새로운 Bean 인스턴스가 생성</li>
  <li><strong>Session</strong> : 각 세션마다 새로운 Bean 인스턴스가 생성</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="di">DI</h1>
<p>IoC 컨테이너가 제공하는 DI 기능으로 객체간의 의존성을 설정하고 관리할 수 있다.
<br />
예를들어, A객체가 B객체를 사용할 경우, A가 B객체를 생성하고 관리하는게 아니라
<br />
IoC 컨테이너가 B객체를 생성하고, A객체가 B객체를 사용할 수 있도록 주입해준다.
<br />
즉, 개발자 직접 처리하는게 아닌 IoC 컨테이너가 자동으로 처리한다.</p>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>어플리케이션에서 발생하는 객체간의 결합도를 줄일 수 있다.
    <ul>
      <li>이를 통해 유지보수, 확장성을 향상시킬 수 있다.</li>
    </ul>
  </li>
  <li>의존성을 주입할 때 인터페이스를 사용해서 <strong>의존성 역전 원칙</strong> 을 지킬 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>스프링 프레임워크에 대한 러닝커브</li>
  <li>잘못 구현할 경우 객체간의 의존성이 너무 복잡해 질 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>@Bean Scope</strong></p>

<p><br />
<br />
<br />
<br /></p>

<h1 id="aop">AOP</h1>
<p>다양한 관점으로 코드를 모듈화 하고 관심사를 분리하는 것이다.
<br />
예를들어, 비즈니스 로직에서 반복적으로 사용되는 공통 기능 (로깅, 트랜잭션, 보안 등) 을
<br />
별도의 모듈로 분리하여 관리하고 적용할 수 있다.
<br />
<strong>즉, 로직과 관련없는 부가적인 관심을 코드에서 분리하여 모듈화 하는 기법이다.</strong>
<br />
<br />
다음과 같은 주요 구성요소로 구성된다.</p>

<ul>
  <li><strong>Aspect</strong>
    <ul>
      <li>특정 관심사를 처리하는 모듈 (모듈화된 로직)</li>
      <li>보통 공통으로 적용되는 부가 기능 (로깅, 트랜잭션 처리 등)을 담당한다.</li>
    </ul>
  </li>
  <li><strong>Join point</strong>
    <ul>
      <li>언제나 관심사가 적용될 수 있는 코드 지점 (메서드 호출 등)</li>
    </ul>
  </li>
  <li><strong>Advice</strong>
    <ul>
      <li><strong>Aspect</strong> 가 <strong>Join point</strong> 에 적용하는 실제 로직(코드)</li>
      <li>Before, After, Around 등의 <strong>Advice유형</strong> 이 있다.</li>
    </ul>
  </li>
  <li><strong>Pointcut</strong>
    <ul>
      <li><strong>Join point</strong> 중에서 <strong>Aspect</strong> 가 적용되는 대상(메서드, 클래스 등)을 지정하는 패턴</li>
    </ul>
  </li>
  <li><strong>Weaving</strong>
    <ul>
      <li><strong>Aspect</strong> 를 대상 코드에 적용하는 과정</li>
      <li>스프링에서는 컴파일 타임, 로드 타임, 런타임에 모두 <strong>Weaving</strong> 이 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>비즈니스 로직과 부가기능의 분리
    <ul>
      <li>가독성, 유지보수성 향상</li>
    </ul>
  </li>
  <li>중복되는 부가기능을 한곳에서 관리할 수 있어 중복을 제거할 수 있다.</li>
  <li>부가기능이 추가 / 변경 될때, 비즈니스 로직을 수정할 필요가 없다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>복잡성이 증가할 수 있다.</li>
  <li>러닝커브</li>
  <li>프록시 기반으로 동작하기 때문에 다양한 기능 (final/private 메서드 등) 이 제한될 수 있다.
    <ul>
      <li>AspectJ 등의 다른 AOP 프레임워크 사용으로 해결 가능</li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="psa">PSA</h1>
<p>여러개의 서비스 구현체를 추상화 하여 사용할 수 있도록 일관된 인터페이스를 제공하는 기법이다.
<br />
스프링에서는 <strong>JDBC, JMS, 캐시, 메일 등</strong> 의 서비스에 대해 <strong>PSA</strong> 를 적용하고 있다.
<br />
예를들어, <strong>JdbcTemplate</strong> 은 <strong>JDBC</strong> 서비스에 대한 <strong>PSA</strong> 를 제공하며 클라이언트 코드에서 
<br />
<strong>서비스 구현체를 직접 참조하지 않고, 일관된 방법으로 서비스를 사용할 수 있게 된다.</strong>
<br />
<strong>또한 서비스 구현체를 변경하더라도, 클라이언트 코드가 변경되지 않도록 해주는 역할을 한다.</strong></p>

<ul>
  <li><strong>인터페이스 추상화</strong>
    <ul>
      <li>서비스를 추상화 하기 위해 인터페이스를 사용</li>
      <li>인터페이스는 일반적으로 서비스의 기능을 제공하는 메서드로 구성</li>
      <li><strong>인터페이스 추상화</strong> 는 서비스 구현체를 추상화 하는데 사용</li>
      <li>클라이언트는 인터페이스를 사용하여 서비스를 호출한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>팩토리 추상화</strong>
    <ul>
      <li>서비스 구현체를 생성하고 제공하기 위한 일관된 방법을 제공하는 추상화</li>
      <li><strong>팩토리 추상화</strong> 는 서비스 구현체를 생성하고 관리하는 데 사용</li>
      <li>클라이언트는 팩토리를 사용하여 서비스 구현체를 얻을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>예외 추상화</strong>
    <ul>
      <li>서비스에서 발생하는 예외를 일관된 방식으로 처리하기 위한 추상화</li>
      <li><strong>예외 추상화</strong> 는 서비스에서 발생하는 예외를 처리하기 위한 일관된 방법을 제공하는 데 사용</li>
      <li>클라이언트는 예외 추상화를 사용하여 서비스에서 발생하는 예외를 처리할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>trade-off</strong></p>

<hr />
<p><br />
<strong>장점</strong></p>
<ul>
  <li>클라이언트는 서비스 구현체를 직접 참조하지 않고, 일관된 방식으로 서비스를 호출할 수 있다.</li>
  <li>클라이언트 코드에서 서비스 구현체를 직접적으로 참조하지 않기 때문에, 서비스 구현체가 변경되더라도 클라이언트 코드를 수정할 필요가 없다.</li>
  <li>다양한 기술과 프레임워크에서 동일한 인터페이스를 사용하여 서비스를 호출할 수 있도록 한다.</li>
  <li><strong>인터페이스 추상화</strong> 와 <strong>팩토리 추상화</strong> 를 통해 서비스를 모듈화할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>인터페이스 추상화와 팩토리 추상화 등을 정의해야 하기 때문에 코드의 양과 복잡성이 증가할 수 있다.</li>
  <li>특정한 프레임워크에서만 적용될 수 있기 때문에, 표준화가 되어 있지 않은 경우에는 다른 프레임워크나 라이브러리에서는 적용할 수 없다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="IoC컨테이너" /><category term="Bean" /><category term="DI" /><category term="AOP" /><category term="PSA" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Design Pattern</title><link href="http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41/" rel="alternate" type="text/html" title="Design Pattern" /><published>2023-02-16T00:00:00+09:00</published><updated>2023-02-16T00:00:00+09:00</updated><id>http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41</id><content type="html" xml:base="http://localhost:4000/til/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B41/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="디자인패턴">디자인패턴</h1>
<p>일종의 설계 템플릿으로, 구체적인 구현방법을 제시하는것이 아니라 어떤 문제에 대해
<br />
어떤 구조와 접근법이 적절한지에 대한 <strong>가이드라인</strong>이다.
<br />
소프트웨어가 점점 복잡해지면서 다양한 문제가 발생하게 되었고, 이런 문제를 해결하기 위해
<br />
많은 개발자들이 각자의 방식으로 접근하다보니 비슷한 문제를 다른방식으로 해결하는 경우가 많았다.
<br />
결국 유지보수 등의 어려움을 겪게되고, 이러한 문제를 해결하기 위해 많은 개발자들의 전문지식을 모아
<br />
이미 검증된 방식을 <strong>템플릿 형태</strong>로 모아 <strong>가이드라인</strong>을 제시하게 되었다. 
<br />
이로써, 소프트웨어의 유연성, 확장성, 생산성, 픔질 향상에 큰 도움이 된다.</p>

<p><br />
<br />
<br />
<br /></p>

<h2 id="어댑터-패턴">어댑터 패턴</h2>
<p><strong>Adapter Pattern</strong>
<br />
호환되지 않는 여러 객체를 하나의 <strong>인터페이스</strong> 로 묶어서 사용할 수 있는 디자인 패턴이다.
<br />
이를통해, 재사용성, 유지보수성 을 향상시킬 수 있다.</p>

<p><br /></p>

<p><strong><em>인터페이스가 호환되지 않는 클래스들을 함께 사용하기 위해 사용한다.</em></strong></p>
<ul>
  <li>기존 코드나 라이브러리를 재사용하면서 새로운 시스템을 구축할 때</li>
  <li>호환성없는 두 클래스를 연결해 사용해야 할때</li>
  <li>인터페이스나 메소드가 다른 두 클래스 사이에서 호환성 문제를 해결해야 할 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>기존코드의 수정없이 호환되지 않는 객체를 연결할 수 있다.</li>
  <li>객체간의 결합도를 줄일 수 있다.</li>
  <li>호환성이 없는 여러 객체를 하나의 어댑터로 묶어서 사용할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>객체가 추가될 때 마다 어댑터 클래스가 늘어난다.</li>
  <li>어댑터가 객체를 감싸는 구조를 가지기 때문에 어댑터로 연결된 객체는 성능상 손실이 있을 수 있다.</li>
  <li>코드가 복잡해진다.</li>
</ul>

<p><br /></p>

<h3 id="구현">구현</h3>

<hr />

<p><strong>일반적인 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Generic animal sound"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Wolf 클래스는 Animal 클래스와 호환되지 않는 인터페이스를 가지고 있다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wolf</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">howl</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Howl"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
WolfAdapter 클래스는 Animal 클래스를 상속받고, makeSound() 메서드를 오버라이드 해서 
Wolf 클래스의 howl() 메서드를 호출하도록 구현한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WolfAdapter</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Wolf</span> <span class="n">wolf</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">WolfAdapter</span><span class="o">(</span><span class="nc">Wolf</span> <span class="n">wolf</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wolf</span> <span class="o">=</span> <span class="n">wolf</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">wolf</span><span class="o">.</span><span class="na">howl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 어댑터패턴으로 호환되지 않는 인터페이스를 연결하면 기존 코드를 수정하지 않아도 다른 객체와 같이 동작할 수 있게 된다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdapterExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// "Generic animal sound" 출력</span>
        
        <span class="nc">Wolf</span> <span class="n">wolf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Wolf</span><span class="o">();</span>
        <span class="nc">WolfAdapter</span> <span class="n">adapter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WolfAdapter</span><span class="o">(</span><span class="n">wolf</span><span class="o">);</span>
        <span class="n">adapter</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span> <span class="c1">// "Howl" 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>JDBC API에 사용된 어댑터 패턴</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
Class.forName() 메서드로 Driver 클래스를 로드한다. 이 클래스는 MySQL 제조사가 제공하는 드라이버이다.
그런다음 DriverManager.getConnection() 메서드를 사용하여 데이터베이스와 연결한다. 
이 메서드는 실제로 Driver 인터페이스를 구현한 객체를 생성하여 Connection 인터페이스와 연결한다.
*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// JDBC 드라이버 로드</span>
    <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.cj.jdbc.Driver"</span><span class="o">);</span>
    
    <span class="c1">// 데이터베이스 연결</span>
    <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost/test"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">user</span> <span class="o">=</span> <span class="s">"user"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>
    <span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/*
JDBC 는 데이터베이스와 연결하기 위해 인터페이스를 제공한다. 데이테베이스 제조사마다 제공하는
드라이버의 인터페이스가 다르기 떄문에 DriverManager클래스에 어댑터 패턴을 사용한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DriverManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Connection</span> <span class="nf">getConnection</span><span class="o">(</span><span class="nc">String</span> <span class="n">url</span><span class="o">,</span> <span class="nc">String</span> <span class="n">user</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 데이터베이스 제조사가 제공하는 드라이버를 찾아서 Driver 인터페이스를 구현한 객체를 생성</span>
        <span class="nc">Driver</span> <span class="n">driver</span> <span class="o">=</span> <span class="n">findDriver</span><span class="o">(</span><span class="n">url</span><span class="o">);</span>
        <span class="c1">// Driver 인터페이스를 구현</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="프록시-패턴">프록시 패턴</h2>
<p><strong>Proxy Pattern</strong>
<br />
Proxy 를 사용하여 객체에 대한 접근을 제어하고 간접적으로 제어하는 디자인 패턴이다.
<br />
객체에 대한 직접적인 접근을 대신해 <strong>Proxy 객체</strong> 를 사용해 객체에 접근을 하고 <strong>Proxy 객체</strong> 는
<br />
실제 객체를 대신해 객체의 <strong>대리자 역할</strong> 을 수행하며 객체와 동일한 인터페이스를 제공한다
<br />
Proxy 객체는 실제 객체의 인터페이스를 구현하며, 실제 객체의 메서드를 호출하기전 추가작업을 할 수 있다.</p>

<p><br /></p>

<p><strong><em>객체에 대한 접근을 제어하고 보안, 성능 최적화 등의 추가 기능을 제공하기 위해 사용한다.</em></strong></p>
<ul>
  <li>원격 객체에 대한 접근을 제어하고 네트워크 부하를 줄이기 위해</li>
  <li>복잡한 객체에 대한 접근을 제어하고 메모리 사용량을 줄이기 위해</li>
  <li>객체에 대한 보안적인 제한 및 부가적인 기능을 제공하기 위해</li>
</ul>

<p><br /></p>

<h3 id="trade-off-1">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>객체 생성과 초기화를 지연시킬 수 있어, 성능을 개선할 수 있다.
    <ul>
      <li>원본객체의 생성 또는 초기화에 많은 비용이 들어갈 경우 유용하다.</li>
      <li>실제객체가 원격서버에 있는경우, 프록시객체로 서버접근에 대한 리소스를 줄일 수 있다.</li>
      <li>프록시객체는 원본객체의 인스턴스를 생성하지 않고, 요청이 들어올 경우 생성하고 요청을 처리한다.</li>
    </ul>
  </li>
  <li>실제객체에 대한 접근을 제어할 수 있어, 보안성을 높일 수 있다.
    <ul>
      <li>원본객체가 보안성이 중요할 경우 유용하다.</li>
    </ul>
  </li>
  <li>객체의 메서드의 실행 전후로 추가적인 작업을 수행할 수 있어 유연성이 증가한다.
    <ul>
      <li>이를 통해 로깅, 캐싱, 트랜잭션 등 다양한 처리가 가능하다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>프록시 객체는 실제객체에 접근하기 위해 추가적인 리소스가 들어가므로 성능이 저하될 수 있다.</li>
  <li>프록시 객체라는 추가적은 클래스가 필요하고, 이는 복잡성이 증가하고 유지보수를 어렵게 할 수 있다.</li>
  <li>중간에 다른 객체가 끼어있기 때문에 디버깅이 어려워질 수 있어 추가적인 로깅이나 디버깅 작업이 필요하다.</li>
  <li>프록시객체가 실제객체를 대신하기 때문에 실제객체가 생성되지 않아 에상하지 못한 문제가 발생할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="구현-1">구현</h3>

<hr />

<p><strong>정적 프록시 방식</strong>
<br />
프록시 객체를 컴파일 시점에 미리 생성하는 방식</p>
<ul>
  <li>컴파일 시점에 생성되므로 런타임에 추가적인 비용이 발생하지 않는다.</li>
  <li>인터페이스를 구현하는 클래스만 프록시 객체를 생성할 수 있다.</li>
  <li>프록시객체를 수정하려면 컴파일을 다시 해야한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Animal is eating"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
프록시 객체가 구현할 AnimalInterface 인터페이스를 구현한다.
AnimalProxy 클래스는 AnimalInterface 인터페이스를 구현한다.
생성자를 통해 실제 객체를 전달받고, eat() 메서드에서 실제 객체의 eat() 메서드를 호출하기 전에 
수행할 작업과 호출한 후에 수행할 작업을 정의한다.
마지막으로 클라이언트에서 프록시 객체를 생성하고 사용한다.
이를 통해 클라이언트는 실제 객체를 알 필요가 없고, 프록시 객체를 이용해 추가적인 작업을 수행할 수 있다.
*/</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalInterface</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalProxy</span> <span class="kd">implements</span> <span class="nc">AnimalInterface</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalProxy</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before eating"</span><span class="o">);</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After eating"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 클라이언트</span>
<span class="nc">Animal</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">();</span>
<span class="nc">AnimalInterface</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnimalProxy</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
<span class="n">proxy</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><strong>동적 프록시 방식</strong>
<br />
프록시 객체를 런타임에 동적으로 생성하는 방식
<br />
일반적으로 유연성이 높고 프록시 객체를 동적으로 수정할 수 있어 더 많이 사용된다.</p>
<ul>
  <li>인터페이스를 구현하지 않은 클래스도 프록시 객체를 생성할 수 있다.</li>
  <li>프록시 객체를 동적으로 수정할 수 있다.</li>
  <li>더 다양한 기능을 수행할 수 있어 AOP 같은 패러다임에 사용하기 적합하다.</li>
  <li>런타임에 프록시객체를 생성하므로, 정적프록시 방식에 비해 성능이 떨어질 수 있다.</li>
  <li>컴파일 시점에 프록시객체를 알수 없어서 디버깅이 어려울 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog is eating."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
AnimalInvocationHandler 클래스는 InvocationHandler 인터페이스를 구현하여 invoke() 메서드를 재정의 한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AnimalInvocationHandler</span> <span class="kd">implements</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalInvocationHandler</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 이 메서드는 실제 객체의 메서드를 호출하기 전후의 실행시간을 출력한다.</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">animal</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Execution time: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ns"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
Dog 객체를 생성한 후 Proxy.newProxyInstance 메서드를 사용해 Animal 인터페이스를 구현하는 동적 프록시 객체를 생성한다.
이때, AnimalInvocationHandler 클래스를 InvocationHandler로 사용한다. 
마지막으로, 프록시 객체의 eat() 메서드를 호출하여 AOP가 적용된 결과를 출력한다.
*/</span>
<span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
<span class="nc">Animal</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Animal</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
    <span class="nc">Animal</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span>
    <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Animal</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span>
    <span class="k">new</span> <span class="nf">AnimalInvocationHandler</span><span class="o">(</span><span class="n">dog</span><span class="o">)</span>
<span class="o">);</span>
<span class="n">proxy</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="데코레이터-패턴">데코레이터 패턴</h2>
<p><strong>Decorator Pattern</strong>
<br />
객체의 기능을 동적으로 추가 / 변경 할 수 있도록 해주는 디자인 패턴이다.
<br />
객체를 래핑하고, 래핑된 객체에 새로운 기능을 추가해 새로운 객체를 생성하는 방식으로 동작한다.
<br />
이렇게 생성된 객체는 래핑된 객체의 기능을 그대로 사용하면서 새로운 기능을 추가한 객체가 된다.
<br />
이를통해, 확장성, 유연성이 높아지고 객체 간의 결합도가 낮아지게 된다.</p>

<p><br /></p>

<p><strong><em>객체를 수정하지 않고 기능을 동적으로 확장하기 위해 사용한다.</em></strong></p>
<ul>
  <li>객체에 대해 동적으로 새로운 기능을 추가하거나 기존 기능을 변경할 필요가 있을 때</li>
  <li>상속으로 인한 클래스의 확장이 어려운 경우에 확장이 필요한 기능을 데코레이터 클래스로 추가할 때</li>
  <li>객체의 수정 없이 기능을 추가하고 싶을 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off-2">trade-off</h3>

<hr />
<p><strong>장점</strong></p>
<ul>
  <li>객체의 기능을 동적으로 추가 / 변경 할 수 있어서 기존 코드를 변경하지 않고 기능을 추가할 수 있다.
    <ul>
      <li>데코레이터 패턴은 <strong>OCP원칙</strong> 을 준수한다.</li>
    </ul>
  </li>
  <li>객체간의 결합도가 낮다.</li>
  <li>객체를 책임별로 분리하기 용이하고 여러개의 데코레이터를 조합해 다양한 기능을 구현할 수 있다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>새로운 데코레이터 클래스를 만들어야 하기 때문에 클래스가 늘어난다.</li>
  <li>런타임에 객체를 생성하기 때문에 아주 약간의 오버헤드가 발생한다.</li>
  <li>초기 설계에 리소스가 든다.</li>
</ul>

<p><br /></p>

<h3 id="구현-2">구현</h3>

<hr />

<p><strong>인터페이스를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal을 데코레이팅하는 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalDecorator</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">decorate</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// AnimalDecorator를 구현한 구현 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogWithHat</span> <span class="kd">implements</span> <span class="nc">AnimalDecorator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">DogWithHat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">decorate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모자를 쓴 강아지"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 기존의 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog1</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>

        <span class="c1">// 모자를 쓴 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="n">dog2</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>추상클래스를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 구현클래스</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal을 데코레이팅하는 데코레이터 추상 클래스</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AnimalDecorator</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AnimalDecorator</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalDecorator를 구현한 Hat 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hat</span> <span class="kd">extends</span> <span class="nc">AnimalDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Hat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">animal</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"모자를 쓴 강아지"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 기존의 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog1</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>

        <span class="c1">// 모자를 쓴 Dog 객체</span>
        <span class="nc">Animal</span> <span class="n">dog2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="n">dog2</span><span class="o">.</span><span class="na">speak</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>람다를 이용한 구현</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">speak</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"멍멍"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Hat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Animal</span> <span class="n">animal</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">decorate</span><span class="o">;</span>  <span class="c1">// 함수형 인터페이스 사용</span>

    <span class="kd">public</span> <span class="nf">Hat</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">animal</span> <span class="o">=</span> <span class="n">animal</span><span class="o">;</span>
        <span class="n">decorate</span> <span class="o">=</span> <span class="o">(</span><span class="n">sound</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">sound</span> <span class="o">+</span> <span class="s">", 모자쓴 강아지"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">speak</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">decorate</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">animal</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span> <span class="c1">// "멍멍"</span>

        <span class="nc">Animal</span> <span class="n">dogWithHat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Hat</span><span class="o">(</span><span class="k">new</span> <span class="nc">Dog</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dogWithHat</span><span class="o">.</span><span class="na">speak</span><span class="o">());</span> <span class="c1">// "멍멍, 모자쓴 강아지"</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="싱글톤-패턴">싱글톤 패턴</h2>
<p><strong>Singleton Pattern</strong>
<br />
어떤 클래스의 인스턴스가 오직 한 개만 존재하도록 보장하고, 전역적인 접근점을 제공하는 디자인 패턴이다.</p>

<p><br /></p>

<p><strong><em>애플리케이션에서 단 하나의 인스턴스만을 생성하고 이에 대한 전역적인 접근을 제공하기 위해 사용한다.</em></strong></p>
<ul>
  <li>자원의 공유가 필요한 경우에 여러 객체를 생성하는 것이 비효율적인 경우</li>
  <li>상태를 유지해야 하는 로깅이나 캐싱 등의 객체가 필요한 경우</li>
  <li>불필요한 객체 생성을 방지하고 메모리 사용량을 줄이기 위해 객체를 관리할 필요가 있는 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-3">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>인스턴스를 오직 하나만 생성하기 때문에, 메모리 사용량이 줄어든다.</li>
  <li>유일한 인스턴스에 대한 접근점이 하나뿐이기 때문에, 인스턴스를 다른 클래스에서 변경할 수 없다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>멀티스레드 환경에서 동시성 문제가 발생할 수 있다.
    <ul>
      <li>동기화 처리가 필요하기 때문에 성능저하를 가져올 수 있다.</li>
    </ul>
  </li>
  <li><strong>OCP원칙</strong> 을 위반한다.
    <ul>
      <li>싱글톤객체를 사용하는 객체가 다른 객체에 의존할 경우, 변경 시 싱글톤객체도 같이 변경해야 할 수 있다.</li>
    </ul>
  </li>
  <li>전역적으로 사용할 수 있기 때문에 다른 객체들과의 결합도가 높아질 수 있다.
    <ul>
      <li><strong>Dependency Injection</strong> 사용으로 해결할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="구현-3">구현</h3>

<hr />

<p><strong>Eager Initialization 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 클래스가 로딩될 때, 인스턴스를 미리 생성하는 방식, thread safe 하지 않다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>Lazy Initialization 방식</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Double-Checked Locking</span>
<span class="c1">// 인스턴스가 필요한 시점에 생성하는 방식, thread safe 하다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">Singleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>스프링 프레임워크 방식</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
스프링에서는 빈(Bean)이라는 개념을 사용하며, 이 빈들은 스프링 컨테이너에서 생성되고 관리된다. 
이때, 스프링 컨테이너는 기본적으로 싱글톤 패턴을 적용하므로, 모든 빈들은 기본적으로 싱글톤으로 생성된다.
thread safe 하다.
*/</span>
<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyComponent</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="템플릿-메서드-패턴">템플릿 메서드 패턴</h2>
<p><strong>Template Method Pattern</strong>
<br />
상위 클래스에서 공통적인 로직을 구현하고 하위클래스에서 구체적으로 구현하기 위한 디자인 패턴이다.
<br />
추상클래스를 사용하는데, 공통로직을 구현하는 템플릿 메서드를 정의하고 하위클래스에선 이 템플릿 메서드를
<br />
상속받아 구체적인 구현을 한다. 상위클래스에서는 추상메서드를 선언해 하위클래스에서 구현을 강제할 수 있다.</p>

<p><br /></p>

<p><strong><em>상위클래스에서 공통부분을 정의하고 하위클래스에서 그 일부를 구체적으로 구현하기 위해 사용한다.</em></strong></p>
<ul>
  <li>일련의 공통작업이 있지만, 그 중 일부는 하위클래스에서 구현해야 하는 경우
    <ul>
      <li>다양한 구현 방법을 지원하면서 일관성을 유지해야 하는 경우</li>
    </ul>
  </li>
  <li>복잡한 알고리즘을 캡슐화하여 코드의 가독성을 높이고 유지보수를 용이하게 하는 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-4">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>중복코드를 줄일 수 있다.
    <ul>
      <li>공통으로 사용되어야 하는 로직이 있을경우, 추상클래스로 정의하여 한곳에서 관리할 수 있다.</li>
    </ul>
  </li>
  <li>일관성을 유지할 수 있다.
    <ul>
      <li>추상클래스에서 공통로직을 정의하므로, 여러 하위클래스에서 일관성있는 코드를 유지할 수 있다.</li>
    </ul>
  </li>
  <li>추상 클래스에서 정의한걸 상속받아 하위 클래스에서 구현하므로, 유연한 확장성을 가진다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>추상클래스와 구체클래스 간의 결합도가 높다.</li>
  <li>상 클래스가 변경될 경우 하위 클래스들도 함께 수정해야 한다.</li>
  <li>상속을 사용하기 때문에 하위 클래스의 개수가 많아질 경우 클래스의 수가 증가할 수 있다.</li>
</ul>

<p><br /></p>

<h3 id="구현-4">구현</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 추상클래스로 play() 메서드에서 공통로직을 정의하고, makeSound(), move() 의 구현을 강제한다.</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">makeSound</span><span class="o">();</span>
        <span class="n">move</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 클래스를 상속받은 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Running!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal 클래스를 상속받은 구현클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Meow!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Jumping!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>

        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cat</span><span class="o">();</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="팩토리-메서드-패턴">팩토리 메서드 패턴</h2>
<p><strong>Factory Method Pattern</strong>
<br />
객체 생성 코드를 클라이언트에서 분리시켜 객체 생성을 캡슐화하는 디자인 패턴이다.
<br />
객체 생성의 책임을 서브클래스에 위임하여 서브클래스가 어떤 클래스의 인스턴스를 만들지 결정하게 한다. 
<br />
이렇게 함으로써 코드를 수정하지 않고도 객체의 타입을 바꿀 수 있는 유연성을 제공한다.
<br /></p>

<p><br /></p>

<p><strong><em>객체 생성을 서브클래스에서 처리하도록 하여 객체 생성 과정을 유연하게 관리하기 위해 사용한다.</em></strong></p>
<ul>
  <li>객체 생성에 필요한 정보가 런타임 시에 결정되는 경우</li>
  <li>객체 생성 방법을 변경해야 할 때 전체 코드를 수정하지 않고 유지보수성을 높이고 싶을 때</li>
</ul>

<p><br /></p>

<h3 id="trade-off-5">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>객체생성 코드를 캡슐화 할 수 있다.</li>
  <li>객체생성 코드를 중앙화 하여 한곳에서 관리해 가독성을 높일 수 있다.</li>
  <li>서브클래스를 추가하거나 수정해 객채생성에 대한 확장성이 높아진다.</li>
  <li>다형성을 활용한 디자인 패턴이다.
    <ul>
      <li>클라이언트 코드가 객체의 타입이 아닌 인터페이스를 통해 객체에 접근할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>서브클래스를 추가해야 하므로 클래스 수가 증가한다.</li>
  <li>추상화 수준이 높아지기 때문에 가독성이 떨어진다.</li>
</ul>

<p><br /></p>

<h3 id="구현-5">구현</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Animal 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getAnimalName</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// Animal 인터페이스를 구현하는 Dog 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAnimalName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Dog"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal 인터페이스를 구현하는 Cat 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getAnimalName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Cat"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalFactory 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AnimalFactory</span> <span class="o">{</span>
    <span class="nc">Animal</span> <span class="nf">createAnimal</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// AnimalFactory 인터페이스를 구현하는 DogFactory 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DogFactory</span> <span class="kd">implements</span> <span class="nc">AnimalFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Animal</span> <span class="nf">createAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Dog</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// AnimalFactory 인터페이스를 구현하는 CatFactory 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CatFactory</span> <span class="kd">implements</span> <span class="nc">AnimalFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Animal</span> <span class="nf">createAnimal</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Cat</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AnimalFactory</span> <span class="n">dogFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DogFactory</span><span class="o">();</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">dogFactory</span><span class="o">.</span><span class="na">createAnimal</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="na">getAnimalName</span><span class="o">());</span> <span class="c1">// "Dog" 출력</span>

        <span class="nc">AnimalFactory</span> <span class="n">catFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CatFactory</span><span class="o">();</span>
        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="n">catFactory</span><span class="o">.</span><span class="na">createAnimal</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">getAnimalName</span><span class="o">());</span> <span class="c1">// "Cat" 출력</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="전략-패턴">전략 패턴</h2>
<p><strong>Strategy Pattern</strong>
<br />
알고리즘의 집합을 정의하고 각각을 캡슐화하여 동적으로 교체하여 사용할 수 있는 디자인 패턴</p>

<p><br /></p>

<p><strong><em>알고리즘을 캡슐화하여 동적으로 교환할 수 있도록 만들어 유연한 애플리케이션을 구현하기 위해 사용한다.</em></strong></p>
<ul>
  <li>런타임 시에 알고리즘을 선택할 필요가 있는 경우</li>
  <li>비슷한 알고리즘을 여러 개 가지고 있고, 이를 쉽게 변경하고 유지보수하고 싶은 경우</li>
  <li>알고리즘의 구현 내용을 클라이언트와 분리하여 의존성을 낮추고 싶은 경우</li>
</ul>

<p><br /></p>

<h3 id="trade-off-6">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>알고리즘을 동적으로 교체할 수 있고 캡슐화 할 수 있다.</li>
  <li>전략객체를 독립적으로 변경할 수 있기 때문에 객체간 결합도가 감소한다.</li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>인터페이스와 클래스 수가 많아진다.</li>
  <li>많은 전략을 사용할 수 있지만 이걸 모두 객체로 생성하는건 무리다.</li>
  <li>컨텍스트, 전략객체, 인터페이스 사용으로 비용이 증가할 수 있다</li>
</ul>

<p><br /></p>

<h3 id="구현-6">구현</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 전략(알고리즘)을 캡슐화한 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MoveStrategy</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">move</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 전략(알고리즘)을 구현한 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WalkStrategy</span> <span class="kd">implements</span> <span class="nc">MoveStrategy</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"걷는다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 전략(알고리즘)을 구현한 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RunStrategy</span> <span class="kd">implements</span> <span class="nc">MoveStrategy</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"달린다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 컨텍스트(전략을 사용하는 클래스)</span>
<span class="c1">// 생성자를 통해 MoveStrategy 인터페이스를 구현한 객체를 받아서 실행한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">MoveStrategy</span> <span class="n">moveStrategy</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Animal</span><span class="o">(</span><span class="nc">MoveStrategy</span> <span class="n">moveStrategy</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">moveStrategy</span> <span class="o">=</span> <span class="n">moveStrategy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">move</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">moveStrategy</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Animal 객체를 생성할 때 원하는 전략 객체를 주입하여 원하는 동작을 실행한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="k">new</span> <span class="nc">WalkStrategy</span><span class="o">());</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>

        <span class="nc">Animal</span> <span class="n">cat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Animal</span><span class="o">(</span><span class="k">new</span> <span class="nc">RunStrategy</span><span class="o">());</span>
        <span class="n">cat</span><span class="o">.</span><span class="na">move</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="템플릿-콜백-패턴">템플릿 콜백 패턴</h2>
<p><strong>Template Callback Pattern</strong>
<br />
알고리즘의 구조를 정의하고 구체적인 단계나 구현 방법을 서브클래스에서 결정하는 방식의 디자인 패턴
<br />
자바에선 인터페이스나 추상클래스를 상위 클래스로 사용하고 하위클래스에서 구현한 메서드(콜백) 를
<br />
상위클래스에서 호출하면서, 하위클래스가 직접 실행할 수 있는 유연성을 제공한다.
<br />
<br />
<strong>템플릿 콜백 패턴은 템플릿 메서드 패턴을 확장한 개념으로, 기본적인 구조는 매우 유사하다.</strong>
<br />
<strong>다른점은, 하위클래스에서 콜백메서드를 제공하고 상위클래스에서 호출하는 방식으로 동작한다.</strong></p>

<p><br /></p>

<p><strong><em>중복 코드를 줄이고 알고리즘을 캡슐화하여 재사용성과 유지보수성을 높이기 위해 사용한다.</em></strong></p>
<ul>
  <li>알고리즘의 골격을 유지하면서 상세한 구현 부분을 변경할 수 있는 경우
    <ul>
      <li>비슷한 알고리즘에 대해 중복 코드를 줄이면서 구현을 변경하고 싶을 때</li>
    </ul>
  </li>
  <li>다양한 클라이언트 요구사항을 만족시키면서 일관성을 유지해야 하는 경우
    <ul>
      <li>여러 클라이언트 요구사항을 수용하면서 알고리즘을 유지보수 가능한 방식으로 구현하고 싶을 때</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h3 id="trade-off-7">trade-off</h3>

<hr />

<p><strong>장점</strong></p>
<ul>
  <li>상위클래스에서 정의한 알고리즘 구조를 여러 하위클래스에서 재사용 및 수정 할 수 있다.
    <ul>
      <li>콜백메서드를 추가하거나 하위클래스를 추가하여 확장성에서도 용이하다.</li>
    </ul>
  </li>
  <li><strong>다형성</strong>
    <ul>
      <li>추상메서드를 상위클래스에 선언하고 하위클래스에서 구체적으로 구현하는 방식</li>
      <li>상위클래스에선 구현에 대한 세부정보를 몰라도 되고, 콜백메서드를 호출함으로써 다형성 활용</li>
    </ul>
  </li>
  <li><strong>제어의 역전</strong>
    <ul>
      <li>상위클래스에서 하위클래스의 콜백 메서드를 호출하기 때문에 제어의 흐름이 역전된다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>단점</strong></p>
<ul>
  <li>추상클래스 또는 인터페이스 등을 사용해야 하기 때문에 복잡해진다.</li>
  <li>알고리즘 구조를 변경하려면 상위클래스를 수정해야 한다.</li>
  <li>다수의 메서드 호출이 발생하기 때문에 약간의 오버헤드 발생</li>
</ul>

<p><br /></p>

<h3 id="구현-7">구현</h3>

<hr />

<p><strong>추상클래스를 사용한 방식</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
performActivity() 메서드를 실행하여 알고리즘의 구조를 정의하고, 
하위 클래스에서 구현할 specificActivity() 메서드를 추상 메서드로 선언
*/</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">doActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Getting ready to do activity..."</span><span class="o">);</span>
        <span class="n">performActivity</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Activity is completed!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 하위 클래스에서 구현해야 할 콜백 메서드</span>
    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">performActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Performing activity..."</span><span class="o">);</span>
        <span class="n">specificActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 콜백 메서드인 specificActivity() 메서드를 구현</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dog is barking."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">doActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>인터페이스를 사용한 방식</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
performActivity() 메서드를 실행하여 알고리즘의 구조를 정의하고, 
하위 클래스에서 구현할 specificActivity() 메서드를 선언
*/</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">doActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Getting ready to do activity..."</span><span class="o">);</span>
        <span class="n">performActivity</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Activity is completed!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 하위 클래스에서 구현해야 할 콜백 메서드</span>
    <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">();</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">performActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Performing activity..."</span><span class="o">);</span>
        <span class="n">specificActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 콜백 메서드인 specificActivity() 메서드를 구현</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">specificActivity</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dog is barking."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">doActivity</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="어댑터 패턴" /><category term="프록시 패턴" /><category term="데코레이터 패턴" /><category term="싱글톤 패턴" /><category term="템플릿 메서드 패턴" /><category term="팩터리 메서드 패턴" /><category term="전략 패턴" /><category term="템플릿 콜백 패턴" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">SOLID</title><link href="http://localhost:4000/til/SOLID/" rel="alternate" type="text/html" title="SOLID" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/til/SOLID</id><content type="html" xml:base="http://localhost:4000/til/SOLID/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="solid">SOLID</h1>
<p>객체지향 프로그래밍에서 소프트웨어 디자인 품질을 향상시키기 위한 다섯 가지 원칙이다.
<br />
이 원칙을 따르면 아래와 같은 장점이 있다.</p>

<ul>
  <li>유지보수성 향상</li>
  <li>재사용성 항샹</li>
  <li>확장성 향상</li>
  <li>변경에 대한 유연성 향상</li>
  <li>코드의 가독성 향상</li>
  <li>결합도 감소</li>
  <li>테스트 용이성 향상</li>
  <li>오류발생 가능성 감소</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="srp---단일-책임-원칙">SRP - 단일 책임 원칙</h2>
<p>하나의 클래스는 하나의 책임을 가져야 한다는 원칙이다.
<br />
이것은 클래스가 변경되어야 하는 이유는 단 하나여야 함을 의미한다.
<br />
클래스의 응집력은 높이고 결합도는 낮춰서 유지보수, 재사용성, 확장성에 용이하게 하는 원칙으로, 
<br />
클래스 하나가 여러 책임을 가지게 되면 그 클래스를 변경해야 하는 이유도 여러가지가 생기므로, 
<br />
코드를 변경할때 다른 책임과 관련된 코드까지 함께 변경해야 한다. 
<br />
<br />
<strong>SRP</strong> 원칙을 지키기 위해서는 클래스가 자신의 책임을 명확하게 정의하고, 
<br />
다른 책임을 수행하는 클래스와의 의존성을 최소화 해야한다.
<br />
<br />
<strong>단점으로는</strong> 클래스와 인터페이스 수가 늘어나게 되고 클래스간의 상호작용을 복잡하게 만들 수 있다.
<br />
<br />
자바에서 <strong>SRP</strong> 를 구현하는 방식에는 <strong>클래스를 단일책임으로 분리</strong>, 
<br />
<strong>인터페이스를 이용해 책임을 분리</strong>, <strong>디자인패턴</strong>, <strong>AOP</strong> 등이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>클래스를 단일 책임으로 분리하는 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Order 클래스는 너무 많은 책임을 가지고 있다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Customer</span> <span class="n">customer</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">()</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// 클래스의 책임을 분리함으로써, 클래스간 의존성이 낮아지게 된다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderItem</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Item</span> <span class="n">item</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCalculator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderItem</span><span class="o">&gt;</span> <span class="n">orderItems</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>인터페이스로 책임을 분리하는 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 상품 목록을 관리하는 ItemManager 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// 이메일을 전송하는 EmailSender 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// ItemManager 인터페이스를 구현하는 ItemManagerImpl 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemManagerImpl</span> <span class="kd">implements</span> <span class="nc">ItemManager</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeItem</span><span class="o">(</span><span class="nc">Item</span> <span class="n">item</span><span class="o">)</span> <span class="o">{}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">calculateTotalPrice</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// EmailSender 인터페이스를 구현하는 EmailSenderImpl 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSenderImpl</span> <span class="kd">implements</span> <span class="nc">EmailSender</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendConfirmEmail</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="ocp---개방--폐쇄-원칙">OCP - 개방 / 폐쇄 원칙</h2>
<p>소프트웨어 구성요소 (클래스, 모듈, 함수 등) 는 확장에는 열려있어야 하지만, 변경에는 닫혀 있어야 한다. 
<br />
즉, 기존의 코드를 변경하지 않아도 새로운 기능을 추가할 수 있도록 하는 것이다.
<br />
<strong>OCP</strong> 는 다형성, 추상화, 인터페이스 등을 통해 내부 구현을 외부로 노출시키지 않고도 기능을 확장할 수 있는데
<br />
이는 코드의 유지보수, 확장성, 재사용성 등을 향상시킬 수 있다.
<br />
<br />
<strong>단점으로는</strong> 초기 설계와 인터페이스 설계등의 리소스가 많이 들어가게 되며 OCP를 적용하기 위해 
<br />
인터페이스와 추상화를 사용해 내부의 세부 구현사항을 숨기게 되면 코드의 복잡성이 증가하게 된다.
<br />
<br />
자바에서 <strong>OCP</strong> 를 구현하는 방식에는 
<br />
<strong>추상클래스 / 인터페이스</strong>, <strong>전략패턴</strong>, <strong>팩토리 메서드 패턴</strong>, <strong>데코레이터 패턴</strong> 등이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>추상클래스를 이용한 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 새로운 동물인 고양이를 이렇게 기존 코드를 변경하지 않고 확장할 수 있다. Cat 클래스는 Animal 타입으로 선언될 수 있고,</span>
<span class="c1">// Animal 타입으로 다루어 질때 makeSound() 메서드가 호출된다.</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>인터페이스를 이용한 방식</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"멍멍"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 기존의 코드를 변경하지 않고 Cat 클래스를 확장</span>
<span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"야옹"</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="lsp---리스코프-치환-원칙">LSP - 리스코프 치환 원칙</h2>
<p>하위타입은 상위타입으로 대체 가능해야 한다는 원칙이다. 
<br />
상속관계에서 부모클래스에 선언된 속성과 메서드는 하위클래스에서 동일하게 동작해야 한다.
<br />
즉, <strong>하위클래스가 상위클래스의 기능을 정확하게 대체할 수 있어야 한다.</strong>
<br />
<strong>LSP</strong> 는 유연한 확장, 재사용성 등에 장점이 있다.
<br />
<br />
<strong>단점으로는</strong> 설계에 리소스가 들어가게 되며 <strong>LSP</strong> 는 인터페이스와 상속관계에서만 적용할 수 있다.
<br />
<br />
자바에서 <strong>LSP</strong> 를 구현하는 방식에는 <strong>인터페이스</strong>, <strong>상속</strong> 이 있다.</p>

<p><br /></p>

<ul>
  <li><strong>LSP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span> 
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BigDog</span> <span class="kd">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Big bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging at speed "</span> <span class="o">+</span> <span class="n">speed</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
BigDog 클래스의 wagTail() 메서드는 Dog 클래스의 wagTail() 메서드와
시그니처가 다르기 때문에 에러가 발생한다.
즉, BigDog 객체가 Dog 객체를 완벽하게 대체하지 못한다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">bigDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDog</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">();</span>  <span class="c1">// 컴파일 에러 발생</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>LSP 를 준수한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bark"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">BigDog</span> <span class="kd">extends</span> <span class="nc">Dog</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">makeSound</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Big bark"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">wagTail</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">wagTail</span><span class="o">(</span><span class="kt">int</span> <span class="n">speed</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Tail wagging at speed "</span> <span class="o">+</span> <span class="n">speed</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Dog 클래스와 BidDog 클래스 모두 같은 wagTail() 메서드를 가지게 된다.</span>
<span class="c1">// Dog 객체를 대신하여 BigDog 객체를 사용할 때 문제가 일어나지 않는다.</span>
<span class="c1">// 즉, 부모클래스를 자식클래스로 대체해도 동일한 기능을 수행해서 LSP를 준수한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">BigDog</span> <span class="n">bigDog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDog</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">makeSound</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">();</span>
        <span class="n">bigDog</span><span class="o">.</span><span class="na">wagTail</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="isp---인터페이스-분리-원칙">ISP - 인터페이스 분리 원칙</h2>
<p>인터페이스 분리 원칙을 의미한다.
<br />
즉, 인터페이스가 클라이언트에서 필요한 메서드만 가지도록 권장한다.
<br />
이렇게 함으로써 클라이언트 입장에선 필요하지 않은 메서드를 호출하거나
<br />
구현할 필요가 없게되고, 이것은 의존성을 줄이고 유지보수, 재사용성을 증가시킨다.
<br />
<br />
<strong>단점으로는</strong> <strong>인터페이스</strong> 와 <strong>클래스</strong> 가 많아지는 문제가 있다.</p>

<p><br /></p>

<ul>
  <li><strong>ISP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">fly</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bird</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fly</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="cm">/*
Bird 클래스는 run() 메서드를 구현하지 않고, Dog 클래스는 fly() 메서드를 구현하지 않는다.
이것은 필요하지 않은 메서드를 구현체에서 구현하기 때문에 ISP 원칙을 위반한다.

Animal 인터페이스를 run() 메서드와 fly() 메서드를 각각 가지는 2개의 인터페이스로 분리하면
ISP 원칙을 준수할 수 있다.
*/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">bird</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Bird</span><span class="o">();</span>
        <span class="n">bird</span><span class="o">.</span><span class="na">fly</span><span class="o">();</span>
        
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">fish</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="dip---의존관계-역전-원칙">DIP - 의존관계 역전 원칙</h2>
<p>상위모듈이 하위모듈에게 의존하면 안되며 둘다 추상화에 의존해야 한다는 원칙이다.
<br />
즉, 클래스는 다른 클래스에 의존하지말고 추상화를 통해 상호작용 해야 한다는 의미이다.
<br />
이것은 결합도를 낮추기 위한 방식으로 객체간의 의존성을 느슨하게 만드는 효과가 있다.
<br />
<strong>DIP</strong> 를 준수하면 하위 모듈이 변경되어도 상위 모듈에 영향이 없으므로 유연성과 확장성이 향상된다.
<br />
<br />
<strong>단점으로는</strong> 추상화를 위한 <strong>인터페이스</strong> 와 <strong>추상클래스</strong> 가 많아지고 복잡성이 증가한다.</p>

<p><br /></p>

<ul>
  <li><strong>DIP 를 위반한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UserRepository</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="c1">// UserRepository 에 직접 의존하고 있으므로 UserRepository 클래스의 변경이 UserService 에게 영향을 준다.</span>
<span class="kd">class</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<ul>
  <li><strong>DIP 를 준수한 코드</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">UserService</span><span class="o">(</span><span class="nc">UserRepository</span> <span class="n">userRepository</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">userRepository</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findUserById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
UserService 클래스는 UserRepository 인터페이스에만 의존하도록 하고 생성자를 통해 주입받는다.
이제 UserRepository 클래스의 구현체인 DatabaseUserRepository 클래스가 UserRepository 인터페이스를 구현하도록 해서 DatabaseUserRepository 클래스가 변경되더라도 UserService 클래스에 영향을 미치지 않는다.
*/</span>
<span class="kd">class</span> <span class="nc">DatabaseUserRepository</span> <span class="kd">implements</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h2 id="책임이란">책임이란?</h2>
<p>객체가 수행하는 역할 또는 기능을 말한다. <strong>책임은 객체의 상태와 행위를 결정한다.</strong>
<br />
<strong>SOLID원칙</strong> 에서 책임은 객체나 모듈은 단 한가지의 책임을 가져야 하고 
<br />
이 객체나 모듈이 변경될 이유는 단 하나여야만 한다.
<br />
즉, 변경이 일어날 때 해당 객체만을 수정하면 단일책임원칙을 따르는 것이고 해당 객체 뿐만이 아니라
<br />
다른객체 까지 수정이 일어나면 단일책임원칙을 준수하지 못한것이다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="SRP" /><category term="OCP" /><category term="LSP" /><category term="ISP" /><category term="DIP" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">OOP</title><link href="http://localhost:4000/til/OOP/" rel="alternate" type="text/html" title="OOP" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/til/OOP</id><content type="html" xml:base="http://localhost:4000/til/OOP/"><![CDATA[<p><br /><br /><br /></p>

<h1 id="oop">OOP</h1>
<p>어플리케이션을 구성하는 요소들을 객체로 보고, 
<br />
객체들을 유기적으로 연결하여 상호작용하는 방식으로 프로그래밍 하는걸 말한다. 
<br />
데이터와 이를 처리하는 루틴을 하나의 <strong>독립된 객체</strong> 로 보고 기능적으로 관련된 
<br />
데이터와 메서드를 묶는 것을 중심으로 한다.
<br />
재사용성, 유지보수 에 용이하고 대형 프로젝트에 적합하다.
<br />
하지만 속도가 상대적으로 느리고, 설계 시 많은 리소스가 들어간다.</p>

<p><br /></p>

<ul>
  <li><strong>객체</strong>
    <ul>
      <li>속성과 동작을 가진다.</li>
      <li>속성은 객체의 상태를 나타내고, 동작은 객체의 행동을 나타낸다.</li>
      <li>자동차 객체를 예로 들면
        <ul>
          <li>속성 : 색상, 모델, 브랜드 등</li>
          <li>동작 : 가속, 감속, 정지 등</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>추상화</strong>
    <ul>
      <li>목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>캡슐화</strong>
    <ul>
      <li>정보은닉 - 접근제어자</li>
      <li>코드의 의존성을 줄이고, 결합도를 낮추는 것</li>
      <li>필요한 부분만 외부에 노출시키고 나머지는 숨긴다.</li>
      <li>외부에서 불필요한 의존을 할 일이 없어지고 의존성이 줄어드는 만큼 유지보수도 편해진다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속</strong>
    <ul>
      <li>코드의 재사용성에 이점이 있지만 코드의 재사용성만을 위해 사용은 지양한다.</li>
      <li>흔히 재사용성 뿐 아니라 계층구조 같은 구조를 만들 때 사용하자</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<ul>
  <li><strong>다형성</strong>
    <ul>
      <li>객체지향의 꽃이라고도 불린다.</li>
      <li>형태가 같지만 다른 기능을 하는 것을 말한다.</li>
      <li>하나의 타입에 여러 객체를 대입할 수 있는 성질이다.
        <ul>
          <li>업캐스팅
            <ul>
              <li>서로 다른 클래스의 인스턴스를 동일한 타입에 할당할 수 있게 한다.</li>
            </ul>
          </li>
          <li>동적바인딩
            <ul>
              <li>메시지를 수신했을 때 실행도리 메서드가 런타임에 결정된다.</li>
            </ul>
          </li>
          <li>오버로딩</li>
          <li>오버라이딩</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop-왜쓰는데">OOP 왜쓰는데?</h2>
<ul>
  <li><strong>재사용성</strong>
<br />
<br />
클래스와 상속을 사용해 이미 작성된 코드를 쉽게 재사용 할 수 있고,
<br />
이로인해 코드의 일관성을 유지할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>코드의 구조화와 유지보수</strong>
<br />
<br />
객체를 사용해 기능적으로 관련된 데이터와 메서드를 묶어서 관리할 수 있다.
<br />
이로인해 코드의 일관성을 유지할 수 있고,
<br />
새로운 기능이 추가될 때 기존 코드를 변경하지 않아도 되므로 유지보수성을 높일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>캡슐화</strong>
<br />
<br />
객체간의 상호작용을 캡슐화 하여 데이터의 안정성을 유지할 수 있다.
<br />
객체는 자신만의 속성과 동작을 가지고 있으며, 다른 객체와 상호작용 할때 인터페이스를 통해
<br />
메시지를 주고받으므로 데이터가 보호되고, 객체간의 의존성을 줄일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속을 통한 코드 재사용</strong>
<br />
<br />
상속이란 이미 작성된 코드를 확장하거나 변경하여 새로운 클래스를 생성하는 방식이다.
<br />
기존 클래스를 기반으로 함으로 재사용성, 유지보수성을 높일 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>다형성</strong>
<br />
<br />
다형성이란 객체가 다양한 형태로 동작할 수 있는 방식이다.
<br />
객체가 동일한 메시지를 받을때, 각각 다르게 동작할 수 있고 이로인해 코드를 유연하게 작성할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>현실세계와의 유사성</strong>
<br />
<br />
현실세계를 반영하므로 코드를 보다 직관적으로 작성할 수 있다.
<br />
예를들어, 자동차 객체를 만들때 자동차의 특징과 동작을 모델링하여 코드를 작성할 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>협업</strong>
<br />
<br />
객체는 개별적인 역할과 책임을 가지므로 여러 개발자가 동시에 작업할 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop-단점">OOP 단점</h2>

<ul>
  <li><strong>복잡성</strong>
<br />
<br />
객체지향적인 설계는 추상화를 통해 복잡성을 감추지만, 구현을 위해 많은 코드가 필요하며
<br />
이로인해 코드의 복잡성이 증가할 수 있다.
<br />
또한 어플리케이션이 커질수록 객체 간의 상호작용과 의존성이 많아지고 그럴수록 복잡성은 증가한다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>성능</strong>
<br />
<br />
객체를 생성하고 관리하기 위한 추가적인 오버헤드가 있으므로 성능 저하가 발생 할 수 있다.
<br />
또한 캡슐화 때문에 데이터에 접근하기 위한 추가비용이 들어가고 이는 데이터에 직접 접근하는 
<br />
절차지향 프로그래밍 보다 느릴 수 있다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>설계</strong>
<br />
<br />
명확한 구조와 규칙을 필요로 하고 객체간의 관계를 적절히 설계해야 하는 등 설계에 많은 리소스가 들어간다.</li>
</ul>

<p><br /></p>

<ul>
  <li><strong>상속 남용</strong>
<br />
<br />
상속을 남용하면 중복코드가 생기고 클래스간의 관계가 복잡해질 수 있고 
<br />
하위 클래스가 상위클래스에 의존하게 되어 하위클래스 수정이 상위클래스까지 영향을 미칠 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop의-특징">OOP의 특징</h2>

<p><br /></p>

<h3 id="oop와-캡슐화">OOP와 캡슐화</h3>
<p><br />
객체를 추상화 하고, 객체의 내부 상태와 동작을 외부로부터 보호하는것을 의미한다.
<br />
객체의 내부 구현을 외부에 숨기고, 객체와 객체간의 상호작용을 인터페이스를 통해서 해서
<br />
객체의 상태를 외부에서 변경할 수 없도록 하고, 변경에 대한 책임을 객체 스스로가 갖도록 한다.
<br />
즉, 객체의 구현 세부사항을 숨기고 객체간의 결합도를 낮추는 효과를 가져온다.
<br />
객체의 구현 세부 사항을 숨기는 것을 객체지향설계 에선 <strong>정보은닉</strong> 이라고 부른다.
<br />
상속과 다형성의 개념과도 관련이 있는데,
<br />
부모클래스의 캡슐화된 멤버 변수와 메서드를 재사용할 수 있도록 하고
<br />
캡슐화된 인터페이스를 이용해 서로 다른 객체를 동일한 방식으로 다룰 수 있도록 한다.
<br />
캡슐화는 <strong>OOP</strong> 에서 객체의 추상화, 모듈화, 재사용성 등의 장점을 실현하는데 중요한 역할을 한다.</p>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-상속">OOP와 상속</h3>
<p><br />
상속이란 부모클래스가 자식클래스에게 자신의 속성과 행위들을 물려주는 것을 의미한다.
<br />
이를 통해 자식클래스는 부모클래스의 기능을 그대로 물려받고, 새로운 속성과 행위를 추가할 수 있다.
<br />
부모 클래스에서 구현한 코드를 자식클래스에서 사용할 수 있으므로 코드의 재사용성이 높아지며
<br />
부모 클래스의 코드를 수정하면 자식클래스에서도 이를 반영하므로 유지보수가 용이해 진다.
<br />
자식클래스는 <strong>오버라이딩</strong> 를 통해 부모클래스의 메서드를 재정의 하여 사용할 수 있고 확장성이 좋아진다.
<br />
<br />
하지만 상속을 남용할 경우, 클래스 간의 복잡한 계층구조가 형성되고 복잡해 지며 유지보수가 어려워 진다.
<br />
또한, 결합도가 높아지기 때문에 부모클래스의 변경이 자식클래스에게도 영향을 미치게 된다.</p>

<p><br />
<strong>상속을 사용할 때</strong>
<br /></p>
<ul>
  <li>부모클래스의 기능을 그대로 사용하면서 새로운 기능을 추가하려는 경우</li>
  <li>부모와 자식클래스 간의 상속관계를 통해 다형성을 구현하려는 경우</li>
  <li>기존 클래스를 수정하지 않고 확장하려는 경우</li>
  <li>공통적인 기능이 있는 클래스들을 만들 때</li>
</ul>

<p><br />
<strong>상속을 사용하지 않을 때</strong>
<br /></p>
<ul>
  <li>계층구조가 복잡할 때</li>
  <li>결합도가 높아질 때</li>
  <li>상속구조가 고정되어 있을때
    <ul>
      <li>이 경우 인터페이스를 이용해 클래스간의 관계를 정의하는 편이 더 나을 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br />
<strong>합성(Composition)?</strong>
<br />
<br />
합성은 객체를 조합해 새로운 객체를 만드는 방법이다. 합성을 이용하면 코드의 재사용성을 높이면서
<br />
클래스간의 결합도를 낮출 수 있다. 다른 클래스의 인스턴스를 생성하여 이를 이용하는 방법인데
<br />
상위클래스와 하위클래스 간의 강한 결합을 피할 수 있다.
<br />
상속은 부모와 자식간의 강한 계층구조를 가지지만 합성은 클래스 간의 관계를 느슨하게 유지한다.
<br />
클래스간의 관계를 조정하여 필요한 기능만을 조합하여 사용하기 때문에 클래스간의 결합도가 낮아진다.
<br />
예를들어 자동차 클래스에서 엔진, 타이어, 핸들 클래스를 각각 상속받는게 아니고, 자동차 클래스에서
<br />
엔진, 타이어, 핸들 클래스의 인스턴스를 생성하여 이를 이용하는 방법이다.
<br />
이를통해 자동차, 엔진, 타이어, 핸들 클래스 간의 결합도를 낮출 수 있다.
<br />
<br />
<strong>상속보단 합성?</strong></p>
<ul>
  <li>객체간의 결합도가 낮은 경우 : 객체가 변경되도 다른객체에 영향을 주지 않는다.</li>
  <li>변경이 상위 객체에 영향을 주지 않는 경우 : 객체의 변경에 유연성을 가진다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Engine started"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>

    <span class="nc">Car</span> <span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Engine</span> <span class="n">engine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
        <span class="nc">Car</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
        <span class="n">car</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h4 id="서브클래싱">서브클래싱</h4>
<p><br />
상속을 통해 부모 클래스의 특성을 상속받아 새로운 클래스를 만드는 것을 말한다.
<br />
자식클래스는 부모클래스로부터 상속받은 속성과 메서드를 사용할 수 있고, 
<br />
상속받은 기능을 추가하거나 변경할 수 있다.
<br />
즉, 부모클래스의 기능을 재사용하고, 그 기능을 수정하거나 확장할 수 있다.</p>

<ul>
  <li><strong>장점</strong>
    <ul>
      <li>부모클래스에 구현된 코드로 재사용성을 높임</li>
      <li>서브클래싱으로 같은 인터페이스를 갖는 클래스를 여러개 만들어 다형성을 지원</li>
    </ul>
  </li>
  <li><strong>단점</strong>
    <ul>
      <li>부모 자식 클래스 간의 강한 결합으로 인한 유지보수의 어려움</li>
      <li>부모클래스의 모든 기능을 상속받기때문에 불필요한 기능 또는 데이터까지 상속받아 객체가 거대해 짐</li>
      <li>서브클래스가 많아 질 수록 클래스간의 계층이 복잡해져서 의존성이 높아지고 가독성과 수정이 어려워짐</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h4 id="서브타이핑">서브타이핑</h4>
<p><br />
상속을 통해 부모클래스와 자식클래스 간의 포함 관계를 정의하는 것을 말한다.
<br />
서브타이핑을 이용하면 자식클래스는 부모클래스의 모든 속성과 메서드를 상속받아 사용할 수 있다.
<br />
또한 자식클래스는 상속받은 특성을 그대로 사용할 수도, 재정의하거나 새로운 메서드를 추가할 수 있다.
<br />
서브타이핑을 통해 부모와 자식클래스 간의 포함 관계를 정의하고, 부모클래스 타입의 변수에 자식클래스
<br />
객체를 할당하여 다형성을 구현하는 다형성의 핵심 개념중 하나이다.
<br />
하지만 부모 자식간의 밀접한 결합이 발생하고, 서브타입 다형성을 사용하면 객체가 어떤 메서드를 호출할지
<br />
런타임에 타입체크를 수행해야 하므로 불필요한 오버헤드가 발생할 수 있다.</p>

<p><br />
<br /></p>

<h4 id="둘의-차이-및-정리">둘의 차이 및 정리</h4>
<p><br />
둘다 객체지향 프로그래밍에서 다형성을 구현하기 위해 사용되는 개념이다.
<br />
<br />
<strong>서브클래싱</strong> 은 부모 클래스에서 상속받은 메서드와 속성을 그대로 사용하면서, 자식클래스에서는
<br />
새로운 기능을 추가하거나 변경하는걸 의미한다. 이는 코드의 재사용성과 확장성을 높이는 역할을 한다.
<br />
<br />
<strong>서브타이핑</strong> 은 부모클래스의 <strong>하위타입</strong> 인 자식클래스를 생성하고, 이를통해 객체의 다형성을 구현하는 것이다.
<br />
즉, <strong>부모클래스의 인스턴스를 자식클래스의 인스턴스로 대체</strong> 할 수 있도록 구현하는 것이다.
<br />
<br />
둘의 가장 큰 차이점은 상속에 대한 의미이다.
<br />
<br />
<strong>서브클래싱</strong> 은 부모 클래스로부터 상속받은 기능을 그대로 사용하면서 기능을 변경하거나 확장하는 것이고,
<br />
클래스의 계층구조를 만들어 코드의 재사용성과 확장성을 높이는데 주로 사용된다.
<br />
<br />
<strong>서브타이핑</strong> 은 부모 자식 클래스 간의 포함관계를 만들어 객체의 다형성을 구현하는것이 목표이다.
<br />
인터페이스와 추상클래스를 사용하여 다형성을 구현하는데 주로 사용된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
서브클래싱
Dog 클래스는 Animal 클래스를 상속받아 eat() 메서드를 사용하면서,
새로운 기능인 bark() 메서드를 추가해서 사용한다.
*/</span>
<span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The animal eats."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog barks."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">bark</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/*
서브타이핑
Animal 인터페이스를 구현한 Dog 클래스에서 eat() 메서드를 구현하고, bark() 메서드를 추가한다.
그리고 Animal 인터페이스를 구현한 Dog 클래스를 생성해 feedAnimal() 메서드에 전달한다.
feedAnimal() 메서드는 Animal 인터페이스 타입의 매개변수를 받기 때문에,
Dog 클래스의 객체를 Animal 인터페이스로 대체할 수 있게 된다.
*/</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog eats."</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kt">void</span> <span class="nf">bark</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The dog barks."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">feedAnimal</span><span class="o">(</span><span class="nc">Animal</span> <span class="n">animal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">animal</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">feedAnimal</span><span class="o">(</span><span class="n">dog</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-추상화">OOP와 추상화</h3>
<p><br />
<strong>추상화</strong> 는 객체를 설계하는 과정에서 필요한 정보만 선택하고 나머지는 숨겨서 단순하게 만드는걸 말한다.
<br />
<strong>캡슐화</strong> 의 정의와 비슷하지만 <strong>캡슐화</strong> 는 객체의 상태와 행동을 외부로부터 보호하고 객체 간 결합도를 낮추는데
<br />
목적이 있다면, <strong>추상화</strong> 는 객체를 단순화 하여 코드의 가독성과 유지보수성을 높이는데에 목적이 있다.
<br />
<strong>캡슐화</strong> 에선 접근제어자를 사용하지만, <strong>추상화</strong> 에선 인터페이스와 추상클래스를 사용한다.</p>

<ul>
  <li><strong>interface</strong>
    <ul>
      <li>추상메서드와 상수만을 가질 수 있다.</li>
      <li>인터페이스를 구현하는 클래스에선 모든 메서드를 구현해야 한다.</li>
      <li>다중 상속 지원</li>
      <li>
        <p>인터페이스 타입으로 변수 선언 후, 변수에 다양한 구현 객체를 대입할 수 있다.</p>
      </li>
      <li><strong>장점</strong>
        <ul>
          <li>다중상속을 지원해 다양한 클래스 간의 유연한 상호작용 가능</li>
          <li>구현객체간의 관계를 약화시켜 코드의 결합도를 낮출 수 있음</li>
        </ul>
      </li>
      <li><strong>단점</strong>
        <ul>
          <li>인터페이스를 구현하는 클래스에서 모든 메서드를 구현해야 하므로, 코드의 양이 증가</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여러개의 클래스에서 같은 인터페이스를 구현하면, 해당 인터페이스를 모든 코드에서 동일하 게 다룰 수 있다. 즉, 다형성</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="kd">implements</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car start"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Car stopp"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Motorcycle</span> <span class="kd">implements</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Motorcycle start"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Motorcycle stopp"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 인터페이스 타입으로 변수를 선언하고, 이 변수에 다양한 구현객체를 대입할 수 있다. 이를 통해 코드의 유연성을 높일 수 있다.</span>
<span class="nc">Vehicle</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span>
<span class="n">car</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">car</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>

<span class="nc">Vehicle</span> <span class="n">motorcycle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Motorcycle</span><span class="o">();</span>
<span class="n">motorcycle</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">motorcycle</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
</code></pre></div></div>

<ul>
  <li><strong>abstract class</strong>
    <ul>
      <li>추상메서드와 일반 메서드도 가질 수 있다.</li>
      <li>추상클래스를 구현하는 클래스에선 추상 메서드를 구현해야 한다.</li>
      <li>단일 상속만 지원</li>
      <li>인스턴스 생성 불가</li>
      <li>
        <p>추상클래스 타입으로 변수 선언 후, 변수에 다양한 구현 객체를 대입할 수 있다.</p>
      </li>
      <li><strong>장점</strong>
        <ul>
          <li>공통된 코드를 추상클래스에 구현하여 재사용성을 높일 수 있음</li>
          <li>일반메서드를 포함할 수 있으므로, 공통된 기능을 쉽게 구현할 수 있음</li>
        </ul>
      </li>
      <li><strong>단점</strong>
        <ul>
          <li>단일상속만을 지원해서, 기능확장에 한계가 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="kd">extends</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 자동차 악셀</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 자동차 브레이크</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 추상클래스 타입으로 변수를 선언하고, 이 변수에 다양한 구현객체를 대입할 수 있다.이를 통해 코드의 유연성을 높일 수 있다.</span>
<span class="nc">Vehicle</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">();</span>
<span class="nc">Vehicle</span> <span class="n">motorcycle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Motorcycle</span><span class="o">();</span>
</code></pre></div></div>

<p><br />
<br />
<br />
<br /></p>

<h3 id="oop와-다형성">OOP와 다형성</h3>
<p><br />
<strong>다형성</strong> 이란 객체가 동일한 메시지를 받았을 경우, 각각의 객체가 다르게 반응하도록 하는걸 말한다.
<br />
즉, 객체들이 동일한 메서드를 호출할 때, 이 메서드가 각 클래스에 따라 다르게 동작하는 것이다.
<br />
이러면 하나의 메서드가 다양한 형태로 동작하므로 재사용성과 유지보수성이 증가한다.
<br />
여러개의 클래스가 하나의 인터페이스를 구현할 수 있고, 인터페이스에 선언된 메서드는 각 클래스에서
<br />
오버라이딩 되어 동작하므로, 이 인터페이스의 메서드를 호출하는 코드는 각 클래스에 따라 동적으로 변하게 된다.
<br />
<br />
하지만, <strong>다형성</strong> 은 객체의 실제 타입을 런타임에 결정하기 때문에, 컴파일러가 정적으로 최적화 할 수 없어
<br />
성능저하를 가져올 수 있고 런타임 시에 오류가 발생할 수 있다.
<br />
또한 남발되면 객체 생성이 많아지고 코드의 가독성이 떨어지고 디버깅이 힘들어 지게 된다.</p>

<p><br />
<br />
<br />
<br /></p>

<h2 id="oop와-getter--setter">OOP와 Getter / Setter</h2>
<p><strong>Getter / Setter</strong> 는 <strong>캡슐화</strong> 의 원칙을 따르는 메서드 이다.
<br />
클래스의 인스턴스 변수에 직접 접근하는 걸 막고 클래스 내부에서 제어를 통해 인스턴스 변수에 접근하도록 한다.
<br />
하지만 과도하게 사용되면 변수에 직접 접근하지 않아도 간접적으로 접근하므로 캡슐화의 장점을 없애게 된다.
<br />
<br />
인스턴스 변수에 직접 접근하는것과 <strong>Getter / Setter</strong> 를 통해 접근하는것과 뭐가 다르냐고 생각할 수 있지만
<br />
인스턴스 변수가 <strong>public</strong> 으로 열려있으면 어디에서든지 접근할 수 있어서 캡슐화에 원칙에 완전히 위배되지만
<br />
<br />
<strong>Getter / Setter</strong> 를 통해 간접적으로 접근을 할 경우 적절한 제어를 통해 캡슐화를 유지할 수 있다.
<br />
여기서 적절한 제어란, <strong>Setter</strong> 에서 유효성 검사를 통해, 잘못된 값이 들어오는 걸 방지하는걸 말한다.</p>

<p><br />
<br />
<br />
<br /></p>

<p><br /></p>]]></content><author><name>NNIIE</name></author><category term="TIL" /><category term="OOP" /><category term="서브클래싱 / 서브타이핑" /><category term="OOP와 상속" /><category term="OOP와 캡슐화" /><category term="OOP와 추상화" /><category term="OOP와 다형성" /><category term="Getter / Setter" /><summary type="html"><![CDATA[]]></summary></entry></feed>